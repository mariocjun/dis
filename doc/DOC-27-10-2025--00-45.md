# Documentação do Projeto: DIS

**Gerado em:** 27/10/2025 às 00:45:09  
**Total de arquivos:** 27  
**Tamanho total:** 194.3KB  
**Extensões incluídas:** txt, cpp, hpp, py, yaml, csv

## Distribuição por tipo de arquivo

- **TXT**: 1 arquivo(s) - 3.2KB
- **CPP**: 7 arquivo(s) - 86.2KB
- **HPP**: 8 arquivo(s) - 79.3KB
- **PY**: 4 arquivo(s) - 16.5KB
- **YAML**: 1 arquivo(s) - 2.7KB
- **CSV**: 6 arquivo(s) - 6.5KB

---

# Estrutura do projeto:
```text
DIS/
┣━━ data
┃   ┣━━ check_toeplitz_structure.py (2.1KB)
┃   ┣━━ plot_convergence.py (10.1KB)
┃   ┗━━ spy_plot.py (3.1KB)
┣━━ include
┃   ┣━━ benchmark_runner.hpp (693B)
┃   ┣━━ config.hpp (2.4KB)
┃   ┣━━ io_utils.hpp (1.7KB)
┃   ┣━━ reporting.hpp (652B)
┃   ┣━━ solvers.hpp (4.5KB)
┃   ┣━━ types.hpp (3.1KB)
┃   ┗━━ utils.hpp (932B)
┣━━ output_csv
┃   ┣━━ convergence_history_30x30_g1_sparse_fista.csv (2.0KB)
┃   ┣━━ convergence_history_30x30_g1_sparse_precond.csv (356B)
┃   ┣━━ convergence_history_30x30_g1_sparse_standard.csv (644B)
┃   ┣━━ lcurve_30x30_g1_sparse_fista.csv (1.6KB)
┃   ┣━━ lcurve_30x30_g1_sparse_precond.csv (654B)
┃   ┗━━ lcurve_30x30_g1_sparse_standard.csv (1.2KB)
┣━━ src
┃   ┣━━ benchmark_runner.cpp (17.1KB)
┃   ┣━━ config.cpp (4.6KB)
┃   ┣━━ io_utils.cpp (17.3KB)
┃   ┣━━ reporting.cpp (7.8KB)
┃   ┣━━ solvers.cpp (23.0KB)
┃   ┗━━ utils.cpp (6.1KB)
┣━━ CMakeLists.txt (3.2KB)
┣━━ config.yaml (2.7KB)
┣━━ debug.py (1.2KB)
┣━━ main.cpp (10.3KB)
┗━━ solver_comparison.hpp (65.4KB)
```

---

# Código dos Arquivos

## arquivo CMakeLists.txt
```text
# The MiniCppStarter for Ultrasound Reconstruction
#
# Build and run by calling:
# cmake -S. -B build && cmake --build build && ./build/Playground

cmake_minimum_required(VERSION 3.16)

# ---- Project ----

project(UltrasoundServer LANGUAGES CXX)

# ---- Fetch CPM ----
# (Esta parte baixa o gerenciador de pacotes CPM, mantemos como está)
file(
        DOWNLOAD
        https://github.com/cpm-cmake/CPM.cmake/releases/download/v0.39.0/CPM.cmake
        ${CMAKE_CURRENT_BINARY_DIR}/cmake/CPM.cmake
        EXPECTED_HASH SHA256=66639BCAC9DD2907B2918DE466783554C1334446B9874E90D38E3778D404C2EF
)
include(${CMAKE_CURRENT_BINARY_DIR}/cmake/CPM.cmake)

# ---- Add dependencies via CPM ----

# MUDANÇA: Usando o repositório oficial do GitLab e a versão 5.0.0.
# O CPM fará o download do código-fonte. Como Eigen é "header-only",
# não há etapa de compilação para a própria biblioteca.
CPMAddPackage(
        NAME Eigen3
        VERSION 5.0.0
        GIT_REPOSITORY "https://gitlab.com/libeigen/eigen.git"
        GIT_TAG "5.0.0"
)

# yaml-cpp
CPMAddPackage(
        NAME yaml-cpp
        GIT_REPOSITORY "https://github.com/jbeder/yaml-cpp.git"
        GIT_TAG "0.8.0"
        OPTIONS
        "YAML_CPP_BUILD_TESTS OFF"
        "YAML_CPP_BUILD_TOOLS OFF"
)

# OpenMP
find_package(OpenMP REQUIRED)

# --- NOVO BLOCO 1: Encontrar o Python ---
# Adicionado para podermos chamar o script de documentação
find_package(Python3 REQUIRED)

# ---- Create executable ----
add_executable(UltrasoundBenchmark
        main.cpp
        src/config.cpp
        src/io_utils.cpp
        src/solvers.cpp
        src/utils.cpp
        src/benchmark_runner.cpp
        src/reporting.cpp
)

# ---- Link Libraries ----
target_link_libraries(UltrasoundBenchmark PRIVATE
        Eigen3::Eigen       # Eigen
        yaml-cpp::yaml-cpp  # yaml-cpp
        OpenMP::OpenMP_CXX  # OpenMP
)

# Necessário para std::filesystem no GCC < 9
if (CMAKE_CXX_COMPILER_ID STREQUAL "GNU" AND CMAKE_CXX_COMPILER_VERSION VERSION_LESS 9.0)
    target_link_libraries(UltrasoundBenchmark PRIVATE -lstdc++fs)
endif ()
if (CMAKE_CXX_COMPILER_ID STREQUAL "Clang" AND CMAKE_CXX_COMPILER_VERSION VERSION_LESS 7.0)
    target_link_libraries(UltrasoundBenchmark PRIVATE -lc++fs)
endif ()


# --- NOVO BLOCO 2: Comando Pós-Compilação ---
# Executa o script documentar.py toda vez que o 'UltrasoundBenchmark'
# for compilado com sucesso.
add_custom_command(
        TARGET UltrasoundBenchmark
        POST_BUILD  # Executa APÓS a compilação
        COMMAND
        # O comando que será executado no terminal
        ${Python3_EXECUTABLE} ${CMAKE_CURRENT_SOURCE_DIR}/documentar.py
        WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}
        COMMENT "Gerando documentação do projeto via documentar.py..."
)


# ---- Target Properties ----
set_target_properties(UltrasoundBenchmark PROPERTIES CXX_STANDARD 23) # Já definido globalmente

# Opcional: Otimizações de compilação para Release
target_compile_options(UltrasoundBenchmark PRIVATE $<$<CONFIG:Release>:-O3 -DNDEBUG>)
# Opcional: Flags de debug
target_compile_options(UltrasoundBenchmark PRIVATE $<$<CONFIG:Debug>:-g>)
```

## arquivo main.cpp
```cpp
#include <iostream>
#include <vector>
#include <string>
#include <filesystem> // Para manipulação de caminhos (C++17)
#include <chrono>     // Para timing (embora a maior parte esteja no header agora)
#include <iomanip>    // Para formatação da tabela
#include <sstream>    // Para formatar speedup
#include <omp.h>      // Para OpenMP info
#include <stdexcept>  // Para std::runtime_error
#include <algorithm>  // Para std::replace

// Inclui o header com a lógica de comparação e funções auxiliares/solvers
#include "solver_comparison.hpp"
#include "include/types.hpp"
#include "include/config.hpp"

// Removida a função create_output_directories daqui pois já existe em solver_comparison.hpp

// --- Função Principal (SIMPLIFICADA) ---
int main(int argc, char *argv[]) {
    std::cout << "======================================================" << std::endl;
    std::cout << " Comparativo: CGNR Standard vs Pre-condicionado vs FISTA" << std::endl;
    std::cout << "======================================================" << std::endl;

    // Carrega a configuração do YAML
    Config config = load_config("config.yaml");
    if (config.run_pipelines.empty()) {
        std::cerr << "[ERRO] Nenhum pipeline definido no arquivo de configuração." << std::endl;
        return 1;
    }

    // Pega apenas o primeiro pipeline (Sparse_Comparison)
    const auto &pipeline = config.run_pipelines[0];

    // Prepara o vetor de testes baseado no pipeline
    std::cout << "\n[INFO] Pipeline selecionado: " << pipeline.name << std::endl;
    std::cout << "[INFO] Datasets configurados: ";
    for (const auto &name: pipeline.dataset_names) {
        std::cout << name << " ";
    }
    std::cout << std::endl;

    std::vector<DatasetConfig> tests;
    for (const auto &dataset_name: pipeline.dataset_names) {
        std::cout << "[INFO] Processando dataset: " << dataset_name << std::endl;
        auto it = config.dataset_map.find(dataset_name);
        if (it != config.dataset_map.end()) {
            tests.push_back(*it->second);
            std::cout << "[INFO] Dataset " << dataset_name << " adicionado para processamento" << std::endl;
        } else {
            std::cout << "[AVISO] Dataset " << dataset_name << " não encontrado no mapa de configurações" << std::endl;
        }
    }

    std::cout << "[INFO] Total de datasets a serem processados: " << tests.size() << std::endl;

    // Configuração OpenMP
    Eigen::setNbThreads(omp_get_max_threads());
    std::cout << "\n[INFO] Usando " << Eigen::nbThreads() << " threads para os calculos Eigen.\n" << std::endl;

    // --- Pré-processamento (Apenas garante que o .sparse.bin existe) ---
    std::cout << "[INFO] Verificando/Criando arquivos binarios esparsos..." << std::endl;
    for (const auto &config: tests) {
        std::filesystem::path h_path = config.h_matrix_csv; // Correção aqui: usa h_matrix_csv
        if (!std::filesystem::exists(h_path)) {
            std::cerr << "[ERRO] Arquivo CSV da matriz H nao encontrado: " << config.h_matrix_csv << std::endl;
            return 1;
        }
        std::filesystem::path data_dir = h_path.parent_path();
        std::filesystem::path sparse_bin_fs_path = data_dir / (h_path.filename().string() + ".sparse.bin");
        std::string sparse_bin_path = sparse_bin_fs_path.string();

        if (!std::filesystem::exists(sparse_bin_fs_path)) {
            std::cout << "[AVISO] Criando arquivo binario esparso para " << config.h_matrix_csv << " em " <<
                    sparse_bin_path << "..." << std::endl;
            try {
                saveSparseMatrix(convertCsvToSparse(config.h_matrix_csv, config.image_rows * config.image_cols),
                                 sparse_bin_path);
                std::cout << "[SUCESSO] Arquivo binario esparso criado: " << sparse_bin_path << std::endl;
            } catch (const std::exception &e) {
                std::cerr << "[ERRO] Falha ao criar arquivo binario esparso: " << e.what() << std::endl;
                return 1;
            }
        }
    }
    std::cout << "[INFO] Pre-processamento concluido.\n" << std::endl;

    // Padronizar o caminho de saída para corresponder ao que o Python espera
    std::filesystem::path output_dir = "../output_csv";
    try {
        create_output_directories(output_dir); // Usa a função do solver_comparison.hpp
        std::cout << "[INFO] Estrutura de diretorios criada: " << std::filesystem::absolute(output_dir) << std::endl;
    } catch (const std::exception &e) {
        std::cerr << "[ERRO] Nao foi possivel criar os diretorios de saida: " << e.what() << std::endl;
        return 1;
    }

    // --- Loop Principal de Testes ---
    std::vector<std::tuple<std::string, PerformanceMetrics, PerformanceMetrics, PerformanceMetrics> > all_results;

    // Verificação adicional para garantir que estamos processando apenas os datasets selecionados
    std::cout << "\n[INFO] Verificando datasets a serem processados:" << std::endl;
    for (const auto &config: tests) {
        std::cout << "  - Dataset: " << config.name << " (" << config.description << ")" << std::endl;
        bool is_in_pipeline = std::find(pipeline.dataset_names.begin(),
                                        pipeline.dataset_names.end(),
                                        config.name) != pipeline.dataset_names.end();
        if (!is_in_pipeline) {
            std::cout << "[AVISO] Dataset " << config.name << " não está no pipeline atual. Ignorando." << std::endl;
            continue;
        }

        std::cout << "\n========================================\nINICIANDO TESTE: " << config.description <<
                // Usa .description
                "\n========================================" << std::endl;

        try {
            auto [fista_metrics, other_metrics] = run_sparse_comparison_with_fista(config);
            all_results.push_back({config.description, other_metrics.first, other_metrics.second, fista_metrics});
            std::cout << "Teste " << config.description << " concluido com sucesso." << std::endl;
        } catch (const std::exception &e) {
            std::cerr << "[ERRO FATAL] Falha ao executar comparacao para o teste " << config.description << ": " << e.
                    what() << std::endl;
        }
    }

    // --- Tabela Final de Resultados ---
    std::cout <<
            "\n\n======================================================================================================================================================"
            << std::endl;
    std::cout << "                                                    RELATORIO COMPARATIVO FINAL" << std::endl;
    std::cout <<
            "======================================================================================================================================================"
            << std::endl;
    std::cout << std::left
            << std::setw(22) << "Teste"
            << std::setw(28) << "Metodo"
            << std::setw(15) << "RAM (MB)"
            << std::setw(20) << "T. Carga (ms)"
            << std::setw(20) << "T. Solver (ms)"
            << std::setw(12) << "Iteracoes"
            << std::setw(15) << "Erro Final"
            << std::setw(15) << "Epsilon Final"
            << std::setw(15) << "Convergiu"
            << std::setw(15) << "Speedup"
            << std::endl;
    std::cout <<
            "------------------------------------------------------------------------------------------------------------------------------------------------------"
            << std::endl;

    for (const auto &[test_name, std_metrics, precond_metrics, fista_metrics]: all_results) {
        auto print_metric = [&](const PerformanceMetrics &m, const std::string &method_name, bool is_baseline) {
            if (m.load_time_ms <= 0 && m.solve_time_ms <= 0) {
                std::cout << std::left
                        << std::setw(22) << (is_baseline ? test_name : "")
                        << std::setw(28) << method_name
                        << std::setw(15 + 20 + 20 + 12 + 15 + 15 + 15) << " [FALHOU]"
                        << std::setw(14) << std::right << (is_baseline ? "BASELINE" : "N/A")
                        << std::endl;
                return;
            }

            std::cout << std::left
                    << std::setw(22) << (is_baseline ? test_name : "")
                    << std::setw(28) << method_name
                    << std::fixed << std::setprecision(2) << std::setw(15) << m.estimated_ram_mb
                    << std::fixed << std::setprecision(2) << std::setw(20) << m.load_time_ms
                    << std::fixed << std::setprecision(2) << std::setw(20) << m.solve_time_ms
                    << std::setw(12) << m.iterations
                    << std::scientific << std::setprecision(3) << std::setw(14) << m.final_error
                    << std::scientific << std::setprecision(3) << std::setw(14) << m.final_epsilon
                    << std::setw(15) << (m.converged ? "Sim" : "Nao (MaxIt)");

            if (is_baseline) {
                std::cout << std::setw(14) << std::right << "BASELINE";
            } else if (std_metrics.solve_time_ms > 0 && m.solve_time_ms > 0) {
                const double speedup = std_metrics.solve_time_ms / m.solve_time_ms;
                std::stringstream ss;
                ss << std::fixed << std::setprecision(2) << speedup << "x";
                std::cout << std::setw(14) << std::right << ss.str();
            } else {
                std::cout << std::setw(14) << std::right << "N/A";
            }
            std::cout << std::endl;
        };

        print_metric(std_metrics, "CGNR Standard", true);
        print_metric(precond_metrics, "CGNR Pre-condicionado", false);
        print_metric(fista_metrics, "FISTA L1", false);

        std::cout <<
                "------------------------------------------------------------------------------------------------------------------------------------------------------"
                << std::endl;
    }

    std::cout << "\nBenchmark concluido." << std::endl;
    std::cout << "[INFO] Para visualizar os graficos de convergencia, execute:" << std::endl;
    std::cout << "[INFO] python ../data/plot_convergence.py" << std::endl;
    return 0;
}
```

## arquivo benchmark_runner.cpp
```cpp
#include "../include/benchmark_runner.hpp" // Inclui a declaração da função principal do benchmark
#include "../include/types.hpp"           // Inclui as definições das structs (Resultados, Métricas, etc.)
#include "../include/config.hpp"          // Inclui a definição da classe Config
#include "../include/io_utils.hpp"        // Inclui as declarações das funções de I/O (load*, save*)
#include "../include/solvers.hpp"         // Inclui as declarações dos solvers (CGNR, Precondicionado, Fixo)
#include "../include/utils.hpp"           // Inclui a declaração da função de normalização

#include <iostream>                      // Para std::cout, std::cerr
#include <string>                        // Para std::string
#include <vector>                        // Para std::vector
#include <map>                           // Para std::map (armazenar resultados)
#include <chrono>                        // Para medição de tempo (high_resolution_clock)
#include <filesystem>                    // Para manipulação de caminhos (C++17)
#include <stdexcept>                     // Para std::runtime_error
#include <Eigen/Sparse>                  // Para Eigen::SparseMatrix
#include <Eigen/Dense>                   // Para Eigen::MatrixXd (caso reative testes densos)
#include <algorithm>                     // Para std::replace

// --- Implementação da Função Principal do Benchmark ---

BenchmarkResults run_benchmarks(const Config& config) {
    BenchmarkResults benchmark_results; // Estrutura para guardar todos os resultados
    const GlobalSettings& settings = config.settings; // Atalho para configurações globais

    std::cout << "\n======================================================" << std::endl;
    std::cout << "               INICIANDO BENCHMARKS" << std::endl;
    std::cout << "======================================================" << std::endl;

    // Garante que o diretório base de saída exista e cria subdiretório para CSVs
    std::filesystem::path base_output_dir = settings.output_base_dir;
    std::filesystem::path results_csv_dir = base_output_dir / "results_csv";
    try {
        std::filesystem::create_directories(results_csv_dir); // Cria o subdiretório para CSVs
        std::cout << "[INFO] Diretorio de saida CSV verificado/criado: " << std::filesystem::absolute(results_csv_dir) << std::endl;
    } catch (const std::filesystem::filesystem_error& e) {
        // Lança um erro se não conseguir criar o diretório essencial
        throw std::runtime_error("Nao foi possivel criar o diretorio de saida CSV: " + results_csv_dir.string() + " - " + e.what());
    }
    // Poderia criar subpastas para logs e PNGs aqui também, se necessário, de forma similar

    // Itera sobre cada pipeline definido no config.yaml
    for (const auto& pipeline : config.run_pipelines) {
        std::cout << "\n--- Iniciando Pipeline: " << pipeline.name << " (" << pipeline.description << ") ---" << std::endl;

        // Itera sobre cada dataset neste pipeline
        for (const std::string& dataset_name : pipeline.dataset_names) {
            // Encontra a configuração do dataset pelo nome
            auto ds_it = config.dataset_map.find(dataset_name);
            if (ds_it == config.dataset_map.end()) {
                std::cerr << "[AVISO] Dataset '" << dataset_name << "' definido no pipeline '" << pipeline.name << "' nao encontrado na lista de datasets. Pulando." << std::endl;
                continue;
            }
            const DatasetConfig& current_dataset = *ds_it->second;

            std::cout << "\n  -- Processando Dataset: " << current_dataset.description << " --" << std::endl;

            // Garante que a entrada no mapa de resultados para este dataset exista
            benchmark_results.results[current_dataset.name];

            // Itera sobre cada método neste pipeline
            for (const std::string& method_name : pipeline.method_names) {
                // Encontra a configuração do método pelo nome
                auto m_it = config.method_map.find(method_name);
                if (m_it == config.method_map.end()) {
                    std::cerr << "[AVISO] Metodo '" << method_name << "' definido no pipeline '" << pipeline.name << "' nao encontrado na lista de metodos. Pulando." << std::endl;
                    continue;
                }
                const MethodConfig& current_method = *m_it->second;

                std::cout << "\n    - Aplicando Metodo: " << current_method.description << " -" << std::endl;

                // --- Variáveis para esta execução específica ---
                PerformanceMetrics current_metrics;
                ReconstructionResult solver_result;
                // **** CORREÇÃO: Declarações movidas para dentro do loop ****
                std::chrono::high_resolution_clock::time_point load_start, load_end;
                double load_time_ms = 0;
                // **** FIM DA CORREÇÃO ****
                double ram_mb = 0;

                try {
                    // --- Carregamento dos Dados ---
                    // **** CORREÇÃO: Usa h_csv_path consistentemente ****
                    std::filesystem::path h_csv_path = current_dataset.h_matrix_csv;
                    std::filesystem::path data_dir = h_csv_path.parent_path();
                    // **** FIM DA CORREÇÃO ****
                    std::filesystem::path h_load_path; // Caminho final (CSV ou BIN) a ser carregado

                    bool is_sparse = (current_method.solver.find("cgnr") != std::string::npos);

                    if (current_method.use_binary) {
                        std::string bin_suffix = is_sparse ? ".sparse.bin" : ".dense.bin";
                        h_load_path = data_dir / (h_csv_path.filename().string() + bin_suffix); // Usa h_csv_path
                        if (!std::filesystem::exists(h_load_path)) {
                            throw std::runtime_error("Arquivo binario necessario '" + h_load_path.string() + "' nao encontrado (execute o pre-processamento).");
                        }
                         std::cout << "[INFO] Carregando H de: " << h_load_path.string() << std::endl;
                    } else {
                        h_load_path = h_csv_path; // Usa h_csv_path
                         if (!std::filesystem::exists(h_load_path)) {
                             throw std::runtime_error("Arquivo CSV necessario '" + h_load_path.string() + "' nao encontrado.");
                         }
                         std::cout << "[INFO] Carregando H de: " << h_load_path.string() << std::endl;
                    }

                    // Inicia a contagem do tempo de carregamento
                    load_start = std::chrono::high_resolution_clock::now();
                    // **** CORREÇÃO: g_signal_path -> g_signal_csv ****
                    Eigen::VectorXd g = loadVectorData(current_dataset.g_signal_csv);
                    // **** FIM DA CORREÇÃO ****

                    // Carrega H esparso ou denso
                    if (is_sparse) {
                        Eigen::SparseMatrix<double> H_sparse;
                        if (current_method.use_binary) {
                            H_sparse = loadSparseMatrix(h_load_path.string());
                        } else {
                             std::cout << "[INFO] Convertendo CSV esparso para memoria..." << std::endl;
                            H_sparse = convertCsvToSparse(h_load_path.string(), current_dataset.image_rows * current_dataset.image_cols);
                        }
                        // Finaliza a contagem do tempo de carregamento
                        load_end = std::chrono::high_resolution_clock::now();
                        // Calcula RAM estimada
                        ram_mb = static_cast<double>(H_sparse.nonZeros() * (sizeof(double) + sizeof(int)) + (H_sparse.outerSize() + 1) * sizeof(int)) / (1024.0 * 1024.0);

                        // Normalização
                        normalize_system_rows(H_sparse, g);

                        // Debug z0
                        Eigen::VectorXd z0 = H_sparse.transpose() * g;
                        std::cout << "[DEBUG " << current_method.name << "] Norma de z0 (H^T * g norm): " << z0.norm() << std::endl;

                        // Seleciona e Chama o Solver Esparso
                        std::string filename_prefix = "image_" + current_dataset.name + "_" + current_method.name;

                        if (current_method.solver == "cgnr_standard") {
                            std::cout << "[INFO] Chamando solver: cgnr_standard..." << std::endl;
                            solver_result = run_cgnr_solver_epsilon_save_iters(g, H_sparse, settings.epsilon_tolerance, settings.max_iterations,
                                (settings.save_intermediate_images ? filename_prefix : ""), results_csv_dir, current_dataset.image_rows, current_dataset.image_cols);
                        } else if (current_method.solver == "cgnr_preconditioned") {
                             std::cout << "[INFO] Chamando solver: cgnr_preconditioned..." << std::endl;
                             solver_result = run_cgnr_solver_preconditioned_save_iters(g, H_sparse, settings.epsilon_tolerance, settings.max_iterations,
                                (settings.save_intermediate_images ? filename_prefix : ""), results_csv_dir, current_dataset.image_rows, current_dataset.image_cols);
                        }
                        // else if (current_method.solver == "fista") { ... }
                        else {
                            throw std::runtime_error("Solver esparso desconhecido ou nao implementado: " + current_method.solver);
                        }

                         // Gerar CSVs de histórico/L-curve
                         Eigen::SparseMatrix<double> H_fixed;
                         if (current_method.use_binary) H_fixed = loadSparseMatrix(h_load_path.string());
                         else H_fixed = convertCsvToSparse(h_load_path.string(), current_dataset.image_rows * current_dataset.image_cols);
                         // **** CORREÇÃO: g_signal_path -> g_signal_csv ****
                         Eigen::VectorXd g_fixed = loadVectorData(current_dataset.g_signal_csv);
                         // **** FIM DA CORREÇÃO ****
                         normalize_system_rows(H_fixed, g_fixed);
                         ReconstructionResult res_fixed = run_cgnr_solver_fixed_iter(g_fixed, H_fixed, settings.max_iterations);
                         std::filesystem::path hist_path = results_csv_dir / ("convergence_history_" + current_dataset.name + "_" + current_method.name + ".csv");
                         std::filesystem::path lcurve_path = results_csv_dir / ("lcurve_" + current_dataset.name + "_" + current_method.name + ".csv");
                         saveHistoryToCSV(res_fixed.residual_history, hist_path.string());
                         saveLcurveToCSV(res_fixed, lcurve_path.string());

                    } else { // Carrega Denso
                        Eigen::MatrixXd H_dense;
                        if (current_method.use_binary) {
                            H_dense = loadDenseMatrix(h_load_path.string());
                        } else {
                            std::cout << "[INFO] Convertendo CSV denso para memoria..." << std::endl;
                            H_dense = loadDenseData(h_load_path.string());
                        }
                        load_end = std::chrono::high_resolution_clock::now();
                        ram_mb = static_cast<double>(H_dense.rows()) * H_dense.cols() * sizeof(double) / (1024.0 * 1024.0);

                        normalize_system_rows(H_dense, g);
                        Eigen::VectorXd z0 = H_dense.transpose() * g;
                        std::cout << "[DEBUG " << current_method.name << "] Norma de z0 (H^T * g norm): " << z0.norm() << std::endl;

                        std::string filename_prefix = "image_" + current_dataset.name + "_" + current_method.name;
                        if (current_method.solver == "cgnr_standard") {
                             std::cout << "[INFO] Chamando solver: cgnr_standard (Denso)..." << std::endl;
                             solver_result = run_cgnr_solver_epsilon_save_iters(g, H_dense, settings.epsilon_tolerance, settings.max_iterations,
                                (settings.save_intermediate_images ? filename_prefix : ""), results_csv_dir, current_dataset.image_rows, current_dataset.image_cols);
                        }
                        else {
                             throw std::runtime_error("Solver denso desconhecido ou nao suportado: " + current_method.solver);
                        }

                         // Gerar CSVs de histórico/L-curve
                         Eigen::MatrixXd H_fixed;
                         if (current_method.use_binary) H_fixed = loadDenseMatrix(h_load_path.string());
                         else H_fixed = loadDenseData(h_load_path.string());
                         // **** CORREÇÃO: g_signal_path -> g_signal_csv ****
                         Eigen::VectorXd g_fixed = loadVectorData(current_dataset.g_signal_csv);
                         // **** FIM DA CORREÇÃO ****
                         normalize_system_rows(H_fixed, g_fixed);
                         ReconstructionResult res_fixed = run_cgnr_solver_fixed_iter(g_fixed, H_fixed, settings.max_iterations);
                         std::filesystem::path hist_path = results_csv_dir / ("convergence_history_" + current_dataset.name + "_" + current_method.name + ".csv");
                         std::filesystem::path lcurve_path = results_csv_dir / ("lcurve_" + current_dataset.name + "_" + current_method.name + ".csv");
                         saveHistoryToCSV(res_fixed.residual_history, hist_path.string());
                         saveLcurveToCSV(res_fixed, lcurve_path.string());
                    }

                    // --- Coleta Métricas ---
                    // **** CORREÇÃO: Linha que dava erro de 'start_load' ****
                    load_time_ms = std::chrono::duration<double, std::milli>(load_end - load_start).count();
                    // **** FIM DA CORREÇÃO ****
                    current_metrics.load_time_ms = load_time_ms;
                    current_metrics.estimated_ram_mb = ram_mb;
                    current_metrics.solve_time_ms = solver_result.execution_time_ms;
                    current_metrics.iterations = solver_result.iterations;
                    current_metrics.final_error = solver_result.final_error;
                    current_metrics.final_epsilon = solver_result.final_epsilon;
                    current_metrics.converged = solver_result.converged;
                    current_metrics.optimization_type = current_method.solver; // Guarda qual solver foi usado


                    // Salva a imagem final (se não salvou intermediárias)
                    if (!settings.save_intermediate_images && solver_result.image.size() > 0) {
                         std::string final_img_filename = "image_" + current_dataset.name + "_" + current_method.name + "_final.csv";
                         std::filesystem::path final_img_path = results_csv_dir / final_img_filename;
                         try {
                              saveImageVectorToCsv(solver_result.image, final_img_path.string(), current_dataset.image_rows, current_dataset.image_cols);
                         } catch (const std::exception& e) {
                             std::cerr << "[AVISO] Falha ao salvar imagem final: " << e.what() << std::endl;
                         }
                    }


                } catch (const std::exception& e) {
                    std::cerr << "[ERRO] Falha ao processar Metodo '" << current_method.name << "' no Dataset '" << current_dataset.name << "': " << e.what() << std::endl;
                    current_metrics = PerformanceMetrics(); // Zera métricas
                    current_metrics.optimization_type = current_method.solver; // Atribui tipo mesmo em erro
                }

                // Armazena as métricas no mapa de resultados
                benchmark_results.results[current_dataset.name][current_method.name] = current_metrics;

                 if (current_method.is_baseline && benchmark_results.baseline_method == nullptr) {
                    benchmark_results.baseline_method = &current_method;
                 }

                std::cout << "    - Metodo '" << current_method.name << "' concluido." << std::endl;

            } // Fim loop methods
             std::cout << "  -- Dataset '" << current_dataset.name << "' concluido. --" << std::endl;
        } // Fim loop datasets
         std::cout << "--- Pipeline '" << pipeline.name << "' concluido. ---" << std::endl;
    } // Fim loop pipelines

    std::cout << "\n======================================================" << std::endl;
    std::cout << "               BENCHMARKS CONCLUIDOS" << std::endl;
    std::cout << "======================================================" << std::endl;

    return benchmark_results;
}
```

## arquivo config.cpp
```cpp
#include "../include/config.hpp"
#include <yaml-cpp/yaml.h>
#include <iostream>
#include <stdexcept>

Config load_config(const std::string& config_path) {
    Config config;
    try {
        YAML::Node yaml = YAML::LoadFile(config_path);

        // Carrega as configurações globais
        if (yaml["settings"]) {
            auto settings = yaml["settings"];
            config.settings.output_base_dir = settings["output_base_dir"].as<std::string>();
            config.settings.epsilon_tolerance = settings["epsilon_tolerance"].as<double>();
            config.settings.max_iterations = settings["max_iterations"].as<int>();
            config.settings.save_intermediate_images = settings["save_intermediate_images"].as<bool>();
            config.settings.num_omp_threads = settings["num_omp_threads"].as<int>();
        }

        // Carrega os datasets
        if (yaml["datasets"]) {
            for (const auto& dataset : yaml["datasets"]) {
                DatasetConfig dc;
                dc.name = dataset["name"].as<std::string>();
                dc.description = dataset["description"].as<std::string>();
                dc.h_matrix_csv = dataset["h_matrix_csv"].as<std::string>();
                dc.g_signal_csv = dataset["g_signal_csv"].as<std::string>();
                dc.image_rows = dataset["image_rows"].as<int>();
                dc.image_cols = dataset["image_cols"].as<int>();
                config.datasets.push_back(dc);
            }
        }

        // Carrega os métodos
        if (yaml["methods"]) {
            for (const auto& method : yaml["methods"]) {
                MethodConfig mc;
                mc.name = method["name"].as<std::string>();
                mc.description = method["description"].as<std::string>();
                mc.solver = method["solver"].as<std::string>();
                mc.use_binary = method["use_binary"].as<bool>();
                mc.is_baseline = method["is_baseline"].as<bool>();
                config.methods.push_back(mc);
            }
        }

        // Carrega os pipelines
        if (yaml["run_pipelines"]) {
            for (const auto& pipeline : yaml["run_pipelines"]) {
                PipelineConfig pc;
                pc.name = pipeline["name"].as<std::string>();
                pc.description = pipeline["description"].as<std::string>();
                pc.method_names = pipeline["methods"].as<std::vector<std::string>>();
                pc.dataset_names = pipeline["datasets"].as<std::vector<std::string>>();
                config.run_pipelines.push_back(pc);
            }
        }

        // Popula os mapas para acesso rápido
        config.populate_maps();

        // Validação do pipeline
        std::cout << "\n[INFO] Validando pipeline..." << std::endl;
        for (const auto& pipeline : config.run_pipelines) {
            std::cout << "\nPipeline: " << pipeline.name << std::endl;
            std::cout << "Datasets configurados:" << std::endl;
            for (const auto& dataset_name : pipeline.dataset_names) {
                if (config.dataset_map.find(dataset_name) == config.dataset_map.end()) {
                    throw std::runtime_error("Dataset '" + dataset_name + "' configurado no pipeline '" +
                                          pipeline.name + "' não foi encontrado na lista de datasets disponíveis");
                }
                std::cout << "  - " << dataset_name << std::endl;
            }

            std::cout << "Métodos configurados:" << std::endl;
            for (const auto& method_name : pipeline.method_names) {
                if (config.method_map.find(method_name) == config.method_map.end()) {
                    throw std::runtime_error("Método '" + method_name + "' configurado no pipeline '" +
                                          pipeline.name + "' não foi encontrado na lista de métodos disponíveis");
                }
                std::cout << "  - " << method_name << std::endl;
            }
        }

        std::cout << "\n[INFO] Configuração carregada com sucesso de: " << config_path << std::endl;
        if (!config.run_pipelines.empty()) {
            std::cout << "[INFO] Pipeline ativo: " << config.run_pipelines[0].name << std::endl;
            std::cout << "[INFO] Dataset(s) a processar:";
            for (const auto& dataset : config.run_pipelines[0].dataset_names) {
                std::cout << " " << dataset;
            }
            std::cout << std::endl;
        }

    } catch (const YAML::Exception& e) {
        throw std::runtime_error("Erro ao carregar configuração YAML: " + std::string(e.what()));
    }

    return config;
}
```

## arquivo io_utils.cpp
```cpp
#include "../include/io_utils.hpp" // Inclui as declarações
#include <fstream>
#include <sstream>
#include <vector>
#include <string>
#include <stdexcept>
#include <iostream>
#include <algorithm> // Para std::remove_if, std::all_of
#include <cmath>     // Para std::abs, std::sqrt
#include <iomanip>    // Para std::scientific, std::setprecision
#include <Eigen/Dense>
#include <Eigen/Sparse>

// --- Implementações das Funções de Carregamento ---

Eigen::VectorXd loadVectorData(const std::string &path) {
    std::ifstream file(path);
    if (!file.is_open()) throw std::runtime_error("Nao foi possivel abrir o arquivo: " + path);
    std::vector<double> values;
    std::string line;
    int line_num = 0;
    while (std::getline(file, line)) {
        line_num++;
        // C++17 compatível:
        if (line.empty() || std::all_of(line.begin(), line.end(), ::isspace)) continue;
        std::stringstream lineStream(line);
        std::string cell;
        while (std::getline(lineStream, cell, ',')) {
            try {
                // C++17 compatível:
                cell.erase(std::remove_if(cell.begin(), cell.end(), ::isspace), cell.end());
                if (!cell.empty()) {
                    values.push_back(std::stod(cell));
                }
            } catch (const std::invalid_argument &) {
                 std::cerr << "[AVISO] Ignorando valor nao numerico em: " << path << ", linha: " << line_num << ", celula: '" << cell << "'" << std::endl;
            } catch (const std::out_of_range &) {
                 std::cerr << "[AVISO] Ignorando valor fora do range em: " << path << ", linha: " << line_num << ", celula: '" << cell << "'" << std::endl;
            }
        }
    }
     if (values.empty()) {
        throw std::runtime_error("Nenhum dado numerico valido encontrado em: " + path);
    }
    Eigen::Map<Eigen::VectorXd> vec_map(values.data(), values.size());
    return Eigen::VectorXd(vec_map);
}

Eigen::MatrixXd loadDenseData(const std::string &path) {
    std::ifstream file(path);
    if (!file.is_open()) throw std::runtime_error("Nao foi possivel abrir o arquivo: " + path);
    std::vector<double> values;
    std::string line;
    int rows = 0;
    long long cols = -1;
    int line_num = 0;

    while (std::getline(file, line)) {
        line_num++;
        // C++17 compatível:
        if (line.empty() || std::all_of(line.begin(), line.end(), ::isspace)) continue;

        std::stringstream lineStream(line);
        std::string cell;
        long long current_cols = 0;
        std::vector<double> row_values;

        while (std::getline(lineStream, cell, ',')) {
             try {
                 // C++17 compatível:
                 cell.erase(std::remove_if(cell.begin(), cell.end(), ::isspace), cell.end());
                 if (!cell.empty()) {
                    row_values.push_back(std::stod(cell));
                 } else {
                     row_values.push_back(0.0);
                     std::cerr << "[AVISO] Celula vazia encontrada em: " << path << ", linha: " << line_num << ", coluna: " << current_cols+1 << ". Assumindo 0.0." << std::endl;
                 }
                current_cols++;
            } catch (const std::invalid_argument &) {
                 std::cerr << "[AVISO] Ignorando valor nao numerico em: " << path << ", linha: " << line_num << ", celula: '" << cell << "'" << std::endl;
                 row_values.push_back(0.0);
                 current_cols++;
            } catch (const std::out_of_range &) {
                 std::cerr << "[AVISO] Ignorando valor fora do range em: " << path << ", linha: " << line_num << ", celula: '" << cell << "'" << std::endl;
                 row_values.push_back(0.0);
                 current_cols++;
            }
        }

        if (cols == -1) {
             if (current_cols == 0) continue;
             cols = current_cols;
        } else if (current_cols != cols) {
             std::cerr << "[ERRO] Numero inconsistente de colunas na linha " << line_num << " do arquivo " << path << ". Esperado: " << cols << ", Encontrado: " << current_cols << ". Abortando." << std::endl;
             throw std::runtime_error("Inconsistencia de colunas no CSV denso.");
        }

        values.insert(values.end(), row_values.begin(), row_values.end());
        rows++;
    }
     if (rows == 0 || cols <= 0 || values.empty()) {
         throw std::runtime_error("Nao foi possivel carregar dados validos da matriz densa de: " + path + " (rows=" + std::to_string(rows) + ", cols=" + std::to_string(cols) + ")");
     }

    Eigen::Map<Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor> > mat_map(values.data(), rows, cols);
    return Eigen::MatrixXd(mat_map);
}

Eigen::MatrixXd loadDenseMatrix(const std::string &path) {
    std::ifstream file(path, std::ios::binary);
    if (!file.is_open()) throw std::runtime_error("Nao foi possivel abrir o arquivo binario: " + path);
    Eigen::Index rows, cols;
    file.read(reinterpret_cast<char *>(&rows), sizeof(rows));
    file.read(reinterpret_cast<char *>(&cols), sizeof(cols));

    if (!file || file.eof()) throw std::runtime_error("Erro ao ler cabecalho do arquivo binario denso: " + path);
    if (rows <= 0 || cols <= 0) throw std::runtime_error("Dimensoes invalidas ("+ std::to_string(rows) + "x" + std::to_string(cols) +") lidas do arquivo binario denso: " + path);

    Eigen::MatrixXd mat(rows, cols);
    file.read(reinterpret_cast<char *>(mat.data()), static_cast<std::streamsize>(rows) * cols * sizeof(double));
    if (!file){
          if (file.eof() && (static_cast<std::streamsize>(rows) * cols * sizeof(double) > 0)) {
              throw std::runtime_error("Fim de arquivo inesperado ao ler dados do arquivo binario denso: " + path);
         } else if (!file.eof()) {
              throw std::runtime_error("Erro de leitura ao processar dados do arquivo binario denso: " + path);
         }
    }
    return mat;
}

Eigen::SparseMatrix<double> convertCsvToSparse(const std::string &path, int expected_cols) {
    std::ifstream file(path);
    if (!file.is_open()) throw std::runtime_error("Nao foi possivel abrir o arquivo: " + path);
    std::vector<Eigen::Triplet<double> > tripletList;
    std::string line;
    int row = 0;
    long long actual_cols = -1;
    int line_num = 0;

    while (std::getline(file, line)) {
        line_num++;
        // C++17 compatível:
        if (line.empty() || std::all_of(line.begin(), line.end(), ::isspace)) continue;

        std::stringstream lineStream(line);
        std::string cell;
        int col = 0;
        while (std::getline(lineStream, cell, ',')) {
            try {
                // C++17 compatível:
                cell.erase(std::remove_if(cell.begin(), cell.end(), ::isspace), cell.end());
                if (!cell.empty()) {
                    double value = std::stod(cell);
                    if (std::abs(value) > 1e-12) {
                        tripletList.emplace_back(row, col, value);
                    }
                }
            } catch (const std::invalid_argument &) {
                 std::cerr << "[AVISO] Ignorando valor nao numerico em CSV esparso: " << path << ", linha: " << line_num
                           << ", celula: '" << cell << "'" << std::endl;
            } catch (const std::out_of_range &) {
                 std::cerr << "[AVISO] Ignorando valor fora do range em CSV esparso: " << path << ", linha: " << line_num
                           << ", celula: '" << cell << "'" << std::endl;
            }
            col++;
        }
         if (actual_cols == -1) {
            if (col == 0) continue;
             actual_cols = col;
         } else if (col != actual_cols) {
             std::cerr << "[ERRO] Numero inconsistente de colunas na linha " << line_num << " do arquivo esparso " <<
                     path << ". Esperado: " << actual_cols << ", Encontrado: " << col << ". Abortando." << std::endl;
              throw std::runtime_error("Inconsistencia de colunas no CSV esparso.");
         }
        row++;
    }
     if (row == 0 || actual_cols <= 0) {
         throw std::runtime_error("Nao foi possivel ler nenhuma linha/coluna valida do arquivo esparso: " + path);
     }
     if (expected_cols > 0 && actual_cols != expected_cols) {
          std::cerr << "[AVISO] Numero de colunas lido (" << actual_cols << ") difere do esperado (" << expected_cols <<
                   ") para " << path << ". Usando o numero lido." << std::endl;
     }

    Eigen::SparseMatrix<double> mat(row, actual_cols);
    if (!tripletList.empty()) {
        mat.setFromTriplets(tripletList.begin(), tripletList.end());
    } else {
         std::cerr << "[AVISO] Nenhum elemento nao-zero (acima de 1e-12) encontrado em " << path << std::endl;
    }
    mat.makeCompressed();
    return mat;
}


Eigen::SparseMatrix<double> loadSparseMatrix(const std::string &path) {
     std::ifstream file(path, std::ios::binary);
    if (!file.is_open()) throw std::runtime_error("Nao foi possivel abrir o arquivo binario: " + path);
    Eigen::Index rows, cols;
    Eigen::Index nonZeros;
    file.read(reinterpret_cast<char *>(&rows), sizeof(rows));
    file.read(reinterpret_cast<char *>(&cols), sizeof(cols));
    file.read(reinterpret_cast<char *>(&nonZeros), sizeof(nonZeros));

    if (!file || file.eof()) throw std::runtime_error("Erro ao ler cabecalho do arquivo binario esparso: " + path);
    if (rows < 0 || cols < 0 || nonZeros < 0) throw std::runtime_error("Dimensoes invalidas (" + std::to_string(rows) + "x" + std::to_string(cols) + ", nnz=" + std::to_string(nonZeros) + ") lidas do arquivo binario esparso: " + path);

    Eigen::SparseMatrix<double> mat(rows, cols);
    mat.makeCompressed();
    mat.resizeNonZeros(nonZeros);

    if (nonZeros > 0) {
        if (!mat.valuePtr() || !mat.innerIndexPtr()){
            throw std::runtime_error("Ponteiros value/inner invalidos apos resizeNonZeros ao carregar: " + path);
        }
        file.read(reinterpret_cast<char *>(mat.valuePtr()), nonZeros * sizeof(double));
        file.read(reinterpret_cast<char *>(mat.innerIndexPtr()), nonZeros * sizeof(int));
    }

     if (!mat.outerIndexPtr()) {
          throw std::runtime_error("Ponteiro outerIndex invalido apos makeCompressed ao carregar: " + path);
     }
    file.read(reinterpret_cast<char *>(mat.outerIndexPtr()), (mat.outerSize() + 1) * sizeof(int));

    if (!file) {
         if (file.eof()) {
              std::cerr << "[AVISO] Fim de arquivo prematuro ao ler dados de " << path << ". A matriz pode estar incompleta." << std::endl;
              throw std::runtime_error("Fim de arquivo inesperado ao ler dados do arquivo binario esparso: " + path);
         } else {
              throw std::runtime_error("Erro de leitura ao processar dados do arquivo binario esparso: " + path);
         }
    }
    mat.finalize();
    return mat;
}

// --- Implementações das Funções de Salvamento ---

void saveDenseMatrix(const Eigen::MatrixXd &mat, const std::string &path) {
    std::ofstream file(path, std::ios::binary | std::ios::trunc);
    if (!file.is_open()) throw std::runtime_error("Nao foi possivel criar o arquivo binario: " + path);
    const auto rows = mat.rows(), cols = mat.cols();
    file.write(reinterpret_cast<const char *>(&rows), sizeof(rows));
    file.write(reinterpret_cast<const char *>(&cols), sizeof(cols));
    file.write(reinterpret_cast<const char *>(mat.data()), static_cast<std::streamsize>(rows) * cols * sizeof(double));
     if (!file) throw std::runtime_error("Erro ao escrever no arquivo binario denso: " + path);
    file.close();
     if (!file) throw std::runtime_error("Erro ao fechar o arquivo binario denso: " + path);
}

void saveSparseMatrix(const Eigen::SparseMatrix<double> &mat, const std::string &path) {
    std::ofstream file(path, std::ios::binary | std::ios::trunc);
    if (!file.is_open()) throw std::runtime_error("Nao foi possivel criar o arquivo binario: " + path);

    Eigen::SparseMatrix<double> compressed_mat = mat;
    if (!compressed_mat.isCompressed()) {
        compressed_mat.makeCompressed();
    }

    const auto rows = compressed_mat.rows();
    const auto cols = compressed_mat.cols();
    const auto nonZeros = compressed_mat.nonZeros();
    const auto outerSize = compressed_mat.outerSize();

    file.write(reinterpret_cast<const char *>(&rows), sizeof(rows));
    file.write(reinterpret_cast<const char *>(&cols), sizeof(cols));
    file.write(reinterpret_cast<const char *>(&nonZeros), sizeof(nonZeros));

    if (nonZeros > 0) {
        if (!compressed_mat.valuePtr() || !compressed_mat.innerIndexPtr()) {
             throw std::runtime_error("Ponteiros internos invalidos ao salvar matriz esparsa para: " + path);
        }
        file.write(reinterpret_cast<const char *>(compressed_mat.valuePtr()), nonZeros * sizeof(double));
        file.write(reinterpret_cast<const char *>(compressed_mat.innerIndexPtr()), nonZeros * sizeof(int));
    }
     if (!compressed_mat.outerIndexPtr()) {
          throw std::runtime_error("Ponteiro outerIndex invalido ao salvar matriz esparsa para: " + path);
     }
    file.write(reinterpret_cast<const char *>(compressed_mat.outerIndexPtr()), (outerSize + 1) * sizeof(int));

    if (!file) throw std::runtime_error("Erro ao escrever no arquivo binario esparso: " + path);
    file.close();
    if (!file) throw std::runtime_error("Erro ao fechar o arquivo binario esparso: " + path);
}


void saveHistoryToCSV(const std::vector<double>& history, const std::string &filename) {
    std::ofstream file(filename);
    if (!file.is_open()) {
        std::cerr << "[AVISO] Nao foi possivel criar o arquivo de historico: " << filename << std::endl;
        return;
    }
    file << "Iteration,ResidualNorm\n";
    for (size_t i = 0; i < history.size(); ++i) {
        file << i + 1 << "," << std::scientific << std::setprecision(8) << history[i] << "\n";
    }
     if (!file) {
         std::cerr << "[AVISO] Erro ao escrever no arquivo de historico: " << filename << std::endl;
     } else {
        // Removido cout daqui para evitar poluir a saída do benchmark
        // std::cout << "[INFO] Historico de convergencia salvo em: " << filename << std::endl;
     }
    file.close();
}

void saveLcurveToCSV(const ReconstructionResult &result, const std::string &filename) {
    if (result.residual_history.size() != result.solution_history.size()) {
         std::cerr << "[AVISO] Tamanhos incompativeis (" << result.residual_history.size() << " vs "
                   << result.solution_history.size() << ") de historico de residuo e solucao para L-curve. Nao salvando " << filename << std::endl;
        return;
    }
     if (result.residual_history.empty()) {
         // std::cerr << "[AVISO] Historico vazio, nada para salvar em L-curve: " << filename << std::endl; // Opcional
         return;
     }
    std::ofstream file(filename);
    if (!file.is_open()) {
        std::cerr << "[AVISO] Nao foi possivel criar o arquivo de cotovelo: " << filename << std::endl;
        return;
    }
    file << "Iteration,SolutionNorm,ResidualNorm\n";
    for (size_t i = 0; i < result.residual_history.size(); ++i) {
        file << i + 1 << ","
             << std::scientific << std::setprecision(8) << result.solution_history[i] << ","
             << std::scientific << std::setprecision(8) << result.residual_history[i] << "\n";
    }
    if (!file) {
         std::cerr << "[AVISO] Erro ao escrever no arquivo L-curve: " << filename << std::endl;
     } else {
        // Removido cout daqui
        // std::cout << "[INFO] Dados L-curve salvos em: " << filename << std::endl;
     }
    file.close();
}

void saveImageVectorToCsv(const Eigen::VectorXd& vec, const std::string& filename, int img_rows, int img_cols) {
     if (vec.size() != static_cast<long long>(img_rows) * img_cols) {
         std::cerr << "[AVISO] Tamanho do vetor (" << vec.size() << ") nao corresponde as dimensoes da imagem ("
                   << img_rows << "x" << img_cols << "). Nao salvando imagem: " << filename << std::endl;
         return;
     }
     if (img_rows <= 0 || img_cols <= 0) {
          std::cerr << "[AVISO] Dimensoes invalidas da imagem (" << img_rows << "x" << img_cols
                    << "). Nao salvando imagem: " << filename << std::endl;
          return;
     }

    std::ofstream file(filename);
    if (!file.is_open()) {
        std::cerr << "[AVISO] Nao foi possivel criar o arquivo CSV da imagem: " << filename << std::endl;
        return;
    }

    file << std::scientific << std::setprecision(8);

    for (int i = 0; i < img_rows; ++i) {
        for (int j = 0; j < img_cols; ++j) {
            long long index = static_cast<long long>(j) * img_rows + i; // ColMajor Indexing
            if (index < vec.size()) {
                file << vec(index);
            } else {
                 file << 0.0;
            }
            if (j < img_cols - 1) {
                file << ",";
            }
        }
        file << "\n";
    }

    if (!file) {
         std::cerr << "[AVISO] Erro ao escrever no arquivo CSV da imagem: " << filename << std::endl;
     } else {
         // Removido cout daqui
         // std::cout << "[INFO] Imagem reconstruida salva em: " << filename << std::endl;
     }
    file.close();
}
```

## arquivo reporting.cpp
```cpp
#include "../include/reporting.hpp" // Inclui a declaração da função
#include "../include/types.hpp"   // Para as structs de dados
#include "../include/config.hpp"  // Para acessar descrições, etc.
#include <iostream>
#include <iomanip>    // Para formatação (setw, setprecision, etc.)
#include <sstream>    // Para formatar o speedup
#include <map>
#include <string>
#include <vector>
#include <fstream>    // Para salvar o relatório em arquivo (opcional)
#include <filesystem> // Para construir o caminho do arquivo de relatório

// --- Implementação da Geração do Relatório ---

void generate_report(const BenchmarkResults& benchmark_results, const Config& config) {
    // String stream para construir o relatório (para console e arquivo)
    std::stringstream report_ss;

    // --- Cabeçalho do Relatório ---
    report_ss << "\n\n======================================================================================================================================================" << std::endl;
    report_ss << "                                           RELATORIO COMPARATIVO FINAL (ESPARSO)" << std::endl;
    report_ss << "======================================================================================================================================================" << std::endl;
    report_ss << std::left
              << std::setw(22) << "Teste"
              << std::setw(28) << "Metodo Otimizado"
              << std::setw(15) << "RAM (MB)"
              << std::setw(20) << "T. Carga (ms)"
              << std::setw(20) << "T. Solver (ms)"
              << std::setw(12) << "Iteracoes"
              << std::setw(15) << "Erro Final"
              << std::setw(15) << "Epsilon Final"
              << std::setw(15) << "Convergiu (Eps)"
              << std::setw(15) << "vs Standard" // Comparação vs standard (baseline)
              << std::endl;
    report_ss << "------------------------------------------------------------------------------------------------------------------------------------------------------" << std::endl;

    // --- Itera sobre os resultados por dataset ---
    // Usamos config.datasets para manter a ordem original
    for (const auto& dataset_config : config.datasets) {
        const std::string& dataset_name = dataset_config.name;

        // Verifica se há resultados para este dataset
        auto dataset_results_it = benchmark_results.results.find(dataset_name);
        if (dataset_results_it == benchmark_results.results.end()) {
            continue; // Pula se nenhum método rodou para este dataset
        }
        const auto& method_results_map = dataset_results_it->second;

        // Encontra as métricas do baseline (standard) para este dataset, se existirem
        const PerformanceMetrics* baseline_metrics_ptr = nullptr;
        std::string baseline_method_name = "sparse_standard"; // Assume que este é o baseline
        auto baseline_it = method_results_map.find(baseline_method_name);
        if (baseline_it != method_results_map.end()) {
            baseline_metrics_ptr = &baseline_it->second;
        }
        bool baseline_valid = baseline_metrics_ptr && baseline_metrics_ptr->solve_time_ms > 0;

        bool first_method_for_dataset = true; // Para imprimir o nome do teste só uma vez

        // Itera sobre os métodos na ordem definida na config, para consistência
        for (const auto& method_config : config.methods) {
             // Verifica se este método foi executado para este dataset
             auto metrics_it = method_results_map.find(method_config.name);
             if (metrics_it == method_results_map.end()) {
                 continue; // Pula se este método não rodou para este dataset
             }
             const PerformanceMetrics& m = metrics_it->second;
             bool is_baseline = (method_config.name == baseline_method_name);

             // Imprime a linha da métrica
             // Verifica se houve erro (métricas zeradas na função de comparação)
            if (m.load_time_ms <= 0 && m.solve_time_ms <= 0 && m.estimated_ram_mb <= 0 && m.iterations == 0 && m.optimization_type != "none") {
                 report_ss << std::left
                           << std::setw(22) << (first_method_for_dataset ? dataset_config.description : "") // Nome do Teste
                           << std::setw(28) << method_config.description // Nome do Método
                           << std::setw(15+20+20+12+15+15+15) << " [FALHOU]" // Mensagem de Falha
                           << std::setw(14) << std::right << (is_baseline ? "BASELINE" : " N/A") // Speedup
                           << std::endl;
            } else if (m.optimization_type != "none") { // Imprime apenas se as métricas foram preenchidas
                 report_ss << std::left
                           << std::setw(22) << (first_method_for_dataset ? dataset_config.description : "") // Nome do Teste
                           << std::setw(28) << method_config.description // Nome do Método
                           << std::fixed << std::setprecision(2) << std::setw(15) << m.estimated_ram_mb
                           << std::fixed << std::setprecision(2) << std::setw(20) << m.load_time_ms
                           << std::fixed << std::setprecision(2) << std::setw(20) << m.solve_time_ms
                           << std::setw(12) << m.iterations
                           << std::scientific << std::setprecision(3) << std::setw(14) << m.final_error
                           << std::scientific << std::setprecision(3) << std::setw(14) << m.final_epsilon
                           << std::setw(15) << (m.converged ? "Sim" : "Nao (MaxIt)");

                // Calcula Speedup vs Baseline (Standard)
                if (is_baseline) {
                    report_ss << std::setw(14) << std::right << "BASELINE";
                } else if (baseline_valid && m.solve_time_ms > 0) {
                    const double speedup = baseline_metrics_ptr->solve_time_ms / m.solve_time_ms;
                    std::stringstream ss_speedup;
                    ss_speedup << std::fixed << std::setprecision(2) << speedup << "x";
                    report_ss << std::setw(14) << std::right << ss_speedup.str();
                } else {
                    report_ss << std::setw(14) << std::right << " N/A";
                }
                report_ss << std::endl;
            }
            first_method_for_dataset = false; // Só imprime nome do teste na primeira linha
        } // Fim loop methods

        // Linha separadora entre datasets
        if (!method_results_map.empty()) { // Só imprime se houve resultados para este dataset
            report_ss << "------------------------------------------------------------------------------------------------------------------------------------------------------" << std::endl;
        }
    } // Fim loop datasets

    report_ss << "\nBenchmark concluido." << std::endl;

    // --- Imprime no Console ---
    std::cout << report_ss.str();

    // --- Salva em Arquivo (Opcional) ---
    try {
        std::filesystem::path report_file_path = config.settings.output_base_dir;
        report_file_path /= "summary_report.txt"; // Nome do arquivo de relatório
        std::ofstream report_file(report_file_path);
        if (report_file.is_open()) {
            report_file << report_ss.str();
            report_file.close();
            std::cout << "\n[INFO] Relatorio final salvo em: " << std::filesystem::absolute(report_file_path) << std::endl;
        } else {
            std::cerr << "[AVISO] Nao foi possivel abrir o arquivo de relatorio para escrita: " << report_file_path << std::endl;
        }
    } catch (const std::exception& e) {
        std::cerr << "[AVISO] Erro ao salvar relatorio final em arquivo: " << e.what() << std::endl;
    }
}
```

## arquivo solvers.cpp
```cpp
#include "../include/solvers.hpp" // Inclui as declarações
#include "../include/io_utils.hpp" // Para saveImageVectorToCsv
#include <vector>
#include <string>
#include <cmath>
#include <limits>
#include <iostream>
#include <iomanip>
#include <filesystem>
#include <Eigen/Core>
#include <Eigen/SparseCore>
#include <fstream>

// --- Implementação do Solver CGNR Regularizado (Salva Imagens Intermediárias) ---
template<typename MatrixType>
ReconstructionResult run_cgnr_solver_epsilon_save_iters(
    const Eigen::VectorXd &g_signal, const MatrixType &H_model,
    const double tolerance, const int max_iterations,
    const std::string& base_filename_prefix,
    const std::filesystem::path& output_dir,
    int img_rows, int img_cols)
{
    // Verificações iniciais
    if (H_model.rows() != g_signal.size()) throw std::runtime_error("run_cgnr_solver_epsilon_save_iters: Dimensoes H/g incompativeis. H.rows=" + std::to_string(H_model.rows()) + ", g.size=" + std::to_string(g_signal.size()));
    if (H_model.cols() <= 0) throw std::runtime_error("run_cgnr_solver_epsilon_save_iters: Matriz H tem " + std::to_string(H_model.cols()) + " colunas.");
    if (H_model.rows() == 0) {
        std::cerr << "[AVISO] run_cgnr_solver_epsilon_save_iters: Matriz H ou sinal g estao vazios." << std::endl;
        return ReconstructionResult{};
    }

    const auto start_time = std::chrono::high_resolution_clock::now();

    // Inicialização
    Eigen::VectorXd f = Eigen::VectorXd::Zero(H_model.cols());
    Eigen::VectorXd r = g_signal;
    Eigen::VectorXd z = H_model.transpose() * r;
    Eigen::VectorXd p = z;
    double z_norm_sq = z.squaredNorm();

    // Cálculo do Lambda
    double lambda = 0.0;
    if (z.size() > 0) {
        lambda = z.cwiseAbs().maxCoeff() * 0.10;
        constexpr double min_lambda = 1e-9;
        if (lambda < min_lambda) { lambda = min_lambda; std::cout << "[INFO] Lambda calculado era quase zero, usando piso minimo: " << lambda << std::endl;}
    } else { lambda = 1e-9; std::cout << "[AVISO] Vetor z inicial vazio, usando lambda=" << lambda << " como fallback." << std::endl;}
    std::cout << "[INFO] Lambda (solver standard): " << lambda << std::endl;

    ReconstructionResult result;
    result.iterations = 0; result.converged = false;
    result.residual_history.clear(); result.residual_history.reserve(max_iterations);
    result.solution_history.clear(); result.solution_history.reserve(max_iterations);
    double previous_residual_norm = r.norm();
    double current_residual_norm = previous_residual_norm;
    double epsilon = std::numeric_limits<double>::max();

    // Salva imagem inicial (iter 0)
    bool save_iters = !base_filename_prefix.empty() && img_rows > 0 && img_cols > 0;
    if (save_iters) {
         try {
             std::filesystem::path iter_img_path = output_dir / (base_filename_prefix + "_iter_0.csv");
             saveImageVectorToCsv(f, iter_img_path.string(), img_rows, img_cols);
         } catch (const std::exception& e) {
              std::cerr << "[AVISO] Falha ao salvar imagem iter 0: " << e.what() << std::endl;
         }
    }

    // Loop CGNR
    for (int i = 0; i < max_iterations; ++i) {
        result.iterations = i + 1;
        Eigen::VectorXd w = H_model * p;
        double p_norm_sq = p.squaredNorm();
        double modified_denominator = w.squaredNorm() + lambda * p_norm_sq;

        if (modified_denominator < std::numeric_limits<double>::epsilon()) {
            std::cout << "[INFO] Denominador modificado (" << modified_denominator << ") proximo de zero na iteracao " << i + 1 << ". Parando." << std::endl;
            break;
        }

        double alpha = z_norm_sq / modified_denominator;
        f += alpha * p;
        r -= alpha * w;

        // Salva imagem intermediária
        if (save_iters) {
             try {
                std::filesystem::path iter_img_path = output_dir / (base_filename_prefix + "_iter_" + std::to_string(i + 1) + ".csv");
                saveImageVectorToCsv(f, iter_img_path.string(), img_rows, img_cols);
             } catch (const std::exception& e) {
                 std::cerr << "[AVISO] Falha ao salvar imagem iter " << i+1 << ": " << e.what() << std::endl;
             }
        }

        Eigen::VectorXd z_next = (H_model.transpose() * r) - (lambda * f);
        const double z_next_norm_sq = z_next.squaredNorm();

        current_residual_norm = r.norm(); result.residual_history.push_back(current_residual_norm);
        result.solution_history.push_back(f.norm());
        epsilon = std::abs(current_residual_norm - previous_residual_norm);

        if (epsilon < tolerance) {
            result.converged = true;
            std::cout << "[INFO] Convergencia por epsilon atingida na iteracao " << i+1 << " (epsilon=" << std::scientific << epsilon << " < " << tolerance << ")" << std::defaultfloat << std::endl;
            break;
        }
        previous_residual_norm = current_residual_norm;

        double beta = 0.0;
        if (z_norm_sq >= std::numeric_limits<double>::epsilon()) { beta = z_next_norm_sq / z_norm_sq; }
        else {
            std::cout << "[INFO] ||z||^2 (" << z_norm_sq << ") proximo de zero na iteracao " << i + 1 << ". Usando beta=0 (restart)." << std::endl;
             if (z_next_norm_sq < std::numeric_limits<double>::epsilon()) {
                 std::cout << "[INFO] ||z_next||^2 tambem proximo de zero. Provavelmente estagnou. Parando." << std::endl;
                 break;
             }
        }

        p = z_next + beta * p;
        z = z_next;
        z_norm_sq = z_next_norm_sq;

        if (i == max_iterations - 1 && !result.converged) {
            std::cout << "[INFO] Numero maximo de iteracoes (" << max_iterations << ") atingido sem convergencia por epsilon (ultimo epsilon=" << std::scientific << epsilon << std::defaultfloat << ")." << std::endl;
        }
    } // Fim do loop

    const auto end_time = std::chrono::high_resolution_clock::now();
    result.image = f; result.final_error = current_residual_norm; result.final_epsilon = epsilon;
    result.execution_time_ms = std::chrono::duration<double, std::milli>(end_time - start_time).count();
    return result;
}

// --- Implementação do Solver CGNR Pré-condicionado (Salva Imagens Intermediárias) ---
template<typename MatrixType>
inline ReconstructionResult run_cgnr_solver_preconditioned_save_iters(
    const Eigen::VectorXd &g_signal, const MatrixType &H_model,
    const double tolerance, const int max_iterations,
    const std::string& base_filename_prefix,
    const std::filesystem::path& output_dir,
    int img_rows, int img_cols)
{
    if (H_model.rows() != g_signal.size()) throw std::runtime_error("...");
    if (H_model.cols() <= 0) throw std::runtime_error("...");
    if (H_model.rows() == 0) return ReconstructionResult{};

    const auto start_time = std::chrono::high_resolution_clock::now();

    Eigen::VectorXd f = Eigen::VectorXd::Zero(H_model.cols());
    Eigen::VectorXd r = g_signal;
    Eigen::VectorXd z_unprec = H_model.transpose() * r;

    // Cálculo do pré-condicionador Jacobi
    Eigen::VectorXd preconditioner = Eigen::VectorXd::Ones(H_model.cols());
     if constexpr (std::is_same_v<MatrixType, Eigen::MatrixXd>) { /* Densa */
        #pragma omp parallel for schedule(static)
        for (Eigen::Index j = 0; j < H_model.cols(); ++j) {
            preconditioner(j) = H_model.col(j).squaredNorm();
        }
     } else { // Esparsa
         preconditioner.setZero();
         // Não dá para paralelizar facilmente por coluna em CSC, faz sequencial
         for (int k=0; k<H_model.outerSize(); ++k) {
             for (typename MatrixType::InnerIterator it(H_model,k); it; ++it) {
                 // it.col() é a coluna, it.value() é o valor
                 preconditioner(it.col()) += it.value() * it.value();
             }
         }
     }
    preconditioner = preconditioner.cwiseMax(1e-12).cwiseInverse(); // Inverte (e evita divisão por zero)
    std::cout << "[INFO] Pre-condicionador Jacobi calculado." << std::endl;

    Eigen::VectorXd z = z_unprec.cwiseProduct(preconditioner); // z_0 = M^-1 * (H^T * r_0)
    Eigen::VectorXd p = z; // p_0 = z_0
    double z_precond_dot_z = z_unprec.dot(z); // z_0^T * M^-1 * z_unprec_0

    double lambda = 0.0;
    if (z_unprec.size() > 0) { // Usa z_unprec (H^T g) para calcular lambda
        lambda = z_unprec.cwiseAbs().maxCoeff() * 0.10;
         constexpr double min_lambda = 1e-9;
        if (lambda < min_lambda) { lambda = min_lambda; std::cout << "[INFO] Lambda calculado era quase zero, usando piso minimo: " << lambda << std::endl;}
    } else { lambda = 1e-9; std::cout << "[AVISO] Vetor z inicial (unprec) vazio, usando lambda=" << lambda << " como fallback." << std::endl;}
    std::cout << "[INFO] Lambda (solver precond): " << lambda << std::endl;

    ReconstructionResult result;
    result.iterations = 0; result.converged = false;
    result.residual_history.clear(); result.residual_history.reserve(max_iterations);
    result.solution_history.clear(); result.solution_history.reserve(max_iterations);
    double previous_residual_norm = r.norm();
    double current_residual_norm = previous_residual_norm;
    double epsilon = std::numeric_limits<double>::max();

     // Salva imagem inicial (iter 0)
     bool save_iters = !base_filename_prefix.empty() && img_rows > 0 && img_cols > 0;
     if (save_iters) {
         try {
             std::filesystem::path iter_img_path = output_dir / (base_filename_prefix + "_iter_0.csv");
             saveImageVectorToCsv(f, iter_img_path.string(), img_rows, img_cols);
         } catch (const std::exception& e) {
             std::cerr << "[AVISO] Falha ao salvar imagem iter 0 (precond): " << e.what() << std::endl;
         }
     }

    // Loop CGNR Pré-condicionado
    for (int i = 0; i < max_iterations; ++i) {
        result.iterations = i + 1;
        Eigen::VectorXd w = H_model * p;
        double p_norm_sq = p.squaredNorm();
        double modified_denominator = w.squaredNorm() + lambda * p_norm_sq;

        if (modified_denominator < std::numeric_limits<double>::epsilon()) {
            std::cout << "[INFO] Denominador modificado (" << modified_denominator << ") proximo de zero na iteracao " << i + 1 << ". Parando." << std::endl;
            break;
        }

        double alpha = z_precond_dot_z / modified_denominator; // Usa produto interno modificado

        f += alpha * p;
        r -= alpha * w;

         // Salva imagem intermediária
         if (save_iters) {
             try {
                std::filesystem::path iter_img_path = output_dir / (base_filename_prefix + "_iter_" + std::to_string(i + 1) + ".csv");
                saveImageVectorToCsv(f, iter_img_path.string(), img_rows, img_cols);
             } catch (const std::exception& e) {
                 std::cerr << "[AVISO] Falha ao salvar imagem iter " << i+1 << " (precond): " << e.what() << std::endl;
             }
        }

        Eigen::VectorXd z_next_unprec = (H_model.transpose() * r) - (lambda * f);
        Eigen::VectorXd z_next = z_next_unprec.cwiseProduct(preconditioner); // Aplica pré-condicionador
        double z_next_precond_dot_z_next = z_next_unprec.dot(z_next); // Novo produto interno

        current_residual_norm = r.norm(); result.residual_history.push_back(current_residual_norm);
        result.solution_history.push_back(f.norm());
        epsilon = std::abs(current_residual_norm - previous_residual_norm);

        if (epsilon < tolerance) {
            result.converged = true;
            std::cout << "[INFO] Convergencia por epsilon atingida na iteracao " << i + 1 << " (epsilon=" << std::scientific << epsilon << " < " << tolerance << ")" << std::defaultfloat << std::endl;
            break;
        }
        previous_residual_norm = current_residual_norm;

        double beta = 0.0;
        // Beta usa os produtos internos modificados
        if (z_precond_dot_z >= std::numeric_limits<double>::epsilon()) {
             beta = z_next_precond_dot_z_next / z_precond_dot_z;
        } else {
             std::cout << "[INFO] Produto interno z^T M^-1 z_unprec (" << z_precond_dot_z << ") proximo de zero na iteracao " << i + 1 << ". Usando beta=0 (restart)." << std::endl;
            if (z_next_precond_dot_z_next < std::numeric_limits<double>::epsilon()) {
                std::cout << "[INFO] Produto interno z_next^T M^-1 z_unprec_next tambem proximo de zero. Provavelmente estagnou. Parando." << std::endl;
                break;
            }
        }

        p = z_next + beta * p; // p_{i+1} = z_{i+1} + beta_i * p_i
        z = z_next; // z é o pré-condicionado
        z_precond_dot_z = z_next_precond_dot_z_next; // Atualiza produto interno

        if (i == max_iterations - 1 && !result.converged) {
            std::cout << "[INFO] Numero maximo de iteracoes (" << max_iterations << ") atingido sem convergencia por epsilon (ultimo epsilon=" << std::scientific << epsilon << std::defaultfloat << ")." << std::endl;
        }
    } // Fim do loop

    const auto end_time = std::chrono::high_resolution_clock::now();
    result.image = f; result.final_error = current_residual_norm; result.final_epsilon = epsilon;
    result.execution_time_ms = std::chrono::duration<double, std::milli>(end_time - start_time).count();
    return result;
}


// --- Implementação Solver Fixo (NÃO salva imagens intermediárias) ---
template<typename MatrixType>
inline ReconstructionResult run_cgnr_solver_fixed_iter(const Eigen::VectorXd &g_signal, const MatrixType &H_model,
                                                const int num_iterations) {
    if (H_model.rows() != g_signal.size()) throw std::runtime_error("run_cgnr_solver_fixed_iter: Dimensoes H/g incompativeis");
    if (H_model.cols() <= 0) throw std::runtime_error("run_cgnr_solver_fixed_iter: Matriz H tem 0 colunas");
    if (H_model.rows() == 0) return ReconstructionResult{};

    const auto start_time = std::chrono::high_resolution_clock::now();
    Eigen::VectorXd f = Eigen::VectorXd::Zero(H_model.cols());
    Eigen::VectorXd r = g_signal;
    Eigen::VectorXd z = H_model.transpose() * r;
    Eigen::VectorXd p = z;
    double z_norm_sq = z.squaredNorm();

    ReconstructionResult result;
    result.iterations = 0; result.converged = false;
    result.residual_history.clear(); result.residual_history.reserve(num_iterations);
    result.solution_history.clear(); result.solution_history.reserve(num_iterations);

    for (int i = 0; i < num_iterations; ++i) {
        result.iterations = i + 1;
        double current_residual_norm = r.norm(); result.residual_history.push_back(current_residual_norm);
        double current_solution_norm = f.norm(); result.solution_history.push_back(current_solution_norm);
        Eigen::VectorXd w = H_model * p; double w_norm_sq = w.squaredNorm();
        double alpha = 0.0;
        if (w_norm_sq >= std::numeric_limits<double>::epsilon()) { alpha = z_norm_sq / w_norm_sq; }
        else {
            // Não imprime aviso repetidamente, pode poluir muito
            // std::cout << "[AVISO - FixedIter] ||H*p||^2 proximo de zero na iteracao " << i + 1 << ". Usando alpha=0." << std::endl;
            z_norm_sq = 0.0;
        }
        f += alpha * p; r -= alpha * w;
        Eigen::VectorXd z_next = H_model.transpose() * r; const double z_next_norm_sq = z_next.squaredNorm();
        double beta = 0.0;
        if (z_norm_sq >= std::numeric_limits<double>::epsilon()) { beta = z_next_norm_sq / z_norm_sq; }
        else {
            // Não imprime aviso repetidamente
            // std::cout << "[AVISO - FixedIter] ||z||^2 proximo de zero na iteracao " << i + 1 << ". Usando beta=0." << std::endl;
        }
        p = z_next + beta * p; z = z_next; z_norm_sq = z_next_norm_sq;
    } // Fim do loop

    const auto end_time = std::chrono::high_resolution_clock::now();
    result.image = f; result.final_error = r.norm();
    result.execution_time_ms = std::chrono::duration<double, std::milli>(end_time - start_time).count();
    return result;
}

template<typename MatrixType>
ReconstructionResult run_fista_solver_save_iters(const Eigen::VectorXd &g_signal, const MatrixType &H_model,
    double tolerance, int max_iterations, const std::string &base_filename_prefix,
    const std::filesystem::path &output_dir, int img_rows, int img_cols) {

    const auto start_time = std::chrono::high_resolution_clock::now();
    ReconstructionResult result;
    result.converged = false;

    // Initialize variables
    const int n = H_model.cols();
    Eigen::VectorXd x = Eigen::VectorXd::Zero(n);  // Current solution
    Eigen::VectorXd y = x;                         // Extrapolated point
    Eigen::VectorXd x_prev = x;                    // Previous solution
    double t = 1.0;                                // Initial step size
    double t_prev;
    double L = 1.0;                                // Lipschitz constant estimate

    // Main FISTA iteration loop
    for (int iter = 0; iter < max_iterations; ++iter) {
        result.iterations = iter + 1;

        // Store previous values
        x_prev = x;
        t_prev = t;

        // Gradient step
        Eigen::VectorXd gradient = H_model.transpose() * (H_model * y - g_signal);
        x = y - (1.0/L) * gradient;

        // Soft thresholding (L1 regularization)
        double lambda = 0.1 / L;  // Regularization parameter
        x = (x.array().abs() > lambda).select(
            (x.array().abs() - lambda) * x.array().sign(),
            0.0
        );

        // Update t and y using FISTA update rule
        t = (1.0 + std::sqrt(1.0 + 4.0 * t * t)) / 2.0;
        y = x + ((t_prev - 1.0) / t) * (x - x_prev);

        // Calculate residual and update histories
        Eigen::VectorXd residual = H_model * x - g_signal;
        double current_residual_norm = residual.norm();
        result.residual_history.push_back(current_residual_norm);
        result.solution_history.push_back(x.norm());

        // Save intermediate result to CSV
        if (img_rows > 0 && img_cols > 0) {
            try {
                std::filesystem::path iter_img_path = output_dir / (base_filename_prefix + "_iter_" + std::to_string(iter) + ".csv");
                saveImageVectorToCsv(x, iter_img_path.string(), img_rows, img_cols);
            } catch (const std::exception& e) {
                std::cerr << "[AVISO] Falha ao salvar imagem iter " << iter << " (FISTA): " << e.what() << std::endl;
            }
        }

        // Check convergence
        if (iter > 0) {
            double epsilon = std::abs(result.residual_history[iter] - result.residual_history[iter-1]);
            result.final_epsilon = epsilon;
            if (epsilon < tolerance) {
                result.converged = true;
                break;
            }
        }
    }

    // Set final results
    result.image = x;
    result.final_error = (H_model * x - g_signal).norm();
    const auto end_time = std::chrono::high_resolution_clock::now();
    result.execution_time_ms = std::chrono::duration<double, std::milli>(end_time - start_time).count();

    return result;
}

// --- Instanciações explícitas para os tipos de matrizes ---
// Garante que o compilador gere o código para SparseMatrix<double>
template ReconstructionResult run_cgnr_solver_epsilon_save_iters<Eigen::SparseMatrix<double>>(
    const Eigen::VectorXd &g_signal, const Eigen::SparseMatrix<double> &H_model,
    double tolerance, int max_iterations,
    const std::string& base_filename_prefix, const std::filesystem::path& output_dir,
    int img_rows, int img_cols);

template ReconstructionResult run_cgnr_solver_preconditioned_save_iters<Eigen::SparseMatrix<double>>(
    const Eigen::VectorXd &g_signal, const Eigen::SparseMatrix<double> &H_model,
    double tolerance, int max_iterations,
    const std::string& base_filename_prefix, const std::filesystem::path& output_dir,
    int img_rows, int img_cols);

template ReconstructionResult run_cgnr_solver_fixed_iter<Eigen::SparseMatrix<double>>(
    const Eigen::VectorXd &g_signal, const Eigen::SparseMatrix<double> &H_model,
    int num_iterations);

// **** DESCOMENTE ESTAS LINHAS ****
template ReconstructionResult run_cgnr_solver_epsilon_save_iters<Eigen::MatrixXd>(
    const Eigen::VectorXd &g_signal, const Eigen::MatrixXd &H_model,
    double tolerance, int max_iterations,
    const std::string& base_filename_prefix, const std::filesystem::path& output_dir,
    int img_rows, int img_cols);

/* // Não estamos usando pré-condicionador denso, então esta pode ficar comentada se quiser
template ReconstructionResult run_cgnr_solver_preconditioned_save_iters<Eigen::MatrixXd>(
    const Eigen::VectorXd &g_signal, const Eigen::MatrixXd &H_model,
    double tolerance, int max_iterations,
    const std::string& base_filename_prefix, const std::filesystem::path& output_dir,
    int img_rows, int img_cols);
*/

template ReconstructionResult run_cgnr_solver_fixed_iter<Eigen::MatrixXd>(
    const Eigen::VectorXd &g_signal, const Eigen::MatrixXd &H_model,
    int num_iterations);
// **** FIM DA CORREÇÃO ****

// Se você precisar rodar com Matriz Densa também, descomente estas:
/*
template ReconstructionResult run_cgnr_solver_epsilon_save_iters<Eigen::MatrixXd>(
    const Eigen::VectorXd &g_signal, const Eigen::MatrixXd &H_model,
    double tolerance, int max_iterations,
    const std::string& base_filename_prefix, const std::filesystem::path& output_dir,
    int img_rows, int img_cols);

template ReconstructionResult run_cgnr_solver_preconditioned_save_iters<Eigen::MatrixXd>(
    const Eigen::VectorXd &g_signal, const Eigen::MatrixXd &H_model,
    double tolerance, int max_iterations,
    const std::string& base_filename_prefix, const std::filesystem::path& output_dir,
    int img_rows, int img_cols);

template ReconstructionResult run_cgnr_solver_fixed_iter<Eigen::MatrixXd>(
    const Eigen::VectorXd &g_signal, const Eigen::MatrixXd &H_model,
    int num_iterations);
*/

// Explicit template instantiation for FISTA solver
template ReconstructionResult run_fista_solver_save_iters<Eigen::SparseMatrix<double>>(
    const Eigen::VectorXd &g_signal, const Eigen::SparseMatrix<double> &H_model,
    double tolerance, int max_iterations,
    const std::string& base_filename_prefix, const std::filesystem::path& output_dir,
    int img_rows, int img_cols);

template ReconstructionResult run_fista_solver_save_iters<Eigen::MatrixXd>(
    const Eigen::VectorXd &g_signal, const Eigen::MatrixXd &H_model,
    double tolerance, int max_iterations,
    const std::string& base_filename_prefix, const std::filesystem::path& output_dir,
    int img_rows, int img_cols);

/* // Commented out dense matrix implementations
template ReconstructionResult run_fista_solver_save_iters<Eigen::MatrixXd>(
    const Eigen::VectorXd &g_signal, const Eigen::MatrixXd &H_model,
    double tolerance, int max_iterations,
    const std::string& base_filename_prefix, const std::filesystem::path& output_dir,
    int img_rows, int img_cols);
*/
```

## arquivo utils.cpp
```cpp
#include "../include/utils.hpp" // Inclui as declarações
#include <vector>
#include <cmath>     // Para std::abs, std::sqrt
#include <iostream>
#include <stdexcept>
#include <Eigen/Core>
#include <Eigen/SparseCore>
#include <omp.h>     // Para OpenMP

// --- Implementação da Função de Normalização ---

template<typename MatrixType>
void normalize_system_rows(MatrixType &H, Eigen::VectorXd &g) {
    if (H.rows() != g.size()) {
        throw std::runtime_error(
            "normalize_system_rows: Dimensoes H/g incompativeis. H.rows=" + std::to_string(H.rows()) + ", g.size=" +
            std::to_string(g.size()));
    }
    if (H.rows() == 0) {
        std::cout << "[INFO] Matriz H vazia, nada para normalizar." << std::endl;
        return; // Nada a fazer
    }

    std::cout << "[INFO] Normalizando linhas de H e elementos de g..." << std::endl;
    constexpr double epsilon_norm = 1e-12; // Limiar para evitar divisao por zero

    if constexpr (std::is_same_v<MatrixType, Eigen::MatrixXd>) {
        // --- Versão Densa ---
#pragma omp parallel for schedule(static) // Paraleliza a normalização das linhas
        for (Eigen::Index i = 0; i < H.rows(); ++i) {
            double row_norm = H.row(i).norm();
            if (row_norm > epsilon_norm) {
                H.row(i) /= row_norm;
                g(i) /= row_norm;
            } else {
                // Linha é (quase) zero, zera explicitamente para evitar NaNs
                H.row(i).setZero();
                g(i) = 0.0;
            }
        }
    } else {
        // --- Versão Esparsa ---
        std::vector<double> row_norms_sq(H.rows(), 0.0);

        // Calcula norma ao quadrado de cada linha (iterando pelos não-zeros)
        // Esta parte é inerentemente sequencial por coluna na estrutura CSC do Eigen
        for (int k = 0; k < H.outerSize(); ++k) {
            for (typename MatrixType::InnerIterator it(H, k); it; ++it) {
                row_norms_sq[it.row()] += it.value() * it.value();
            }
        }

        // Modifica os valores da matriz esparsa in-place (paralelizável por coluna)
#pragma omp parallel for schedule(static)
        for (int k = 0; k < H.outerSize(); ++k) {
            for (typename MatrixType::InnerIterator it(H, k); it; ++it) {
                double row_norm = std::sqrt(row_norms_sq[it.row()]);
                if (row_norm > epsilon_norm) {
                    // valueRef() permite modificar o valor
                    it.valueRef() /= row_norm;
                } else {
                    // Se a norma da linha é zero, o valor deve ser zero
                    it.valueRef() = 0.0;
                }
            }
        }
        // Remove explicitamente os zeros que podem ter sido criados (opcional, mas bom para limpeza)
        H.prune(0.0, std::numeric_limits<double>::epsilon()); // Remove valores muito pequenos

        // Normaliza g (paralelizável)
#pragma omp parallel for schedule(static)
        for (Eigen::Index i = 0; i < g.size(); ++i) {
            double row_norm = std::sqrt(row_norms_sq[i]);
            if (row_norm > epsilon_norm) {
                g(i) /= row_norm;
            } else {
                g(i) = 0.0;
            }
        }
    }
    std::cout << "[INFO] Normalizacao concluida." << std::endl;
}

// --- Instanciação explícita para os tipos que vamos usar ---
// Isso garante que o compilador gere o código para MatrixXd e SparseMatrix<double>
// Coloque isso no final do arquivo .cpp
template void normalize_system_rows<Eigen::MatrixXd>(Eigen::MatrixXd &H, Eigen::VectorXd &g);

template void normalize_system_rows<Eigen::SparseMatrix<double> >(Eigen::SparseMatrix<double> &H, Eigen::VectorXd &g);

// --- Implementação de Outras Funções Utilitárias (se houver) ---
// Exemplo: isToeplitz (copiado do solver_comparison.hpp anterior)
/*
template<typename MatrixType>
bool isToeplitz(const MatrixType &H, const double tolerance = 1e-10) {
    const Eigen::Index rows = H.rows();
    const Eigen::Index cols = H.cols();

    if (rows == 0 || cols == 0) return true;

    for (int d = -rows + 1; d < cols; ++d) {
        double first_val = 0.0; // Initialize properly
        bool first = true;

        for (Eigen::Index i = std::max(0, -d); i < std::min(rows, cols - d); ++i) {
            Eigen::Index j = i + d;
            double current_val;

            if constexpr (std::is_same_v<MatrixType, Eigen::MatrixXd>) {
                current_val = H(i, j);
            } else {
                current_val = H.coeff(i, j); // Use coeff for sparse
            }

            if (first) {
                 // Only record the first non-zero (or near-zero) value encountered on the diagonal
                 if (std::abs(current_val) > tolerance * 1e-3) { // Use a smaller tolerance to find the 'first' meaningful value
                     first_val = current_val;
                     first = false;
                 } else if (i == std::min(rows, cols - d) - 1) { // If we reach the end and only found zeros
                     first_val = 0.0; // Consider the diagonal constant zero
                     first = false; // Prevent comparison below
                 }
            } else {
                // Only compare if the current value is also significant
                if (std::abs(current_val) > tolerance * 1e-3 || std::abs(first_val) > tolerance * 1e-3) {
                     if (std::abs(current_val - first_val) > tolerance) {
                         //std::cout << "[DEBUG] Diagonal " << d << " nao e constante na pos (" << i << "," << j << "): "
                         //          << first_val << " vs " << current_val << std::endl;
                         return false;
                     }
                }
                 // If both current_val and first_val are near zero, consider them equal
            }
        }
    }
    return true;
}

// Instanciações explícitas para isToeplitz
template bool isToeplitz<Eigen::MatrixXd>(const Eigen::MatrixXd& H, double tolerance);
template bool isToeplitz<Eigen::SparseMatrix<double>>(const Eigen::SparseMatrix<double>& H, double tolerance);
*/
```

## arquivo benchmark_runner.hpp
```cpp
#ifndef ULTRASOUNDBENCHMARK_BENCHMARK_RUNNER_HPP
#define ULTRASOUNDBENCHMARK_BENCHMARK_RUNNER_HPP

#include "types.hpp"   // Para Config, BenchmarkResults, etc.
#include "config.hpp"  // Para a classe Config

/**
 * @brief Executa os pipelines de benchmark definidos na configuração.
 * Carrega dados, chama os solvers apropriados, coleta métricas e
 * preenche a estrutura BenchmarkResults.
 *
 * @param config Objeto Config contendo toda a configuração lida do YAML.
 * @return BenchmarkResults Estrutura contendo os resultados de todos os testes executados.
 */
BenchmarkResults run_benchmarks(const Config& config);


#endif //ULTRASOUNDBENCHMARK_BENCHMARK_RUNNER_HPP
```

## arquivo config.hpp
```cpp
#ifndef ULTRASOUNDBENCHMARK_CONFIG_HPP
#define ULTRASOUNDBENCHMARK_CONFIG_HPP

#include <iostream>
#include "types.hpp" // Inclui as definições de structs (DatasetConfig, MethodConfig, etc.)
#include <string>
#include <vector>
#include <map>

// Classe para armazenar a configuração completa lida do YAML
class Config {
public:
    GlobalSettings settings; // Configurações globais
    std::vector<DatasetConfig> datasets; // Lista de datasets disponíveis
    std::vector<MethodConfig> methods; // Lista de métodos disponíveis
    std::vector<PipelineConfig> run_pipelines; // Lista de pipelines a executar

    // Mapas para acesso rápido por nome (preenchidos após carregar)
    std::map<std::string, const DatasetConfig*> dataset_map;
    std::map<std::string, const MethodConfig*> method_map;

    // Construtor padrão
    Config() = default;

    // Função para preencher os mapas após carregar os vetores
    void populate_maps() {
        dataset_map.clear();
        method_map.clear();

        std::cout << "\n[INFO] Populando mapas de configuração..." << std::endl;

        std::cout << "[INFO] Datasets disponíveis:" << std::endl;
        for (const auto& dataset : datasets) {
            dataset_map[dataset.name] = &dataset;
            std::cout << "  - " << dataset.name << std::endl;
        }

        std::cout << "[INFO] Métodos disponíveis:" << std::endl;
        for (const auto& method : methods) {
            method_map[method.name] = &method;
            std::cout << "  - " << method.name << std::endl;
        }

        std::cout << "[INFO] Pipelines configurados:" << std::endl;
        for (const auto& pipeline : run_pipelines) {
            std::cout << "  Pipeline: " << pipeline.name << std::endl;
            std::cout << "    Datasets: ";
            for (const auto& dataset : pipeline.dataset_names) {
                std::cout << dataset << " ";
            }
            std::cout << std::endl;
            std::cout << "    Métodos: ";
            for (const auto& method : pipeline.method_names) {
                std::cout << method << " ";
            }
            std::cout << std::endl;
        }
    }
};

// Declaração da função que carregará a configuração do arquivo YAML
Config load_config(const std::string& config_path);


#endif //ULTRASOUNDBENCHMARK_CONFIG_HPP
```

## arquivo io_utils.hpp
```cpp
#ifndef ULTRASOUNDBENCHMARK_IO_UTILS_HPP
#define ULTRASOUNDBENCHMARK_IO_UTILS_HPP

#include <string>
#include <vector>
#include <Eigen/Core>
#include <Eigen/SparseCore>
#include "types.hpp" // Para ReconstructionResult

// --- Declarações das Funções de Carregamento ---

// Carrega um vetor de um arquivo CSV (uma coluna ou linha longa)
Eigen::VectorXd loadVectorData(const std::string& path);

// Carrega uma matriz densa de um arquivo CSV
Eigen::MatrixXd loadDenseData(const std::string& path);

// Carrega uma matriz densa de um arquivo binário
Eigen::MatrixXd loadDenseMatrix(const std::string& path);

// Converte um CSV para uma matriz esparsa
Eigen::SparseMatrix<double> convertCsvToSparse(const std::string& path, int expected_cols);

// Carrega uma matriz esparsa de um arquivo binário
Eigen::SparseMatrix<double> loadSparseMatrix(const std::string& path);

// --- Declarações das Funções de Salvamento ---

// Salva uma matriz densa em um arquivo binário
void saveDenseMatrix(const Eigen::MatrixXd& mat, const std::string& path);

// Salva uma matriz esparsa em um arquivo binário
void saveSparseMatrix(const Eigen::SparseMatrix<double>& mat, const std::string& path);

// Salva o histórico de normas de resíduo em CSV
void saveHistoryToCSV(const std::vector<double>& history, const std::string& filename);

// Salva os dados para a L-curve (norma da solução vs norma do resíduo) em CSV
void saveLcurveToCSV(const ReconstructionResult& result, const std::string& filename);

// Salva o vetor da imagem reconstruída (f) em formato CSV (matricial)
void saveImageVectorToCsv(const Eigen::VectorXd& vec, const std::string& filename, int img_rows, int img_cols);


#endif //ULTRASOUNDBENCHMARK_IO_UTILS_HPP
```

## arquivo reporting.hpp
```cpp
#ifndef ULTRASOUNDBENCHMARK_REPORTING_HPP
#define ULTRASOUNDBENCHMARK_REPORTING_HPP

#include "types.hpp"   // Para BenchmarkResults, Config
#include "config.hpp"  // Para Config
#include <string>

/**
 * @brief Gera a tabela de relatório comparativo final.
 * Imprime a tabela no console e, opcionalmente, salva em um arquivo.
 *
 * @param benchmark_results Estrutura contendo os resultados de todos os testes.
 * @param config Objeto Config contendo a configuração global e dos métodos/datasets.
 */
void generate_report(const BenchmarkResults& benchmark_results, const Config& config);

#endif //ULTRASOUNDBENCHMARK_REPORTING_HPP
```

## arquivo solvers.hpp
```cpp
#ifndef ULTRASOUNDBENCHMARK_SOLVERS_HPP
#define ULTRASOUNDBENCHMARK_SOLVERS_HPP

#include "types.hpp" // Para ReconstructionResult
#include <Eigen/Core>
#include <Eigen/SparseCore>
#include <vector>
#include <string>
#include <filesystem> // Para std::filesystem::path

// --- Declarações dos Solvers ---

/**
 * @brief Executa o solver CGNR padrão com Regularização de Tikhonov (Salva Imagens Intermediárias).
 * Assume que H e g já foram normalizados. Para quando epsilon < tolerance ou max_iterations.
 * @param g_signal Sinal medido (vetor g) normalizado.
 * @param H_model Matriz do sistema (H) normalizada.
 * @param tolerance Tolerância para o critério de parada epsilon.
 * @param max_iterations Número máximo de iterações.
 * @param base_filename_prefix Prefixo para os nomes dos arquivos CSV das imagens intermediárias.
 * @param output_dir Diretório para salvar as imagens intermediárias.
 * @param img_rows Número de linhas da imagem para salvar CSV.
 * @param img_cols Número de colunas da imagem para salvar CSV.
 * @return ReconstructionResult Contendo a imagem final, métricas e histórico.
 */
template<typename MatrixType>
ReconstructionResult run_cgnr_solver_epsilon_save_iters(
    const Eigen::VectorXd &g_signal, const MatrixType &H_model,
    double tolerance, int max_iterations,
    const std::string& base_filename_prefix,
    const std::filesystem::path& output_dir,
    int img_rows, int img_cols);

/**
 * @brief Executa o solver CGNR com Pré-condicionador Jacobi e Regularização de Tikhonov (Salva Imagens Intermediárias).
 * Assume que H e g já foram normalizados. Para quando epsilon < tolerance ou max_iterations.
 * @param g_signal Sinal medido (vetor g) normalizado.
 * @param H_model Matriz do sistema (H) normalizada.
 * @param tolerance Tolerância para o critério de parada epsilon.
 * @param max_iterations Número máximo de iterações.
 * @param base_filename_prefix Prefixo para os nomes dos arquivos CSV das imagens intermediárias.
 * @param output_dir Diretório para salvar as imagens intermediárias.
 * @param img_rows Número de linhas da imagem para salvar CSV.
 * @param img_cols Número de colunas da imagem para salvar CSV.
 * @return ReconstructionResult Contendo a imagem final, métricas e histórico.
 */
template<typename MatrixType>
ReconstructionResult run_cgnr_solver_preconditioned_save_iters(
    const Eigen::VectorXd &g_signal, const MatrixType &H_model,
    double tolerance, int max_iterations,
    const std::string& base_filename_prefix,
    const std::filesystem::path& output_dir,
    int img_rows, int img_cols);


/**
 * @brief Executa o solver CGNR padrão (sem regularização explícita aqui) por um número FIXO de iterações.
 * Usado para gerar dados consistentes para os CSVs de convergência e L-curve.
 * Assume que H e g já foram normalizados. NÃO salva imagens intermediárias.
 * @param g_signal Sinal medido (vetor g) normalizado.
 * @param H_model Matriz do sistema (H) normalizada.
 * @param num_iterations Número exato de iterações a executar.
 * @return ReconstructionResult Contendo histórico de resíduo e solução.
 */
template<typename MatrixType>
ReconstructionResult run_cgnr_solver_fixed_iter(
    const Eigen::VectorXd &g_signal, const MatrixType &H_model,
    int num_iterations);


/**
 * @brief Executa o solver FISTA (Fast Iterative Shrinkage-Thresholding Algorithm) com salvamento de iterações.
 * Usa regularização L1 (soft thresholding) e atualização de momento FISTA.
 * @param g_signal Sinal medido (vetor g) normalizado.
 * @param H_model Matriz do sistema (H) normalizada.
 * @param tolerance Tolerância para o critério de parada epsilon.
 * @param max_iterations Número máximo de iterações.
 * @param base_filename_prefix Prefixo para os nomes dos arquivos CSV das imagens intermediárias.
 * @param output_dir Diretório para salvar as imagens intermediárias.
 * @param img_rows Número de linhas da imagem para salvar CSV.
 * @param img_cols Número de colunas da imagem para salvar CSV.
 * @return ReconstructionResult Contendo a imagem final, métricas e histórico.
 */
template<typename MatrixType>
ReconstructionResult run_fista_solver_save_iters(
    const Eigen::VectorXd &g_signal, const MatrixType &H_model,
    double tolerance, int max_iterations,
    const std::string& base_filename_prefix,
    const std::filesystem::path& output_dir,
    int img_rows, int img_cols);

#endif //ULTRASOUNDBENCHMARK_SOLVERS_HPP
```

## arquivo types.hpp
```cpp
#ifndef ULTRASOUNDBENCHMARK_TYPES_HPP
#define ULTRASOUNDBENCHMARK_TYPES_HPP

#include <vector>
#include <string>
#include <map> // Para std::map
#include <Eigen/Core> // Para Eigen::VectorXd

// Estrutura para armazenar o resultado de uma reconstrução
struct ReconstructionResult {
    Eigen::VectorXd image; // Vetor f reconstruído
    int iterations{};
    double final_error{}; // Norma do resíduo final ||r||
    double final_epsilon{}; // Valor final de epsilon = | ||r_i+1|| - ||r_i|| |
    double execution_time_ms{};
    bool converged{}; // Indica se parou pela tolerância epsilon
    std::vector<double> residual_history; // Histórico da norma ||r_i||
    std::vector<double> solution_history; // Histórico da norma ||f_i||
};

// Estrutura para configurar um conjunto de dados de teste (lido do YAML)
struct DatasetConfig {
    std::string name;           // Nome curto (ex: "60x60_G1")
    std::string description;    // Descrição (ex: "60x60 (Sinal G-1)")
    std::string h_matrix_csv;   // Caminho para o CSV da matriz H
    std::string g_signal_csv;   // Caminho para o CSV do sinal G
    int image_rows = 0;
    int image_cols = 0;
};

// Estrutura para configurar um método de reconstrução (lido do YAML)
struct MethodConfig {
    std::string name;           // Nome curto (ex: "sparse_standard")
    std::string description;    // Descrição (ex: "Esparso / Binario (Standard)")
    std::string solver;         // Identificador do solver (ex: "cgnr_standard")
    bool use_binary = true;     // Usar .bin em vez de .csv para H?
    bool is_baseline = false;   // É a referência para speedup?
};

// Estrutura para configurar um pipeline de execução (lido do YAML)
struct PipelineConfig {
    std::string name;
    std::string description;
    std::vector<std::string> method_names; // Nomes dos métodos a rodar
    std::vector<std::string> dataset_names; // Nomes dos datasets a usar
};

// Estrutura para armazenar as métricas de desempenho de uma execução
struct PerformanceMetrics {
    std::string optimization_type;  // "standard", "jacobi", "fista"
    double load_time_ms = 0.0;
    double solve_time_ms = 0.0;
    double estimated_ram_mb = 0.0; // RAM estimada apenas para H
    int iterations = 0;
    double final_error = 0.0; // ||r|| final
    double final_epsilon = 0.0; // Epsilon final
    bool converged = false;
};

// Estrutura para guardar todos os resultados de um pipeline
struct BenchmarkResults {
    // Mapeia nome do dataset -> (Mapeia nome do método -> Métricas)
    std::map<std::string, std::map<std::string, PerformanceMetrics>> results;
    // Guarda ponteiros para a config original para referência
    const MethodConfig* baseline_method = nullptr;
};

// Estrutura global para as configurações lidas do YAML
struct GlobalSettings {
    std::string output_base_dir = "../output";
    double epsilon_tolerance = 1.0e-4;
    int max_iterations = 10;
    bool save_intermediate_images = false;
    int num_omp_threads = 0; // 0 = padrão
};


#endif //ULTRASOUNDBENCHMARK_TYPES_HPP
```

## arquivo utils.hpp
```cpp
#ifndef ULTRASOUNDBENCHMARK_UTILS_HPP
#define ULTRASOUNDBENCHMARK_UTILS_HPP

#include <Eigen/Core>
#include <Eigen/SparseCore>
#include <vector>
#include <string>

// --- Declaração da Função de Normalização ---

/**
 * @brief Normaliza as linhas da matriz H e os elementos correspondentes do vetor g.
 * Modifica H e g no local.
 * @tparam MatrixType Eigen::MatrixXd ou Eigen::SparseMatrix<double>
 * @param H Matriz do sistema (será modificada).
 * @param g Vetor do sinal medido (será modificado).
 */
template<typename MatrixType>
void normalize_system_rows(MatrixType& H, Eigen::VectorXd& g);

// --- Declaração de Outras Funções Utilitárias (se houver) ---
// Exemplo: Função para verificar estrutura Toeplitz (se ainda for útil para análise)
// template<typename MatrixType>
// bool isToeplitz(const MatrixType& H, double tolerance = 1e-10);


#endif //ULTRASOUNDBENCHMARK_UTILS_HPP
```

## arquivo solver_comparison.hpp
```cpp
#ifndef ULTRASOUNDSERVER_SOLVER_COMPARISON_HPP
#define ULTRASOUNDSERVER_SOLVER_COMPARISON_HPP

#include <iostream>
#include <vector>
#include <string>
#include <fstream>
#include <sstream>
#include <chrono>
#include <cmath>
#include <iomanip>
#include <omp.h>
#include <stdexcept>
#include <numeric>
#include <algorithm>
#include <limits>
#include <filesystem>
#include <Eigen/Dense>
#include <Eigen/Sparse>
#include <Eigen/Core>

// Inclui as definições de structs do seu próprio projeto
#include "include/types.hpp"

// --- Funções Auxiliares (Implementações Completas) ---
// (As 11 funções: loadVectorData, convertCsvToSparse, saveSparseMatrix, loadSparseMatrix,
// loadDenseData, loadDenseMatrix, saveDenseMatrix, saveHistoryToCSV, saveLcurveToCSV,
// saveImageVectorToCsv, normalize_system_rows... ESTÃO AQUI)

inline Eigen::VectorXd loadVectorData(const std::string &path) {
    std::ifstream file(path);
    if (!file.is_open()) throw std::runtime_error("Nao foi possivel abrir o arquivo: " + path);
    std::vector<double> values;
    std::string line;
    int line_num = 0;
    while (std::getline(file, line)) {
        line_num++;
        if (line.empty() || std::ranges::all_of(line, ::isspace)) continue;
        std::stringstream lineStream(line);
        std::string cell;
        while (std::getline(lineStream, cell, ',')) {
            try {
                std::erase_if(cell, ::isspace);
                if (!cell.empty()) {
                    values.push_back(std::stod(cell));
                }
            } catch (const std::invalid_argument &) {
                std::cerr << "[AVISO] Ignorando valor nao numerico em: " << path << ", linha: " << line_num <<
                        ", celula: '" << cell << "'" << std::endl;
            } catch (const std::out_of_range &) {
                std::cerr << "[AVISO] Ignorando valor fora do range em: " << path << ", linha: " << line_num <<
                        ", celula: '" << cell << "'" << std::endl;
            }
        }
    }
    if (values.empty()) {
        throw std::runtime_error("Nenhum dado numerico valido encontrado em: " + path);
    }
    Eigen::Map<Eigen::VectorXd> vec_map(values.data(), values.size());
    return Eigen::VectorXd(vec_map);
}

inline Eigen::SparseMatrix<double> convertCsvToSparse(const std::string &path, int expected_cols) {
    std::ifstream file(path);
    if (!file.is_open()) throw std::runtime_error("Nao foi possivel abrir o arquivo: " + path);
    std::vector<Eigen::Triplet<double> > tripletList;
    std::string line;
    int row = 0;
    long long actual_cols = -1;
    int line_num = 0;

    while (std::getline(file, line)) {
        line_num++;
        if (line.empty() || std::ranges::all_of(line, ::isspace)) continue;

        std::stringstream lineStream(line);
        std::string cell;
        int col = 0;
        while (std::getline(lineStream, cell, ',')) {
            try {
                std::erase_if(cell, ::isspace);
                if (!cell.empty()) {
                    double value = std::stod(cell);
                    if (std::abs(value) > 1e-12) {
                        tripletList.emplace_back(row, col, value);
                    }
                }
            } catch (const std::invalid_argument &) {
                std::cerr << "[AVISO] Ignorando valor nao numerico em CSV esparso: " << path << ", linha: " << line_num
                        << ", celula: '" << cell << "'" << std::endl;
            } catch (const std::out_of_range &) {
                std::cerr << "[AVISO] Ignorando valor fora do range em CSV esparso: " << path << ", linha: " << line_num
                        << ", celula: '" << cell << "'" << std::endl;
            }
            col++;
        }
        if (actual_cols == -1) {
            if (col == 0) continue;
            actual_cols = col;
        } else if (col != actual_cols) {
            std::cerr << "[ERRO] Numero inconsistente de colunas na linha " << line_num << " do arquivo esparso " <<
                    path << ". Esperado: " << actual_cols << ", Encontrado: " << col << ". Abortando." << std::endl;
            throw std::runtime_error("Inconsistencia de colunas no CSV esparso.");
        }
        row++;
    }
    if (row == 0 || actual_cols <= 0) {
        throw std::runtime_error("Nao foi possivel ler nenhuma linha/coluna valida do arquivo esparso: " + path);
    }
    if (expected_cols > 0 && actual_cols != expected_cols) {
        std::cerr << "[AVISO] Numero de colunas lido (" << actual_cols << ") difere do esperado (" << expected_cols <<
                ") para " << path << ". Usando o numero lido." << std::endl;
    }

    Eigen::SparseMatrix<double> mat(row, actual_cols);
    if (!tripletList.empty()) {
        mat.setFromTriplets(tripletList.begin(), tripletList.end());
    } else {
        std::cerr << "[AVISO] Nenhum elemento nao-zero (acima de 1e-12) encontrado em " << path << std::endl;
    }
    mat.makeCompressed();
    return mat;
}

inline void saveSparseMatrix(const Eigen::SparseMatrix<double> &mat, const std::string &path) {
    std::ofstream file(path, std::ios::binary | std::ios::trunc);
    if (!file.is_open()) throw std::runtime_error("Nao foi possivel criar o arquivo binario: " + path);

    Eigen::SparseMatrix<double> compressed_mat = mat;
    if (!compressed_mat.isCompressed()) {
        compressed_mat.makeCompressed();
    }

    const auto rows = compressed_mat.rows();
    const auto cols = compressed_mat.cols();
    const auto nonZeros = compressed_mat.nonZeros();
    const auto outerSize = compressed_mat.outerSize();

    file.write(reinterpret_cast<const char *>(&rows), sizeof(rows));
    file.write(reinterpret_cast<const char *>(&cols), sizeof(cols));
    file.write(reinterpret_cast<const char *>(&nonZeros), sizeof(nonZeros));

    if (nonZeros > 0) {
        if (!compressed_mat.valuePtr() || !compressed_mat.innerIndexPtr()) {
            throw std::runtime_error("Ponteiros internos invalidos ao salvar matriz esparsa para: " + path);
        }
        file.write(reinterpret_cast<const char *>(compressed_mat.valuePtr()), nonZeros * sizeof(double));
        file.write(reinterpret_cast<const char *>(compressed_mat.innerIndexPtr()), nonZeros * sizeof(int));
    }
    if (!compressed_mat.outerIndexPtr()) {
        throw std::runtime_error("Ponteiro outerIndex invalido ao salvar matriz esparsa para: " + path);
    }
    file.write(reinterpret_cast<const char *>(compressed_mat.outerIndexPtr()), (outerSize + 1) * sizeof(int));

    if (!file) throw std::runtime_error("Erro ao escrever no arquivo binario esparso: " + path);
    file.close();
    if (!file) throw std::runtime_error("Erro ao fechar o arquivo binario esparso: " + path);
}


inline Eigen::SparseMatrix<double> loadSparseMatrix(const std::string &path) {
    std::ifstream file(path, std::ios::binary);
    if (!file.is_open()) throw std::runtime_error("Nao foi possivel abrir o arquivo binario: " + path);
    Eigen::Index rows, cols;
    Eigen::Index nonZeros;
    file.read(reinterpret_cast<char *>(&rows), sizeof(rows));
    file.read(reinterpret_cast<char *>(&cols), sizeof(cols));
    file.read(reinterpret_cast<char *>(&nonZeros), sizeof(nonZeros));

    if (!file || file.eof()) throw std::runtime_error("Erro ao ler cabecalho do arquivo binario esparso: " + path);
    if (rows < 0 || cols < 0 || nonZeros < 0) throw std::runtime_error(
        "Dimensoes invalidas (" + std::to_string(rows) + "x" + std::to_string(cols) + ", nnz=" +
        std::to_string(nonZeros) + ") lidas do arquivo binario esparso: " + path);

    Eigen::SparseMatrix<double> mat(rows, cols);
    mat.makeCompressed();
    mat.resizeNonZeros(nonZeros);

    if (nonZeros > 0) {
        if (!mat.valuePtr() || !mat.innerIndexPtr()) {
            throw std::runtime_error("Ponteiros value/inner invalidos apos resizeNonZeros ao carregar: " + path);
        }
        file.read(reinterpret_cast<char *>(mat.valuePtr()), nonZeros * sizeof(double));
        file.read(reinterpret_cast<char *>(mat.innerIndexPtr()), nonZeros * sizeof(int));
    }

    if (!mat.outerIndexPtr()) {
        throw std::runtime_error("Ponteiro outerIndex invalido apos makeCompressed ao carregar: " + path);
    }
    file.read(reinterpret_cast<char *>(mat.outerIndexPtr()), (mat.outerSize() + 1) * sizeof(int));

    if (!file) {
        if (file.eof()) {
            std::cerr << "[AVISO] Fim de arquivo prematuro ao ler dados de " << path <<
                    ". A matriz pode estar incompleta." << std::endl;
            throw std::runtime_error("Fim de arquivo inesperado ao ler dados do arquivo binario esparso: " + path);
        } else {
            throw std::runtime_error("Erro de leitura ao processar dados do arquivo binario esparso: " + path);
        }
    }
    mat.finalize();
    return mat;
}

inline Eigen::MatrixXd loadDenseData(const std::string &path) {
    std::ifstream file(path);
    if (!file.is_open()) throw std::runtime_error("Nao foi possivel abrir o arquivo: " + path);
    std::vector<double> values;
    std::string line;
    int rows = 0;
    long long cols = -1;
    int line_num = 0;

    while (std::getline(file, line)) {
        line_num++;
        if (line.empty() || std::all_of(line.begin(), line.end(), ::isspace)) continue;

        std::stringstream lineStream(line);
        std::string cell;
        long long current_cols = 0;
        std::vector<double> row_values;

        while (std::getline(lineStream, cell, ',')) {
            try {
                cell.erase(std::remove_if(cell.begin(), cell.end(), ::isspace), cell.end());
                if (!cell.empty()) {
                    row_values.push_back(std::stod(cell));
                } else {
                    row_values.push_back(0.0);
                    std::cerr << "[AVISO] Celula vazia encontrada em: " << path << ", linha: " << line_num <<
                            ", coluna: " << current_cols + 1 << ". Assumindo 0.0." << std::endl;
                }
                current_cols++;
            } catch (const std::invalid_argument &) {
                std::cerr << "[AVISO] Ignorando valor nao numerico em: " << path << ", linha: " << line_num <<
                        ", celula: '" << cell << "'" << std::endl;
                row_values.push_back(0.0);
                current_cols++;
            } catch (const std::out_of_range &) {
                std::cerr << "[AVISO] Ignorando valor fora do range em: " << path << ", linha: " << line_num <<
                        ", celula: '" << cell << "'" << std::endl;
                row_values.push_back(0.0);
                current_cols++;
            }
        }

        if (cols == -1) {
            if (current_cols == 0) continue;
            cols = current_cols;
        } else if (current_cols != cols) {
            std::cerr << "[ERRO] Numero inconsistente de colunas na linha " << line_num << " do arquivo " << path <<
                    ". Esperado: " << cols << ", Encontrado: " << current_cols << ". Abortando." << std::endl;
            throw std::runtime_error("Inconsistencia de colunas no CSV denso.");
        }

        values.insert(values.end(), row_values.begin(), row_values.end());
        rows++;
    }
    if (rows == 0 || cols <= 0 || values.empty()) {
        throw std::runtime_error(
            "Nao foi possivel carregar dados validos da matriz densa de: " + path + " (rows=" + std::to_string(rows) +
            ", cols=" + std::to_string(cols) + ")");
    }

    Eigen::Map<Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor> > mat_map(
        values.data(), rows, cols);
    return Eigen::MatrixXd(mat_map);
}

inline Eigen::MatrixXd loadDenseMatrix(const std::string &path) {
    std::ifstream file(path, std::ios::binary);
    if (!file.is_open()) throw std::runtime_error("Nao foi possivel abrir o arquivo binario: " + path);
    Eigen::Index rows, cols;
    file.read(reinterpret_cast<char *>(&rows), sizeof(rows));
    file.read(reinterpret_cast<char *>(&cols), sizeof(cols));

    if (!file || file.eof()) throw std::runtime_error("Erro ao ler cabecalho do arquivo binario denso: " + path);
    if (rows <= 0 || cols <= 0) throw std::runtime_error(
        "Dimensoes invalidas (" + std::to_string(rows) + "x" + std::to_string(cols) +
        ") lidas do arquivo binario denso: " + path);

    Eigen::MatrixXd mat(rows, cols);
    file.read(reinterpret_cast<char *>(mat.data()), static_cast<std::streamsize>(rows) * cols * sizeof(double));
    if (!file) {
        if (file.eof() && (static_cast<std::streamsize>(rows) * cols * sizeof(double) > 0)) {
            throw std::runtime_error("Fim de arquivo inesperado ao ler dados do arquivo binario denso: " + path);
        } else if (!file.eof()) {
            throw std::runtime_error("Erro de leitura ao processar dados do arquivo binario denso: " + path);
        }
    }
    return mat;
}

inline void saveDenseMatrix(const Eigen::MatrixXd &mat, const std::string &path) {
    std::ofstream file(path, std::ios::binary | std::ios::trunc);
    if (!file.is_open()) throw std::runtime_error("Nao foi possivel criar o arquivo binario: " + path);
    const auto rows = mat.rows(), cols = mat.cols();
    file.write(reinterpret_cast<const char *>(&rows), sizeof(rows));
    file.write(reinterpret_cast<const char *>(&cols), sizeof(cols));
    file.write(reinterpret_cast<const char *>(mat.data()), static_cast<std::streamsize>(rows) * cols * sizeof(double));
    if (!file) throw std::runtime_error("Erro ao escrever no arquivo binario denso: " + path);
    file.close();
    if (!file) throw std::runtime_error("Erro ao fechar o arquivo binario denso: " + path);
}


inline void saveHistoryToCSV(const std::vector<double> &history, const std::string &filename) {
    std::ofstream file(filename);
    if (!file.is_open()) {
        std::cerr << "[AVISO] Nao foi possivel criar o arquivo de historico: " << filename << std::endl;
        return;
    }
    file << "Iteration,ResidualNorm\n";
    for (size_t i = 0; i < history.size(); ++i) {
        file << i + 1 << "," << std::scientific << std::setprecision(8) << history[i] << "\n";
    }
    if (!file) {
        std::cerr << "[AVISO] Erro ao escrever no arquivo de historico: " << filename << std::endl;
    }
    file.close();
}

// Função auxiliar para manter compatibilidade com ReconstructionResult
inline void saveHistoryToCSV(const ReconstructionResult &result, const std::string &filename) {
    std::ofstream file(filename);
    if (!file.is_open()) {
        std::cerr << "[AVISO] Nao foi possivel criar o arquivo de historico: " << filename << std::endl;
        return;
    }

    // Cabeçalho com mais métricas
    file << "Iteration,ResidualNorm,SolutionNorm,ExecutionTime_ms\n";

    for (size_t i = 0; i < result.residual_history.size(); ++i) {
        file << i + 1 << ","
                << std::scientific << std::setprecision(8) << result.residual_history[i] << ","
                << std::scientific << std::setprecision(8) << (i < result.solution_history.size()
                                                                   ? result.solution_history[i]
                                                                   : 0.0) << ","
                << std::fixed << std::setprecision(2) << result.execution_time_ms << "\n";
    }

    if (!file) {
        std::cerr << "[AVISO] Erro ao escrever no arquivo de historico: " << filename << std::endl;
    } else {
        std::cout << "[INFO] Historico de convergencia salvo em: " << filename << std::endl;
    }
    file.close();
}

inline void saveLcurveToCSV(const ReconstructionResult &result, const std::string &filename) {
    if (result.residual_history.size() != result.solution_history.size()) {
        std::cerr << "[AVISO] Tamanhos incompativeis (" << result.residual_history.size() << " vs "
                << result.solution_history.size() << ") de historico de residuo e solucao para L-curve. Nao salvando "
                << filename << std::endl;
        return;
    }
    if (result.residual_history.empty()) {
        std::cerr << "[AVISO] Historico vazio, nada para salvar em L-curve: " << filename << std::endl;
        return;
    }
    std::ofstream file(filename);
    if (!file.is_open()) {
        std::cerr << "[AVISO] Nao foi possivel criar o arquivo de cotovelo: " << filename << std::endl;
        return;
    }
    file << "Iteration,SolutionNorm,ResidualNorm\n";
    for (size_t i = 0; i < result.residual_history.size(); ++i) {
        file << i + 1 << ","
                << std::scientific << std::setprecision(8) << result.solution_history[i] << ","
                << std::scientific << std::setprecision(8) << result.residual_history[i] << "\n";
    }
    if (!file) {
        std::cerr << "[AVISO] Erro ao escrever no arquivo L-curve: " << filename << std::endl;
    } else {
        std::cout << "[INFO] Dados L-curve salvos em: " << filename << std::endl;
    }
    file.close();
}

inline void saveImageVectorToCsv(const Eigen::VectorXd &vec, const std::string &filename, int img_rows, int img_cols) {
    if (vec.size() != static_cast<long long>(img_rows) * img_cols) {
        std::cerr << "[AVISO] Tamanho do vetor (" << vec.size() << ") nao corresponde as dimensoes da imagem ("
                << img_rows << "x" << img_cols << "). Nao salvando imagem: " << filename << std::endl;
        return;
    }
    if (img_rows <= 0 || img_cols <= 0) {
        std::cerr << "[AVISO] Dimensoes invalidas da imagem (" << img_rows << "x" << img_cols
                << "). Nao salvando imagem: " << filename << std::endl;
        return;
    }

    std::ofstream file(filename);
    if (!file.is_open()) {
        std::cerr << "[AVISO] Nao foi possivel criar o arquivo CSV da imagem: " << filename << std::endl;
        return;
    }

    file << std::scientific << std::setprecision(8);

    for (int i = 0; i < img_rows; ++i) {
        for (int j = 0; j < img_cols; ++j) {
            long long index = static_cast<long long>(j) * img_rows + i; // ColMajor Indexing
            if (index < vec.size()) {
                file << vec(index);
            } else {
                file << 0.0;
            }
            if (j < img_cols - 1) {
                file << ",";
            }
        }
        file << "\n";
    }

    if (!file) {
        std::cerr << "[AVISO] Erro ao escrever no arquivo CSV da imagem: " << filename << std::endl;
    } else {
        std::cout << "[INFO] Imagem reconstruida salva em: " << filename << std::endl;
    }
    file.close();
}

template<typename MatrixType>
inline void normalize_system_rows(MatrixType &H, Eigen::VectorXd &g) {
    if (H.rows() != g.size()) {
        throw std::runtime_error("normalize_system_rows: Dimensoes H/g incompativeis.");
    }
    if (H.rows() == 0) return;

    std::cout << "[INFO] Normalizando linhas de H e elementos de g..." << std::endl;
    constexpr double epsilon_norm = 1e-12;

    if constexpr (std::is_same_v<MatrixType, Eigen::MatrixXd>) {
#pragma omp parallel for
        for (Eigen::Index i = 0; i < H.rows(); ++i) {
            double row_norm = H.row(i).norm();
            if (row_norm > epsilon_norm) {
                H.row(i) /= row_norm;
                g(i) /= row_norm;
            } else {
                H.row(i).setZero();
                g(i) = 0.0;
            }
        }
    } else {
        // Esparsa
        std::vector<double> row_norms_sq(H.rows(), 0.0);
        for (int k = 0; k < H.outerSize(); ++k) {
            for (typename MatrixType::InnerIterator it(H, k); it; ++it) {
                row_norms_sq[it.row()] += it.value() * it.value();
            }
        }
        std::vector<Eigen::Triplet<double> > triplets_normalized;
        triplets_normalized.reserve(H.nonZeros());
        for (int k = 0; k < H.outerSize(); ++k) {
            for (typename MatrixType::InnerIterator it(H, k); it; ++it) {
                double row_norm = std::sqrt(row_norms_sq[it.row()]);
                if (row_norm > epsilon_norm) {
                    triplets_normalized.emplace_back(it.row(), it.col(), it.value() / row_norm);
                }
            }
        }
        H.setFromTriplets(triplets_normalized.begin(), triplets_normalized.end());
#pragma omp parallel for
        for (Eigen::Index i = 0; i < g.size(); ++i) {
            double row_norm = std::sqrt(row_norms_sq[i]);
            if (row_norm > epsilon_norm) { g(i) /= row_norm; } else { g(i) = 0.0; }
        }
    }
    std::cout << "[INFO] Normalizacao concluida." << std::endl;
}


// --- Solver CGNR Regularizado (Salva Imagens Intermediárias) ---
template<typename MatrixType>
inline ReconstructionResult run_cgnr_solver_epsilon_save_iters(
    const Eigen::VectorXd &g_signal, const MatrixType &H_model,
    const double tolerance, const int max_iterations,
    const std::string &base_filename_prefix,
    const std::filesystem::path &output_dir,
    int img_rows, int img_cols) {
    if (H_model.rows() != g_signal.size()) throw std::runtime_error(
        "Dimensoes incompativeis: H.rows()!=" + std::to_string(H_model.rows()) + " vs g.size()=" + std::to_string(
            g_signal.size()));
    if (H_model.cols() <= 0) throw std::runtime_error("Matriz H tem " + std::to_string(H_model.cols()) + " colunas.");
    if (H_model.rows() == 0) return ReconstructionResult{};


    const auto start_time = std::chrono::high_resolution_clock::now();

    Eigen::VectorXd f = Eigen::VectorXd::Zero(H_model.cols());
    Eigen::VectorXd r = g_signal;
    Eigen::VectorXd z = H_model.transpose() * r;
    Eigen::VectorXd p = z;
    double z_norm_sq = z.squaredNorm();

    double lambda = 0.0;
    if (z.size() > 0) {
        lambda = z.cwiseAbs().maxCoeff() * 0.10;
        constexpr double min_lambda = 1e-9;
        if (lambda < min_lambda) {
            lambda = min_lambda;
            std::cout << "[INFO] Lambda calculado era quase zero, usando piso minimo: " << lambda << std::endl;
        }
    } else {
        lambda = 1e-9;
        std::cout << "[AVISO] Vetor z inicial vazio, usando lambda=" << lambda << " como fallback." << std::endl;
    }
    std::cout << "[INFO] Lambda (solver standard): " << lambda << std::endl;

    ReconstructionResult result;
    result.iterations = 0;
    result.converged = false;
    result.residual_history.clear();
    result.residual_history.reserve(max_iterations);
    result.solution_history.clear();
    result.solution_history.reserve(max_iterations);
    double previous_residual_norm = r.norm();
    double current_residual_norm = previous_residual_norm;
    double epsilon = std::numeric_limits<double>::max();

    bool save_iters = !base_filename_prefix.empty() && img_rows > 0 && img_cols > 0;
    if (save_iters) {
        try {
            std::filesystem::path iter_img_path = output_dir / (base_filename_prefix + "_iter_0.csv");
            saveImageVectorToCsv(f, iter_img_path.string(), img_rows, img_cols);
        } catch (const std::exception &e) {
            std::cerr << "[AVISO] Falha ao salvar imagem iter 0: " << e.what() << std::endl;
        }
    }


    for (int i = 0; i < max_iterations; ++i) {
        result.iterations = i + 1;
        Eigen::VectorXd w = H_model * p;
        double p_norm_sq = p.squaredNorm();
        double modified_denominator = w.squaredNorm() + lambda * p_norm_sq;

        if (modified_denominator < std::numeric_limits<double>::epsilon()) {
            std::cout << "[INFO] Denominador modificado (...) proximo de zero na iteracao " << i + 1 << ". Parando." <<
                    std::endl;
            break;
        }

        double alpha = z_norm_sq / modified_denominator;
        f += alpha * p;
        r -= alpha * w;

        if (save_iters) {
            try {
                std::filesystem::path iter_img_path =
                        output_dir / (base_filename_prefix + "_iter_" + std::to_string(i + 1) + ".csv");
                saveImageVectorToCsv(f, iter_img_path.string(), img_rows, img_cols);
            } catch (const std::exception &e) {
                std::cerr << "[AVISO] Falha ao salvar imagem iter " << i + 1 << ": " << e.what() << std::endl;
            }
        }

        Eigen::VectorXd z_next = (H_model.transpose() * r) - (lambda * f);
        const double z_next_norm_sq = z_next.squaredNorm();

        current_residual_norm = r.norm();
        result.residual_history.push_back(current_residual_norm);
        result.solution_history.push_back(f.norm());
        epsilon = std::abs(current_residual_norm - previous_residual_norm);

        if (epsilon < tolerance) {
            result.converged = true;
            std::cout << "[INFO] Convergencia por epsilon atingida na iteracao " << i + 1 << " (epsilon=" <<
                    std::scientific << epsilon << " < " << tolerance << ")" << std::defaultfloat << std::endl;
            break;
        }
        previous_residual_norm = current_residual_norm;

        double beta = 0.0;
        if (z_norm_sq >= std::numeric_limits<double>::epsilon()) { beta = z_next_norm_sq / z_norm_sq; } else {
            std::cout << "[INFO] ||z||^2 (...) proximo de zero na iteracao " << i + 1 << ". Usando beta=0 (restart)." <<
                    std::endl;
            if (z_next_norm_sq < std::numeric_limits<double>::epsilon()) {
                std::cout << "[INFO] ||z_next||^2 tambem proximo de zero. Provavelmente estagnou. Parando." <<
                        std::endl;
                break;
            }
        }

        p = z_next + beta * p;
        z = z_next;
        z_norm_sq = z_next_norm_sq;

        if (i == max_iterations - 1 && !result.converged) {
            std::cout << "[INFO] Numero maximo de iteracoes (" << max_iterations <<
                    ") atingido sem convergencia por epsilon (ultimo epsilon=" << std::scientific << epsilon <<
                    std::defaultfloat << ")." << std::endl;
        }
    }

    const auto end_time = std::chrono::high_resolution_clock::now();
    result.image = f;
    result.final_error = current_residual_norm;
    result.final_epsilon = epsilon;
    result.execution_time_ms = std::chrono::duration<double, std::milli>(end_time - start_time).count();
    return result;
}

// --- Solver CGNR Pré-condicionado (Salva Imagens Intermediárias) ---
template<typename MatrixType>
inline ReconstructionResult run_cgnr_solver_preconditioned_save_iters(
    const Eigen::VectorXd &g_signal, const MatrixType &H_model,
    const double tolerance, const int max_iterations,
    const std::string &base_filename_prefix,
    const std::filesystem::path &output_dir,
    int img_rows, int img_cols) {
    if (H_model.rows() != g_signal.size()) throw std::runtime_error("...");
    if (H_model.cols() <= 0) throw std::runtime_error("...");
    if (H_model.rows() == 0) return ReconstructionResult{};

    const auto start_time = std::chrono::high_resolution_clock::now();

    Eigen::VectorXd f = Eigen::VectorXd::Zero(H_model.cols());
    Eigen::VectorXd r = g_signal;
    Eigen::VectorXd z_unprec = H_model.transpose() * r;

    Eigen::VectorXd preconditioner = Eigen::VectorXd::Ones(H_model.cols());
    if constexpr (std::is_same_v<MatrixType, Eigen::MatrixXd>) {
#pragma omp parallel for schedule(static)
        for (Eigen::Index j = 0; j < H_model.cols(); ++j) {
            preconditioner(j) = H_model.col(j).squaredNorm();
        }
    } else {
        // Esparsa
        preconditioner.setZero();
        for (int k = 0; k < H_model.outerSize(); ++k) {
            for (typename MatrixType::InnerIterator it(H_model, k); it; ++it) {
                preconditioner(it.col()) += it.value() * it.value();
            }
        }
    }
    preconditioner = preconditioner.cwiseMax(1e-12).cwiseInverse();
    std::cout << "[INFO] Pre-condicionador Jacobi calculado." << std::endl;

    Eigen::VectorXd z = z_unprec.cwiseProduct(preconditioner);
    Eigen::VectorXd p = z;
    double z_precond_dot_z = z_unprec.dot(z);

    double lambda = 0.0;
    if (z_unprec.size() > 0) {
        lambda = z_unprec.cwiseAbs().maxCoeff() * 0.10;
        constexpr double min_lambda = 1e-9;
        if (lambda < min_lambda) {
            lambda = min_lambda;
            std::cout << "[INFO] Lambda calculado era quase zero, usando piso minimo: " << lambda << std::endl;
        }
    } else {
        lambda = 1e-9;
        std::cout << "[AVISO] Vetor z inicial (unprec) vazio, usando lambda=" << lambda << " como fallback." <<
                std::endl;
    }
    std::cout << "[INFO] Lambda (solver precond): " << lambda << std::endl;

    ReconstructionResult result;
    result.iterations = 0;
    result.converged = false;
    result.residual_history.clear();
    result.residual_history.reserve(max_iterations);
    result.solution_history.clear();
    result.solution_history.reserve(max_iterations);
    double previous_residual_norm = r.norm();
    double current_residual_norm = previous_residual_norm;
    double epsilon = std::numeric_limits<double>::max();

    if (!base_filename_prefix.empty() && img_rows > 0 && img_cols > 0) {
        try {
            std::filesystem::path iter_img_path = output_dir / (base_filename_prefix + "_iter_0.csv");
            saveImageVectorToCsv(f, iter_img_path.string(), img_rows, img_cols);
        } catch (const std::exception &e) {
            std::cerr << "[AVISO] Falha ao salvar imagem iter 0 (precond): " << e.what() << std::endl;
        }
    }

    for (int i = 0; i < max_iterations; ++i) {
        result.iterations = i + 1;
        Eigen::VectorXd w = H_model * p;
        double p_norm_sq = p.squaredNorm();
        double modified_denominator = w.squaredNorm() + lambda * p_norm_sq;

        if (modified_denominator < std::numeric_limits<double>::epsilon()) {
            std::cout << "[INFO] Denominador modificado (...) proximo de zero na iteracao " << i + 1 << ". Parando." <<
                    std::endl;
            break;
        }

        double alpha = z_precond_dot_z / modified_denominator;
        f += alpha * p;
        r -= alpha * w;

        if (!base_filename_prefix.empty() && img_rows > 0 && img_cols > 0) {
            try {
                std::filesystem::path iter_img_path =
                        output_dir / (base_filename_prefix + "_iter_" + std::to_string(i + 1) + ".csv");
                saveImageVectorToCsv(f, iter_img_path.string(), img_rows, img_cols);
            } catch (const std::exception &e) {
                std::cerr << "[AVISO] Falha ao salvar imagem iter " << i + 1 << " (precond): " << e.what() << std::endl;
            }
        }

        Eigen::VectorXd z_next_unprec = (H_model.transpose() * r) - (lambda * f);
        Eigen::VectorXd z_next = z_next_unprec.cwiseProduct(preconditioner);
        double z_next_precond_dot_z_next = z_next_unprec.dot(z_next);

        current_residual_norm = r.norm();
        result.residual_history.push_back(current_residual_norm);
        result.solution_history.push_back(f.norm());
        epsilon = std::abs(current_residual_norm - previous_residual_norm);

        if (epsilon < tolerance) {
            result.converged = true;
            std::cout << "[INFO] Convergencia por epsilon atingida na iteracao " << i + 1 << " (epsilon=" <<
                    std::scientific << epsilon << " < " << tolerance << ")" << std::defaultfloat << std::endl;
            break;
        }
        previous_residual_norm = current_residual_norm;

        double beta = 0.0;
        if (z_precond_dot_z >= std::numeric_limits<double>::epsilon()) {
            beta = z_next_precond_dot_z_next / z_precond_dot_z;
        } else {
            std::cout << "[INFO] ||z||^2 (...) proximo de zero na iteracao " << i + 1 << ". Usando beta=0 (restart)." <<
                    std::endl;
            if (z_next_precond_dot_z_next < std::numeric_limits<double>::epsilon()) {
                std::cout << "[INFO] ||z_next||^2 tambem proximo de zero. Provavelmente estagnou. Parando." <<
                        std::endl;
                break;
            }
        }

        p = z_next + beta * p;
        z = z_next;
        z_precond_dot_z = z_next_precond_dot_z_next;

        if (i == max_iterations - 1 && !result.converged) {
            std::cout << "[INFO] Numero maximo de iteracoes (" << max_iterations <<
                    ") atingido sem convergencia por epsilon (ultimo epsilon=" << std::scientific << epsilon <<
                    std::defaultfloat << ")." << std::endl;
        }
    }

    const auto end_time = std::chrono::high_resolution_clock::now();
    result.image = f;
    result.final_error = current_residual_norm;
    result.final_epsilon = epsilon;
    result.execution_time_ms = std::chrono::duration<double, std::milli>(end_time - start_time).count();
    return result;
}

// Solver Fixo (NÃO salva imagens intermediárias)
template<typename MatrixType>
inline ReconstructionResult run_cgnr_solver_fixed_iter(const Eigen::VectorXd &g_signal, const MatrixType &H_model,
                                                       const int num_iterations) {
    if (H_model.rows() != g_signal.size()) throw std::runtime_error("...");
    if (H_model.cols() <= 0) throw std::runtime_error("...");
    if (H_model.rows() == 0) return ReconstructionResult{};

    const auto start_time = std::chrono::high_resolution_clock::now();
    Eigen::VectorXd f = Eigen::VectorXd::Zero(H_model.cols());
    Eigen::VectorXd r = g_signal;
    Eigen::VectorXd z = H_model.transpose() * r;
    Eigen::VectorXd p = z;
    double z_norm_sq = z.squaredNorm();
    ReconstructionResult result;
    result.iterations = 0;
    result.converged = false;
    result.residual_history.clear();
    result.residual_history.reserve(num_iterations);
    result.solution_history.clear();
    result.solution_history.reserve(num_iterations);


    for (int i = 0; i < num_iterations; ++i) {
        result.iterations = i + 1;
        double current_residual_norm = r.norm();
        result.residual_history.push_back(current_residual_norm);
        double current_solution_norm = f.norm();
        result.solution_history.push_back(current_solution_norm);
        Eigen::VectorXd w = H_model * p;
        double w_norm_sq = w.squaredNorm();
        double alpha = 0.0;
        if (w_norm_sq >= std::numeric_limits<double>::epsilon()) { alpha = z_norm_sq / w_norm_sq; } else {
            /* std::cout << "[AVISO - FixedIter] ||H*p||^2 proximo de zero..." << std::endl; */
            z_norm_sq = 0.0;
        }
        f += alpha * p;
        r -= alpha * w;
        Eigen::VectorXd z_next = H_model.transpose() * r;
        const double z_next_norm_sq = z_next.squaredNorm();
        double beta = 0.0;
        if (z_norm_sq >= std::numeric_limits<double>::epsilon()) { beta = z_next_norm_sq / z_norm_sq; } else {
            /* std::cout << "[AVISO - FixedIter] ||z||^2 proximo de zero..." << std::endl; */
        }
        p = z_next + beta * p;
        z = z_next;
        z_norm_sq = z_next_norm_sq;
    }
    const auto end_time = std::chrono::high_resolution_clock::now();
    result.image = f;
    result.final_error = r.norm();
    result.execution_time_ms = std::chrono::duration<double, std::milli>(end_time - start_time).count();
    return result;
}

// --- Funções FISTA (Novas) ---

template<typename MatrixType>
inline double calculate_lipschitz_constant(const MatrixType &H, int max_power_iters = 20) {
    if (H.cols() == 0) return 1.0;

    Eigen::VectorXd v = Eigen::VectorXd::Random(H.cols());
    v.normalize();

    for (int i = 0; i < max_power_iters; ++i) {
        Eigen::VectorXd H_v = H * v;
        Eigen::VectorXd Ht_H_v = H.transpose() * H_v;
        v = Ht_H_v;
        v.normalize();
    }

    Eigen::VectorXd H_v = H * v;
    double L = H_v.squaredNorm();

    L = L * 1.05; // 5% de margem
    if (L < 1e-6) L = 1.0; // Evita L zero

    std::cout << "[INFO] Constante de Lipschitz (c) estimada: " << L << std::endl;
    return L;
}

inline double soft_threshold(double x, double alpha) {
    if (x > alpha) return x - alpha;
    if (x < -alpha) return x + alpha;
    return 0.0;
}

inline Eigen::VectorXd soft_threshold_vec(const Eigen::VectorXd &x, double alpha) {
    return x.unaryExpr([alpha](double val) { return soft_threshold(val, alpha); });
}

template<typename MatrixType>
inline ReconstructionResult run_fista_solver_save_iters(
    const Eigen::VectorXd &g_signal, const MatrixType &H_model,
    const double tolerance, const int max_iterations,
    const std::string &base_filename_prefix,
    const std::filesystem::path &output_dir,
    int img_rows, int img_cols) {
    if (H_model.rows() != g_signal.size()) throw std::runtime_error(
        "Dimensoes incompativeis: H.rows()!=" + std::to_string(H_model.rows()) + " vs g.size()=" + std::to_string(
            g_signal.size()));
    if (H_model.cols() <= 0) throw std::runtime_error("Matriz H tem " + std::to_string(H_model.cols()) + " colunas.");
    if (H_model.rows() == 0) return ReconstructionResult{};


    const auto start_time = std::chrono::high_resolution_clock::now();

    Eigen::VectorXd f_k = Eigen::VectorXd::Zero(H_model.cols());
    Eigen::VectorXd y_k = f_k;
    double t_k = 1.0;
    Eigen::VectorXd f_k_next, y_k_next;
    double t_k_next;

    double c = calculate_lipschitz_constant(H_model);
    double step_size = 1.0 / c;

    Eigen::VectorXd Ht_g = H_model.transpose() * g_signal;
    double lambda = 0.0;
    if (Ht_g.size() > 0) {
        lambda = Ht_g.cwiseAbs().maxCoeff() * 0.10;
        constexpr double min_lambda = 1e-9;
        if (lambda < min_lambda) {
            lambda = min_lambda;
            std::cout << "[INFO] Lambda (FISTA) calculado era quase zero, usando piso minimo: " << lambda << std::endl;
        }
    } else {
        lambda = 1e-9;
        std::cout << "[AVISO] Vetor H^T*g (FISTA) inicial vazio, usando lambda=" << lambda << " como fallback." <<
                std::endl;
    }
    std::cout << "[INFO] Lambda (FISTA-L1): " << lambda << std::endl;
    double threshold_param = lambda * step_size;

    ReconstructionResult result;
    result.iterations = 0;
    result.converged = false;
    result.residual_history.clear();
    result.residual_history.reserve(max_iterations);
    result.solution_history.clear();
    result.solution_history.reserve(max_iterations);

    double current_residual_norm = (g_signal - H_model * f_k).norm();
    double previous_residual_norm = current_residual_norm;
    double epsilon = std::numeric_limits<double>::max();

    bool save_iters = !base_filename_prefix.empty() && img_rows > 0 && img_cols > 0;
    if (save_iters) {
        try {
            std::filesystem::path iter_img_path = output_dir / (base_filename_prefix + "_iter_0.csv");
            saveImageVectorToCsv(f_k, iter_img_path.string(), img_rows, img_cols);
        } catch (const std::exception &e) {
            std::cerr << "[AVISO] Falha ao salvar imagem iter 0 (FISTA): " << e.what() << std::endl;
        }
    }

    for (int i = 0; i < max_iterations; ++i) {
        result.iterations = i + 1;

        Eigen::VectorXd grad_y = H_model.transpose() * (H_model * y_k - g_signal);
        f_k_next = soft_threshold_vec(y_k - step_size * grad_y, threshold_param);

        t_k_next = (1.0 + std::sqrt(1.0 + 4.0 * t_k * t_k)) / 2.0;
        y_k_next = f_k_next + ((t_k - 1.0) / t_k_next) * (f_k_next - f_k);

        f_k = f_k_next;
        y_k = y_k_next;
        t_k = t_k_next;

        if (save_iters) {
            try {
                std::filesystem::path iter_img_path =
                        output_dir / (base_filename_prefix + "_iter_" + std::to_string(i + 1) + ".csv");
                saveImageVectorToCsv(f_k, iter_img_path.string(), img_rows, img_cols);
            } catch (const std::exception &e) {
                std::cerr << "[AVISO] Falha ao salvar imagem iter " << i + 1 << " (FISTA): " << e.what() << std::endl;
            }
        }

        current_residual_norm = (g_signal - H_model * f_k).norm();
        result.residual_history.push_back(current_residual_norm);
        result.solution_history.push_back(f_k.norm());
        epsilon = std::abs(current_residual_norm - previous_residual_norm);

        if (epsilon < tolerance) {
            result.converged = true;
            std::cout << "[INFO] Convergencia por epsilon (FISTA) atingida na iteracao " << i + 1 << " (epsilon=" <<
                    std::scientific << epsilon << " < " << tolerance << ")" << std::defaultfloat << std::endl;
            break;
        }
        previous_residual_norm = current_residual_norm;

        if (i == max_iterations - 1 && !result.converged) {
            std::cout << "[INFO] Numero maximo de iteracoes (FISTA) (" << max_iterations <<
                    ") atingido sem convergencia por epsilon (ultimo epsilon=" << std::scientific << epsilon <<
                    std::defaultfloat << ")." << std::endl;
        }
    } // Fim do loop

    const auto end_time = std::chrono::high_resolution_clock::now();
    result.image = f_k;
    result.final_error = current_residual_norm;
    result.final_epsilon = epsilon;
    result.execution_time_ms = std::chrono::duration<double, std::milli>(end_time - start_time).count();
    return result;
}

// **** FIM DO FISTA ****


// --- Instanciações explícitas para os tipos de matrizes ---
template ReconstructionResult run_cgnr_solver_epsilon_save_iters<Eigen::SparseMatrix<double> >(
    const Eigen::VectorXd &g_signal, const Eigen::SparseMatrix<double> &H_model,
    double tolerance, int max_iterations,
    const std::string &base_filename_prefix, const std::filesystem::path &output_dir,
    int img_rows, int img_cols);

template ReconstructionResult run_cgnr_solver_preconditioned_save_iters<Eigen::SparseMatrix<double> >(
    const Eigen::VectorXd &g_signal, const Eigen::SparseMatrix<double> &H_model,
    double tolerance, int max_iterations,
    const std::string &base_filename_prefix, const std::filesystem::path &output_dir,
    int img_rows, int img_cols);

template ReconstructionResult run_cgnr_solver_fixed_iter<Eigen::SparseMatrix<double> >(
    const Eigen::VectorXd &g_signal, const Eigen::SparseMatrix<double> &H_model,
    int num_iterations);

// Instanciação do FISTA
template ReconstructionResult run_fista_solver_save_iters<Eigen::SparseMatrix<double> >(
    const Eigen::VectorXd &g_signal, const Eigen::SparseMatrix<double> &H_model,
    double tolerance, int max_iterations,
    const std::string &base_filename_prefix, const std::filesystem::path &output_dir,
    int img_rows, int img_cols);


// Instanciações para Matriz Densa (para reativar testes densos se necessário)
template ReconstructionResult run_cgnr_solver_epsilon_save_iters<Eigen::MatrixXd>(
    const Eigen::VectorXd &g_signal, const Eigen::MatrixXd &H_model,
    double tolerance, int max_iterations,
    const std::string &base_filename_prefix, const std::filesystem::path &output_dir,
    int img_rows, int img_cols);

template ReconstructionResult run_cgnr_solver_preconditioned_save_iters<Eigen::MatrixXd>(
    const Eigen::VectorXd &g_signal, const Eigen::MatrixXd &H_model,
    double tolerance, int max_iterations,
    const std::string &base_filename_prefix, const std::filesystem::path &output_dir,
    int img_rows, int img_cols);

template ReconstructionResult run_cgnr_solver_fixed_iter<Eigen::MatrixXd>(
    const Eigen::VectorXd &g_signal, const Eigen::MatrixXd &H_model,
    int num_iterations);

template ReconstructionResult run_fista_solver_save_iters<Eigen::MatrixXd>(
    const Eigen::VectorXd &g_signal, const Eigen::MatrixXd &H_model,
    double tolerance, int max_iterations,
    const std::string &base_filename_prefix, const std::filesystem::path &output_dir,
    int img_rows, int img_cols);


// --- Função Principal de Comparação Esparsa ---
// **** CORREÇÃO: TestConfig -> DatasetConfig ****
// Função para encontrar o ponto ótimo na curva L (declarada antes de ser usada)
inline int find_l_curve_corner(const std::vector<double> &residual_norms, const std::vector<double> &solution_norms) {
    if (residual_norms.size() < 3) return residual_norms.size() - 1;

    // Usa log dos valores para melhor análise
    std::vector<double> log_residual(residual_norms.size());
    std::vector<double> log_solution(solution_norms.size());

    // Calcula os logs e normaliza
    double min_res = *std::min_element(residual_norms.begin(), residual_norms.end());
    double max_res = *std::max_element(residual_norms.begin(), residual_norms.end());
    double min_sol = *std::min_element(solution_norms.begin(), solution_norms.end());
    double max_sol = *std::max_element(solution_norms.begin(), solution_norms.end());

    for (size_t i = 0; i < residual_norms.size(); ++i) {
        log_residual[i] = (std::log(residual_norms[i]) - std::log(min_res)) /
                          (std::log(max_res) - std::log(min_res));
        log_solution[i] = (std::log(solution_norms[i]) - std::log(min_sol)) /
                          (std::log(max_sol) - std::log(min_sol));
    }

    // Encontra o ponto de máxima curvatura
    double max_curvature = -1;
    int corner_idx = 1;

    for (size_t i = 1; i < log_residual.size() - 1; ++i) {
        // Vetores para os pontos adjacentes
        double dx1 = log_residual[i] - log_residual[i - 1];
        double dy1 = log_solution[i] - log_solution[i - 1];
        double dx2 = log_residual[i + 1] - log_residual[i];
        double dy2 = log_solution[i + 1] - log_solution[i];

        // Normaliza os vetores
        double len1 = std::sqrt(dx1 * dx1 + dy1 * dy1);
        double len2 = std::sqrt(dx2 * dx2 + dy2 * dy2);

        if (len1 > 1e-10 && len2 > 1e-10) {
            dx1 /= len1;
            dy1 /= len1;
            dx2 /= len2;
            dy2 /= len2;

            // Calcula o ângulo entre os vetores
            double cos_theta = dx1 * dx2 + dy1 * dy2;
            double curvature = 1.0 - cos_theta; // Simplificação da curvatura

            if (curvature > max_curvature) {
                max_curvature = curvature;
                corner_idx = i;
            }
        }
    }

    return corner_idx;
}

inline std::pair<PerformanceMetrics, PerformanceMetrics> run_sparse_comparison(const DatasetConfig &config) {
    PerformanceMetrics standard_metrics;
    PerformanceMetrics precond_metrics;
    standard_metrics.optimization_type = "standard";
    precond_metrics.optimization_type = "jacobi";

    // Primeiro roda com iterações suficientes para encontrar o ponto ótimo
    constexpr int initial_iterations = 50; // Número de iterações para construir a curva L
    constexpr int max_iterations = 10;
    constexpr double epsilon_tolerance = 1e-4;

    std::cout << "\n-----------------------------------------------------" << std::endl;
    // **** CORREÇÃO: test_name -> description ****
    std::cout << "Iniciando Comparacao Esparsa para: " << config.description << std::endl;
    std::cout << "-----------------------------------------------------" << std::endl;

    // **** CORREÇÃO: test_name -> name ****
    std::string base_filename = config.name; // Usa o nome curto para arquivos
    // C++17 compatível replace:
    std::replace(base_filename.begin(), base_filename.end(), ' ', '_');
    std::replace(base_filename.begin(), base_filename.end(), '(', '_');
    std::replace(base_filename.begin(), base_filename.end(), ')', '_');
    std::replace(base_filename.begin(), base_filename.end(), '-', '_');


    std::filesystem::path output_dir = "../output_csv";
    // **** CORREÇÃO: h_matrix_path -> h_matrix_csv ****
    std::filesystem::path h_path = config.h_matrix_csv;
    std::filesystem::path data_dir = h_path.parent_path();
    std::filesystem::path sparse_bin_fs_path = data_dir / (h_path.filename().string() + ".sparse.bin");

    // --- Teste 1: CGNR Padrão ---
    try {
        std::cout << "\n--- Rodando CGNR Esparso Padrao (Binario) ---\n";
        auto start_load = std::chrono::high_resolution_clock::now();
        Eigen::SparseMatrix<double> H_std = loadSparseMatrix(sparse_bin_fs_path.string());
        // **** CORREÇÃO: g_signal_path -> g_signal_csv ****
        Eigen::VectorXd g_std = loadVectorData(config.g_signal_csv);
        auto end_load = std::chrono::high_resolution_clock::now();
        standard_metrics.load_time_ms = std::chrono::duration<double, std::milli>(end_load - start_load).count();
        standard_metrics.estimated_ram_mb =
                static_cast<double>(H_std.nonZeros() * (sizeof(double) + sizeof(int)) + (H_std.outerSize() + 1) * sizeof
                                    (int)) / (1024.0 * 1024.0);

        normalize_system_rows(H_std, g_std);
        Eigen::VectorXd z0_std = H_std.transpose() * g_std;
        std::cout << "[DEBUG Standard] Norma de z0 (H^T * g norm): " << z0_std.norm() << std::endl;

        // Define o prefixo do arquivo para o FISTA
        std::string filename_prefix_std = "image_" + base_filename + "_sparse_standard";
        std::string filename_prefix_fista = "image_" + base_filename + "_sparse_fista";
        ReconstructionResult res_std = run_cgnr_solver_epsilon_save_iters(
            g_std, H_std, epsilon_tolerance, max_iterations,
            filename_prefix_std, output_dir, config.image_rows, config.image_cols);

        standard_metrics.solve_time_ms = res_std.execution_time_ms;
        standard_metrics.iterations = res_std.iterations;
        standard_metrics.final_error = res_std.final_error;
        standard_metrics.final_epsilon = res_std.final_epsilon;
        standard_metrics.converged = res_std.converged;

        // Primeiro executa com iterações suficientes para construir a curva L
        ReconstructionResult res_std_initial = run_cgnr_solver_fixed_iter(g_std, H_std, initial_iterations);

        // Encontra o ponto ótimo na curva L
        int optimal_iter = find_l_curve_corner(res_std_initial.residual_history, res_std_initial.solution_history);
        std::filesystem::path hist_path_std =
                output_dir / ("convergence_history_" + base_filename + "_sparse_standard.csv");
        std::filesystem::path lcurve_path_std = output_dir / ("lcurve_" + base_filename + "_sparse_standard.csv");
        saveHistoryToCSV(res_std_initial, hist_path_std.string());
        saveLcurveToCSV(res_std_initial, lcurve_path_std.string());

        // Executa novamente com o número ótimo de iterações
        std::cout << "[INFO] Ponto otimo da curva L encontrado na iteracao " << optimal_iter << std::endl;
        ReconstructionResult res_std_optimal = run_cgnr_solver_fixed_iter(g_std, H_std, optimal_iter);
    } catch (const std::exception &e) {
        std::cerr << "[ERRO - Esparso Padrao] " << e.what() << std::endl;
        standard_metrics = PerformanceMetrics();
        standard_metrics.optimization_type = "standard";
    }

    // --- Teste 2: CGNR Pré-condicionado ---
    try {
        std::cout << "\n--- Rodando CGNR Esparso Pre-condicionado (Binario) ---\n";
        auto start_load = std::chrono::high_resolution_clock::now();
        Eigen::SparseMatrix<double> H_pre = loadSparseMatrix(sparse_bin_fs_path.string());
        // **** CORREÇÃO: g_signal_path -> g_signal_csv ****
        Eigen::VectorXd g_pre = loadVectorData(config.g_signal_csv);
        auto end_load = std::chrono::high_resolution_clock::now();
        precond_metrics.load_time_ms = std::chrono::duration<double, std::milli>(end_load - start_load).count();
        precond_metrics.estimated_ram_mb =
                static_cast<double>(H_pre.nonZeros() * (sizeof(double) + sizeof(int)) + (H_pre.outerSize() + 1) * sizeof
                                    (int)) / (1024.0 * 1024.0);

        normalize_system_rows(H_pre, g_pre);
        Eigen::VectorXd z0_pre = H_pre.transpose() * g_pre;
        std::cout << "[DEBUG Precond] Norma de z0 (H^T * g norm): " << z0_pre.norm() << std::endl;

        std::string filename_prefix_pre = "image_" + base_filename + "_sparse_precond";
        ReconstructionResult res_pre = run_cgnr_solver_preconditioned_save_iters(
            g_pre, H_pre, epsilon_tolerance, max_iterations,
            filename_prefix_pre, output_dir, config.image_rows, config.image_cols);

        precond_metrics.solve_time_ms = res_pre.execution_time_ms;
        precond_metrics.iterations = res_pre.iterations;
        precond_metrics.final_error = res_pre.final_error;
        precond_metrics.final_epsilon = res_pre.final_epsilon;
        precond_metrics.converged = res_pre.converged;

        // **** CORREÇÃO: g_signal_path -> g_signal_csv ****
        // Primeiro executa com iterações suficientes para construir a curva L
        ReconstructionResult res_pre_initial = run_cgnr_solver_fixed_iter(g_pre, H_pre, initial_iterations);

        // Encontra o ponto ótimo na curva L
        int optimal_iter_pre = find_l_curve_corner(res_pre_initial.residual_history, res_pre_initial.solution_history);
        std::cout << "[INFO] Ponto otimo da curva L (precondicionado) encontrado na iteracao " << optimal_iter_pre <<
                std::endl;

        // Executa novamente com o número ótimo de iterações
        ReconstructionResult res_pre_optimal = run_cgnr_solver_fixed_iter(g_pre, H_pre, optimal_iter_pre);
        std::filesystem::path hist_path_pre =
                output_dir / ("convergence_history_" + base_filename + "_sparse_precond.csv");
        // **** CORREÇÃO: Typo "lcurve_"to_string() ****
        std::filesystem::path lcurve_path_pre = output_dir / ("lcurve_" + base_filename + "_sparse_precond.csv");
        saveHistoryToCSV(res_pre_initial, hist_path_pre.string());
        saveLcurveToCSV(res_pre_initial, lcurve_path_pre.string());
    } catch (const std::exception &e) {
        std::cerr << "[ERRO - Esparso Precondicionado] " << e.what() << std::endl;
        precond_metrics = PerformanceMetrics();
        precond_metrics.optimization_type = "jacobi";
    }

    return {standard_metrics, precond_metrics};
}

// Função para executar o FISTA e coletar métricas
inline std::pair<PerformanceMetrics, ReconstructionResult> run_sparse_fista(
    const DatasetConfig &config,
    const std::filesystem::path &output_dir,
    const double tolerance = 1e-6,
    const int max_iterations = 1000) {
    PerformanceMetrics metrics;
    metrics.optimization_type = "fista";

    const auto load_start = std::chrono::high_resolution_clock::now();

    // Carrega a matriz H do arquivo binário esparso
    const std::filesystem::path h_path(config.h_matrix_csv);
    const std::string sparse_bin_path = h_path.parent_path().string() + "/" + h_path.filename().string() +
                                        ".sparse.bin";
    Eigen::SparseMatrix<double> H = loadSparseMatrix(sparse_bin_path);

    // Carrega o sinal g
    Eigen::VectorXd g = loadVectorData(config.g_signal_csv);

    // Normaliza o sistema
    normalize_system_rows(H, g);

    const auto load_end = std::chrono::high_resolution_clock::now();
    metrics.load_time_ms = std::chrono::duration<double, std::milli>(load_end - load_start).count();

    // Estima uso de RAM (em MB) - apenas para matriz esparsa
    metrics.estimated_ram_mb = (H.nonZeros() * (sizeof(double) + sizeof(int)) +
                                H.outerSize() * sizeof(int)) / (1024.0 * 1024.0);

    // Executa o solver FISTA
    const auto solve_start = std::chrono::high_resolution_clock::now();

    ReconstructionResult result = run_fista_solver_save_iters(
        g, H, tolerance, max_iterations,
        "fista_" + config.name, output_dir,
        config.image_rows, config.image_cols
    );

    const auto solve_end = std::chrono::high_resolution_clock::now();
    metrics.solve_time_ms = std::chrono::duration<double, std::milli>(solve_end - solve_start).count();

    // Atualiza métricas finais
    metrics.iterations = result.iterations;
    metrics.final_error = result.final_error;
    metrics.final_epsilon = result.final_epsilon;
    metrics.converged = result.converged;

    return {metrics, result};
}

// Função para comparar FISTA com os outros métodos
inline std::pair<PerformanceMetrics, std::pair<PerformanceMetrics, PerformanceMetrics> >
run_sparse_comparison_with_fista(const DatasetConfig &config) {
    std::filesystem::path output_dir = "../output_csv";
    constexpr double tolerance = 1e-6;
    constexpr int max_iterations = 1000;
    constexpr int initial_iterations = 50; // Número de iterações para construir a curva L

    // Cria base_filename padronizado
    std::string base_filename = config.name;
    std::replace(base_filename.begin(), base_filename.end(), ' ', '_');
    std::replace(base_filename.begin(), base_filename.end(), '(', '_');
    std::replace(base_filename.begin(), base_filename.end(), ')', '_');
    std::replace(base_filename.begin(), base_filename.end(), '-', '_');

    // Define prefixos padronizados para todos os métodos
    std::string filename_prefix_std = "image_" + base_filename + "_sparse_standard";
    std::string filename_prefix_pre = "image_" + base_filename + "_sparse_precond";
    std::string filename_prefix_fista = "image_" + base_filename + "_sparse_fista";

    // Execute each solver
    PerformanceMetrics standard_metrics;
    standard_metrics.optimization_type = "standard";

    PerformanceMetrics precond_metrics;
    precond_metrics.optimization_type = "precond";

    PerformanceMetrics fista_metrics;
    fista_metrics.optimization_type = "fista";

    try {
        // Standard CGNR
        const auto std_load_start = std::chrono::high_resolution_clock::now();
        std::filesystem::path h_path(config.h_matrix_csv);
        std::string sparse_bin_path = h_path.parent_path().string() + "/" + h_path.filename().string() + ".sparse.bin";
        Eigen::SparseMatrix<double> H_std = loadSparseMatrix(sparse_bin_path);
        Eigen::VectorXd g_std = loadVectorData(config.g_signal_csv);
        const auto std_load_end = std::chrono::high_resolution_clock::now();
        standard_metrics.load_time_ms = std::chrono::duration<double, std::milli>(std_load_end - std_load_start).
                count();

        normalize_system_rows(H_std, g_std);
        auto std_result = run_cgnr_solver_epsilon_save_iters(
            g_std, H_std, tolerance, max_iterations,
            filename_prefix_std, output_dir,
            config.image_rows, config.image_cols
        );

        standard_metrics.solve_time_ms = std_result.execution_time_ms;
        standard_metrics.iterations = std_result.iterations;
        standard_metrics.final_error = std_result.final_error;
        standard_metrics.final_epsilon = std_result.final_epsilon;
        standard_metrics.converged = std_result.converged;

        // Save convergence history
        std::filesystem::path hist_path_std =
                output_dir / ("convergence_history_" + base_filename + "_sparse_standard.csv");
        std::filesystem::path lcurve_path_std = output_dir / ("lcurve_" + base_filename + "_sparse_standard.csv");
        saveHistoryToCSV(std_result.residual_history, hist_path_std.string());
        saveLcurveToCSV(std_result, lcurve_path_std.string());
    } catch (const std::exception &e) {
        std::cerr << "[ERRO] Falha no CGNR padrao: " << e.what() << std::endl;
    }

    try {
        // Preconditioned CGNR
        const auto pre_load_start = std::chrono::high_resolution_clock::now();
        std::filesystem::path h_path(config.h_matrix_csv);
        std::string sparse_bin_path = h_path.parent_path().string() + "/" + h_path.filename().string() + ".sparse.bin";
        Eigen::SparseMatrix<double> H_pre = loadSparseMatrix(sparse_bin_path);
        Eigen::VectorXd g_pre = loadVectorData(config.g_signal_csv);
        const auto pre_load_end = std::chrono::high_resolution_clock::now();
        precond_metrics.load_time_ms = std::chrono::duration<double, std::milli>(pre_load_end - pre_load_start).count();

        normalize_system_rows(H_pre, g_pre);
        auto pre_result = run_cgnr_solver_preconditioned_save_iters(
            g_pre, H_pre, tolerance, max_iterations,
            filename_prefix_pre, output_dir,
            config.image_rows, config.image_cols
        );

        precond_metrics.solve_time_ms = pre_result.execution_time_ms;
        precond_metrics.iterations = pre_result.iterations;
        precond_metrics.final_error = pre_result.final_error;
        precond_metrics.final_epsilon = pre_result.final_epsilon;
        precond_metrics.converged = pre_result.converged;

        // Save convergence history
        std::filesystem::path hist_path_pre =
                output_dir / ("convergence_history_" + base_filename + "_sparse_precond.csv");
        std::filesystem::path lcurve_path_pre = output_dir / ("lcurve_" + base_filename + "_sparse_precond.csv");
        saveHistoryToCSV(pre_result.residual_history, hist_path_pre.string());
        saveLcurveToCSV(pre_result, lcurve_path_pre.string());
    } catch (const std::exception &e) {
        std::cerr << "[ERRO] Falha no CGNR pre-condicionado: " << e.what() << std::endl;
    }

    try {
        // FISTA
        const auto fista_load_start = std::chrono::high_resolution_clock::now();
        std::filesystem::path h_path(config.h_matrix_csv);
        std::string sparse_bin_path = h_path.parent_path().string() + "/" + h_path.filename().string() + ".sparse.bin";
        Eigen::SparseMatrix<double> H_fista = loadSparseMatrix(sparse_bin_path);
        Eigen::VectorXd g_fista = loadVectorData(config.g_signal_csv);
        const auto fista_load_end = std::chrono::high_resolution_clock::now();
        fista_metrics.load_time_ms = std::chrono::duration<double, std::milli>(fista_load_end - fista_load_start).
                count();

        normalize_system_rows(H_fista, g_fista);
        auto fista_result = run_fista_solver_save_iters(
            g_fista, H_fista, tolerance, initial_iterations,
            filename_prefix_fista, output_dir,
            config.image_rows, config.image_cols
        );

        // Encontra o ponto ótimo na curva L
        int optimal_iter_fista = find_l_curve_corner(fista_result.residual_history, fista_result.solution_history);
        std::cout << "[INFO] Ponto otimo da curva L (FISTA) encontrado na iteracao " << optimal_iter_fista << std::endl;

        // Executa novamente com o número ótimo de iterações
        auto fista_result_optimal = run_fista_solver_save_iters(
            g_fista, H_fista, tolerance, optimal_iter_fista,
            filename_prefix_fista, output_dir,
            config.image_rows, config.image_cols
        );

        fista_metrics.solve_time_ms = fista_result.execution_time_ms;
        fista_metrics.iterations = fista_result.iterations;
        fista_metrics.final_error = fista_result.final_error;
        fista_metrics.final_epsilon = fista_result.final_epsilon;
        fista_metrics.converged = fista_result.converged;

        // Save convergence history
        std::filesystem::path hist_path_fista =
                output_dir / ("convergence_history_" + base_filename + "_sparse_fista.csv");
        std::filesystem::path lcurve_path_fista = output_dir / ("lcurve_" + base_filename + "_sparse_fista.csv");
        saveHistoryToCSV(fista_result, hist_path_fista.string());
        saveLcurveToCSV(fista_result, lcurve_path_fista.string());
    } catch (const std::exception &e) {
        std::cerr << "[ERRO] Falha no FISTA: " << e.what() << std::endl;
    }

    return {fista_metrics, {standard_metrics, precond_metrics}};
}

// --- Criação de Diretórios de Saída ---
inline void create_output_directories(const std::filesystem::path &output_dir) {
    auto images_dir = output_dir / "images";
    auto metrics_dir = output_dir / "metrics";
    auto lcurve_dir = output_dir / "lcurve";

    std::filesystem::create_directories(images_dir);
    std::filesystem::create_directories(metrics_dir);
    std::filesystem::create_directories(lcurve_dir);

    std::cout << "[INFO] Diretorios de saida criados:" << std::endl;
    std::cout << "  - Imagens: " << images_dir << std::endl;
    std::cout << "  - Metricas: " << metrics_dir << std::endl;
    std::cout << "  - Curvas L: " << lcurve_dir << std::endl;
}

inline void save_iteration_image(const Eigen::VectorXd &vec,
                                 const std::filesystem::path &output_dir,
                                 const std::string &base_filename_prefix,
                                 int iteration,
                                 int img_rows, int img_cols) {
    auto images_dir = output_dir / "images";
    std::filesystem::create_directories(images_dir);
    std::filesystem::path iter_img_path =
            images_dir / (base_filename_prefix + "_iter_" + std::to_string(iteration) + ".csv");
    saveImageVectorToCsv(vec, iter_img_path.string(), img_rows, img_cols);
}

inline void save_convergence_data(const ReconstructionResult &result,
                                  const std::filesystem::path &output_dir,
                                  const std::string &base_filename) {
    auto metrics_dir = output_dir / "metrics";
    auto lcurve_dir = output_dir / "lcurve";

    std::filesystem::create_directories(metrics_dir);
    std::filesystem::create_directories(lcurve_dir);

    const std::filesystem::path hist_path = metrics_dir / ("convergence_history_" + base_filename + ".csv");
    const std::filesystem::path lcurve_path = lcurve_dir / ("lcurve_" + base_filename + ".csv");

    saveHistoryToCSV(result, hist_path.string());
    saveLcurveToCSV(result, lcurve_path.string());
}
#endif //ULTRASOUNDSERVER_SOLVER_COMPARISON_HPP
```

## arquivo check_toeplitz_structure.py
```python
import pandas as pd
import numpy as np
import random

def check_toeplitz_robust(csv_file, num_tests=5):
    """
    Verifica a estrutura de Toeplitz de forma robusta, procurando
    ativamente por valores não-nulos para testar as diagonais.
    """
    print(f"Verificando estrutura de Toeplitz para: {csv_file}")
    try:
        # Carrega um pedaço maior para ter mais chances de achar valores
        df = pd.read_csv(csv_file, header=None, nrows=100)
        H = df.values

        print(f"Procurando {num_tests} diagonais não-nulas para testar...")
        tests_done = 0
        attempts = 0

        while tests_done < num_tests and attempts < 500:
            attempts += 1
            # Escolhe um ponto de partida aleatório
            r = random.randint(0, H.shape[0] - 2)
            c = random.randint(0, H.shape[1] - 2)

            val1 = H[r, c]

            # Só testa se o valor for significativo (não perto de zero)
            if abs(val1) > 1e-6:
                val2 = H[r + 1, c + 1]

                print(f"\n--- Teste #{tests_done + 1} ---")
                print(f"  Testando a diagonal que passa por ({r}, {c})")
                print(f"  Valor em H[{r}, {c}] = {val1:.6f}")
                print(f"  Valor em H[{r+1}, {c+1}] = {val2:.6f}")

                if np.isclose(val1, val2):
                    print("  -> \033[92mSUCESSO: Os valores na diagonal são iguais.\033[0m")
                else:
                    print("  -> \033[91mFALHA: Os valores são diferentes. A matriz NÃO é Toeplitz.\033[0m")

                tests_done += 1

        if tests_done == 0:
            print("\n[AVISO] Não foi possível encontrar diagonais com valores não-nulos para testar.")

    except Exception as e:
        print(f"\n[ERRO] Falha ao ler ou testar o arquivo: {e}")

# --- Execute os testes ---
if __name__ == "__main__":
    import debug
    # mostra o diretório do arquivo que chamou a função (o diretório de `plot_convergence.py`)
    debug.debug_files('caller')

    check_toeplitz_robust("H-1.csv")
    print("\n" + "="*40 + "\n")
    check_toeplitz_robust("H-2.csv")
```

## arquivo plot_convergence.py
```python
import os
import sys
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
from pathlib import Path
import re
from collections import defaultdict

def main():
    # Obtém o diretório do script
    script_dir = Path(__file__).parent.absolute()
    print(f"Diretório do script: {script_dir}")

    # Define o caminho para a pasta output_csv
    project_root = script_dir.parent
    output_csv_dir = project_root / "output_csv"

    print(f"Procurando CSVs em: {output_csv_dir}")

    # Verifica se a pasta output_csv existe
    if not output_csv_dir.exists():
        print(f"\n[ERRO] A pasta '{output_csv_dir}' não existe.")
        print("Execute o programa C++ primeiro para gerar os arquivos CSV")
        return False

    # Procura por arquivos CSV de imagem na raiz (onde realmente estão)
    image_files = list(output_csv_dir.glob("image_*.csv"))
    convergence_files = list(output_csv_dir.glob("convergence_history_*.csv"))
    lcurve_files = list(output_csv_dir.glob("lcurve_*.csv"))

    if not image_files and not convergence_files:
        print(f"\nNenhum arquivo CSV encontrado em '{output_csv_dir}'.")
        # Lista arquivos que existem
        all_files = list(output_csv_dir.glob("*.csv"))
        if all_files:
            print(f"\nArquivos CSV encontrados:")
            for file in sorted(all_files):
                print(f"  - {file.name}")
        return False

    print(f"\nEncontrados {len(image_files)} arquivos de imagem")
    print(f"Encontrados {len(convergence_files)} arquivos de convergência")
    print(f"Encontrados {len(lcurve_files)} arquivos de curva-L")

    # Cria gráficos
    results_created = []

    if convergence_files:
        conv_path = plot_convergence_histories(convergence_files, output_csv_dir)
        results_created.append(conv_path)

    if lcurve_files:
        lcurve_path = plot_lcurves(lcurve_files, output_csv_dir)
        results_created.append(lcurve_path)

    if image_files:
        img_path = create_image_evolution_plots(image_files, output_csv_dir)
        results_created.append(img_path)

    if results_created:
        print("\n[SUCESSO] Gráficos gerados com sucesso!")
        for path in results_created:
            if path:
                print(f"  - {path}")
        return True
    else:
        print("\n[AVISO] Nenhum gráfico foi gerado.")
        return False

def plot_convergence_histories(convergence_files, output_dir):
    """Gera gráficos de convergência"""
    try:
        fig, ax = plt.subplots(figsize=(12, 8))
        colors = ['blue', 'red', 'green', 'orange', 'purple']

        for i, file in enumerate(sorted(convergence_files)):
            try:
                df = pd.read_csv(file)
                # Extrai o nome do método do arquivo
                method_name = file.stem.replace("convergence_history_", "").replace("_", " ")
                method_name = method_name.replace("sparse", "").strip()
                method_name = method_name.replace("30x30 g1", "").strip()

                # Mapeia nomes para versões mais legíveis
                if "standard" in method_name:
                    method_name = "CGNR Padrão"
                elif "precond" in method_name:
                    method_name = "CGNR Pré-condicionado"
                elif "fista" in method_name:
                    method_name = "FISTA L1"

                if 'ResidualNorm' in df.columns and 'Iteration' in df.columns:
                    color = colors[i % len(colors)]
                    ax.semilogy(df['Iteration'], df['ResidualNorm'],
                                label=method_name, marker='o', markersize=3,
                                color=color, linewidth=2, alpha=0.8)
                    print(f"  Plotado: {method_name} ({len(df)} pontos)")

            except Exception as e:
                print(f"Erro ao processar {file.name}: {e}")

        ax.set_xlabel('Iteração', fontsize=12)
        ax.set_ylabel('Norma do Resíduo (escala log)', fontsize=12)
        ax.set_title('Histórico de Convergência - Comparação de Métodos', fontsize=14, fontweight='bold')
        ax.legend(fontsize=11)
        ax.grid(True, alpha=0.3)
        ax.set_xlim(left=0)

        # Melhora a formatação
        plt.tight_layout()

        output_path = output_dir / "convergence_comparison.png"
        plt.savefig(output_path, dpi=300, bbox_inches='tight', facecolor='white')
        plt.close()

        print(f"Gráfico de convergência salvo em: {output_path}")
        return output_path

    except Exception as e:
        print(f"Erro ao criar gráfico de convergência: {e}")
        return None

def plot_lcurves(lcurve_files, output_dir):
    """Gera gráficos de curva L"""
    try:
        fig, ax = plt.subplots(figsize=(12, 8))
        colors = ['blue', 'red', 'green', 'orange', 'purple']

        for i, file in enumerate(sorted(lcurve_files)):
            try:
                df = pd.read_csv(file)
                method_name = file.stem.replace("lcurve_", "").replace("_", " ")
                method_name = method_name.replace("sparse", "").strip()
                method_name = method_name.replace("30x30 g1", "").strip()

                # Mapeia nomes para versões mais legíveis
                if "standard" in method_name:
                    method_name = "CGNR Padrão"
                elif "precond" in method_name:
                    method_name = "CGNR Pré-condicionado"
                elif "fista" in method_name:
                    method_name = "FISTA L1"

                if 'SolutionNorm' in df.columns and 'ResidualNorm' in df.columns:
                    color = colors[i % len(colors)]
                    ax.loglog(df['ResidualNorm'], df['SolutionNorm'],
                              label=method_name, marker='o', markersize=3,
                              color=color, linewidth=2, alpha=0.8)
                    print(f"  Plotado: {method_name} ({len(df)} pontos)")

            except Exception as e:
                print(f"Erro ao processar {file.name}: {e}")

        ax.set_xlabel('Norma do Resíduo (escala log)', fontsize=12)
        ax.set_ylabel('Norma da Solução (escala log)', fontsize=12)
        ax.set_title('Curvas L - Comparação de Métodos', fontsize=14, fontweight='bold')
        ax.legend(fontsize=11)
        ax.grid(True, alpha=0.3)

        plt.tight_layout()

        output_path = output_dir / "lcurve_comparison.png"
        plt.savefig(output_path, dpi=300, bbox_inches='tight', facecolor='white')
        plt.close()

        print(f"Gráfico de curva L salvo em: {output_path}")
        return output_path

    except Exception as e:
        print(f"Erro ao criar gráfico de curva L: {e}")
        return None

def create_image_evolution_plots(image_files, output_dir):
    """Cria gráficos da evolução das imagens durante iterações"""
    try:
        # Agrupa arquivos por método
        methods = defaultdict(list)
        pattern = r'image_(.+?)_iter_(\d+)\.csv'

        for file in image_files:
            match = re.match(pattern, file.name)
            if match:
                method_base = match.group(1)
                iteration = int(match.group(2))
                methods[method_base].append((iteration, file))

        # Ordena por iteração
        for method in methods:
            methods[method].sort(key=lambda x: x[0])

        if not methods:
            print("Nenhum arquivo de imagem com padrão reconhecido encontrado.")
            return None

        print(f"Métodos encontrados para evolução de imagens: {list(methods.keys())}")

        # Cria um plot para mostrar algumas iterações de cada método
        fig, axes = plt.subplots(len(methods), 3, figsize=(15, 5*len(methods)))
        if len(methods) == 1:
            axes = axes.reshape(1, -1)

        for row, (method_name, files) in enumerate(methods.items()):
            # Seleciona 3 pontos: início, meio e fim
            indices_to_show = [0, len(files)//2, -1]

            method_display = method_name.replace("_", " ").replace("sparse", "").strip()
            if "standard" in method_display:
                method_display = "CGNR Padrão"
            elif "precond" in method_display:
                method_display = "CGNR Pré-condicionado"
            elif "fista" in method_display:
                method_display = "FISTA L1"

            for col, idx in enumerate(indices_to_show):
                if idx < len(files):
                    iteration, file_path = files[idx]
                    try:
                        # Carrega e plota a imagem
                        df = pd.read_csv(file_path, header=None)
                        image_data = df.values

                        im = axes[row, col].imshow(image_data, cmap='viridis', aspect='equal')
                        axes[row, col].set_title(f'{method_display}\nIteração {iteration}')
                        axes[row, col].axis('off')

                        # Adiciona colorbar
                        plt.colorbar(im, ax=axes[row, col], fraction=0.046)

                    except Exception as e:
                        axes[row, col].text(0.5, 0.5, f'Erro:\n{str(e)[:50]}...',
                                            transform=axes[row, col].transAxes,
                                            ha='center', va='center')
                        axes[row, col].set_title(f'{method_display}\nIteração {iteration} (Erro)')
                else:
                    axes[row, col].axis('off')

        plt.suptitle('Evolução das Imagens Reconstruídas', fontsize=16, fontweight='bold')
        plt.tight_layout()

        output_path = output_dir / "image_evolution.png"
        plt.savefig(output_path, dpi=300, bbox_inches='tight', facecolor='white')
        plt.close()

        print(f"Gráfico de evolução de imagens salvo em: {output_path}")
        return output_path

    except Exception as e:
        print(f"Erro ao criar gráfico de evolução de imagens: {e}")
        return None

if __name__ == "__main__":
    success = main()
    sys.exit(0 if success else 1)
```

## arquivo spy_plot.py
```python
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd


def plot_spy(csv_file, image_cols, title="Spy Plot da Matriz H"):
    """
    Gera um Spy Plot (grafico de espionagem) de uma matriz
    armazenada em um CSV, lendo-a em pedaços.
    """
    print(f"Gerando Spy Plot para: {csv_file}")
    print("Isso pode levar alguns minutos para arquivos grandes...")

    # Listas para guardar as coordenadas dos pontos
    rows = []
    cols = []

    try:
        # Lê o CSV em "chunks" (pedaços) para economizar memória
        chunk_iter = pd.read_csv(
            csv_file,
            chunksize=5000,  # Processa 500 linhas de cada vez
            header=None,    # Seu CSV parece não ter cabeçalho
            dtype=np.float32 # Economiza memória
        )

        current_row = 0
        for chunk in chunk_iter:
            # Encontra os índices (linha, coluna) onde o valor não é zero
            # O 'chunk.values' converte para numpy, que é mais rápido
            r_chunk, c_chunk = np.where(np.abs(chunk.values) > 1e-12)

            # Adiciona os índices encontrados às listas
            rows.extend(r_chunk + current_row) # Ajusta o índice da linha
            cols.extend(c_chunk)

            current_row += chunk.shape[0]
            print(f"Processadas {current_row} linhas...")

        print("Plotando o gráfico...")
        if not rows:
            print("[AVISO] Nenhum dado não-nulo encontrado.")
            return

        plt.figure(figsize=(15, 10))
        # 's=1' faz o ponto ser minúsculo, 'marker='.' é mais eficiente
        plt.scatter(cols, rows, s=0.1, marker='.')

        # Inverte o eixo Y para a matriz ser exibida como "linha 0 no topo"
        plt.gca().invert_yaxis()

        plt.title(title, fontsize=16)
        plt.xlabel('Índice da Coluna', fontsize=12)
        plt.ylabel('Índice da Linha', fontsize=12)

        # AQUI ESTÁ O PULO DO GATO:
        # Desenha a linha de simetria
        if image_cols > 0:
            symmetry_axis = (image_cols / 2) - 0.5 # Ponto médio
            plt.axvline(x=symmetry_axis, color='r', linestyle='--', label=f'Eixo de Simetria (Coluna {symmetry_axis:.1f})')
            plt.legend()

        plt.grid(True, linestyle=':', alpha=0.5)

        output_file = csv_file.replace('.csv', '.spy_plot.png')
        plt.savefig(output_file, dpi=200, bbox_inches='tight')
        print(f"\n[SUCESSO] Spy Plot salvo em: {output_file}")
        plt.close()

    except Exception as e:
        print(f"[ERRO] Falha ao gerar o Spy Plot: {e}")

# --- Como usar ---
if __name__ == "__main__":
    import debug
    # mostra o diretório do arquivo que chamou a função (o diretório de `plot_convergence.py`)
    debug.debug_files('caller')

    # Configure aqui

    # Teste 1: Matriz 60x60 (3600 colunas)
    plot_spy(
        csv_file="H-1.csv",
        image_cols=3600,
        title="Spy Plot - H-1 (Imagem 60x60)"
    )

    # Teste 2: Matriz 30x30 (900 colunas)
    plot_spy(
        csv_file="H-2.csv",
        image_cols=900,
        title="Spy Plot - H-2 (Imagem 30x30)"
    )
```

## arquivo debug.py
```python
# python
import os
import sys
import inspect

def _caller_dir():
    # percorre a pilha e retorna a primeira filename diferente deste arquivo
    this = os.path.abspath(__file__)
    for frame_info in inspect.stack()[1:]:
        fn = os.path.abspath(frame_info.filename)
        if fn != this:
            return os.path.dirname(fn)
    # fallback
    return os.path.dirname(os.path.abspath(sys.argv[0])) if sys.argv and sys.argv[0] else os.getcwd()

def debug_files(which='module'):
    """
    which: 'module' -> pasta deste módulo (`debug.py`)
           'caller' -> pasta do arquivo que chamou esta função
           'cwd'    -> diretório de trabalho atual
    """
    if which == 'module':
        script_dir = os.path.dirname(os.path.abspath(__file__))
    elif which == 'caller':
        script_dir = _caller_dir()
    elif which == 'cwd':
        script_dir = os.getcwd()
    else:
        raise ValueError("which must be 'module', 'caller' or 'cwd'")

    print(f"Rodando a partir da pasta: {script_dir}")
    print("Arquivos:")
    for f in os.listdir(script_dir):
        print(" -", f)


if __name__ == "__main__":
    debug_files()
```

## arquivo config.yaml
```yaml
# config.yaml

# Configurações Globais do Benchmark
settings:
  output_base_dir: "output"  # Diretório base relativo ao diretório de build
  epsilon_tolerance: 1.0e-4
  max_iterations: 10
  save_intermediate_images: true # true para salvar imagem a cada iteração, false para salvar só a final
  num_omp_threads: 0           # 0 para usar o máximo padrão do OpenMP, ou especifique um número

# Definição dos Conjuntos de Teste Disponíveis
datasets:
  - name: "60x60_G1"
    description: "60x60 (Sinal G-1)"
    h_matrix_csv: "data/H-1.csv"
    g_signal_csv: "data/G-1.csv"
    image_rows: 60
    image_cols: 60

  - name: "60x60_G2"
    description: "60x60 (Sinal G-2)"
    h_matrix_csv: "data/H-1.csv"
    g_signal_csv: "data/G-2.csv"
    image_rows: 60
    image_cols: 60

  - name: "30x30_g1"
    description: "30x30 (Sinal g-1)"
    h_matrix_csv: "data/H-2.csv"
    g_signal_csv: "data/g-30x30-1.csv"
    image_rows: 30
    image_cols: 30

  - name: "30x30_g2"
    description: "30x30 (Sinal g-2)"
    h_matrix_csv: "data/H-2.csv"
    g_signal_csv: "data/g-30x30-2.csv"
    image_rows: 30
    image_cols: 30

# Definição dos Métodos de Reconstrução a serem testados
methods:
  - name: "sparse_standard"
    description: "Esparso / Binario (Standard)"
    solver: "cgnr_standard" # Identificador da função solver a ser chamada
    use_binary: true
    is_baseline: true      # Marca este como referência para speedup

  - name: "sparse_jacobi"
    description: "Esparso / Binario (Jacobi)"
    solver: "cgnr_preconditioned" # Identificador da função solver
    use_binary: true
    is_baseline: false

  - name: "sparse_fista"
    description: "Esparso / Binario (FISTA)"
    solver: "fista"
    use_binary: true
    is_baseline: false

  # Adicione aqui se/quando implementar FISTA
  # - name: "sparse_fista"
  #   description: "Esparso / Binario (FISTA)"
  #   solver: "fista"
  #   use_binary: true
  #   is_baseline: false

  # Você pode reativar os testes densos/texto se quiser
  # - name: "dense_text"
  #   description: "Denso / Texto"
  #   solver: "cgnr_standard" # Usaria o mesmo solver, mas com matriz densa
  #   use_binary: false
  #   is_baseline: false
  # - name: "dense_binary"
  # ...

# Quais comparações/pipelines executar
run_pipelines:
  - name: "Sparse_Comparison"
    description: "Compara CGNR Standard, Jacobi e FISTA"
    methods: [ "sparse_standard", "sparse_jacobi", "sparse_fista" ]
    datasets: [ "30x30_g1" ] # Comece com um dataset pequeno para testar

  # Exemplo: Rodar FISTA em um dataset específico
  # - name: "FISTA_Test_Small"
  #   description: "Testa FISTA no dataset 30x30 g1"
  #   methods: ["sparse_fista"]
  #   datasets: ["30x30_g1"]
```

## arquivo convergence_history_30x30_g1_sparse_fista.csv
```csv
Iteration,ResidualNorm,SolutionNorm,ExecutionTime_ms
1,9.42069860e+00,4.77310456e-02,6567.91
2,9.17847292e+00,9.39234256e-02,6567.91
3,8.87915877e+00,1.51236560e-01,6567.91
4,8.53103579e+00,2.18218746e-01,6567.91
5,8.14225517e+00,2.93461367e-01,6567.91
6,7.72094960e+00,3.75564562e-01,6567.91
7,7.27517035e+00,4.63140880e-01,6567.91
8,6.81279416e+00,5.54831645e-01,6567.91
9,6.34140210e+00,6.49327570e-01,6567.91
10,5.86795889e+00,7.45389560e-01,6567.91
11,5.39800237e+00,8.41862552e-01,6567.91
12,4.93680954e+00,9.37679178e-01,6567.91
13,4.48922983e+00,1.03187314e+00,6567.91
14,4.06016252e+00,1.12357100e+00,6567.91
15,3.65324586e+00,1.21202718e+00,6567.91
16,3.27091301e+00,1.29660335e+00,6567.91
17,2.91129122e+00,1.37674439e+00,6567.91
18,2.57116589e+00,1.45181741e+00,6567.91
19,2.25861865e+00,1.52125660e+00,6567.91
20,1.97973575e+00,1.58471987e+00,6567.91
21,1.72900419e+00,1.64202233e+00,6567.91
22,1.50731787e+00,1.69306081e+00,6567.91
23,1.31426879e+00,1.73781447e+00,6567.91
24,1.14898195e+00,1.77633109e+00,6567.91
25,1.01095674e+00,1.80878377e+00,6567.91
26,9.02273819e-01,1.83543479e+00,6567.91
27,8.05975387e-01,1.85659725e+00,6567.91
28,7.18548011e-01,1.87246432e+00,6567.91
29,6.40088982e-01,1.88334618e+00,6567.91
30,5.78836252e-01,1.88963060e+00,6567.91
31,5.45876662e-01,1.89173370e+00,6567.91
32,5.38198023e-01,1.89014008e+00,6567.91
33,5.51469796e-01,1.88535512e+00,6567.91
34,5.84398164e-01,1.87787100e+00,6567.91
35,6.32904777e-01,1.86818192e+00,6567.91
36,6.92507182e-01,1.85677119e+00,6567.91
37,7.59093712e-01,1.84410411e+00,6567.91
38,8.29215344e-01,1.83062167e+00,6567.91
39,9.00090845e-01,1.81673511e+00,6567.91
40,9.69514885e-01,1.80282141e+00,6567.91
41,1.03575940e+00,1.78921946e+00,6567.91
42,1.09749430e+00,1.77622712e+00,6567.91
43,1.15372813e+00,1.76409900e+00,6567.91
44,1.20376290e+00,1.75304503e+00,6567.91
45,1.24715726e+00,1.74322979e+00,6567.91
46,1.28369434e+00,1.73477271e+00,6567.91
47,1.31335155e+00,1.72774909e+00,6567.91
48,1.33627155e+00,1.72219189e+00,6567.91
49,1.35273375e+00,1.71809448e+00,6567.91
50,1.36312679e+00,1.71541406e+00,6567.91
```

## arquivo convergence_history_30x30_g1_sparse_precond.csv
```csv
Iteration,ResidualNorm
1,3.11273808e+00
2,1.75927049e+00
3,1.36499486e+00
4,1.21235878e+00
5,1.15836060e+00
6,1.14049143e+00
7,1.13090605e+00
8,1.12715735e+00
9,1.12655618e+00
10,1.12604232e+00
11,1.12573830e+00
12,1.12565848e+00
13,1.12559848e+00
14,1.12553307e+00
15,1.12550771e+00
16,1.12549822e+00
17,1.12549316e+00
18,1.12549576e+00
19,1.12549598e+00
```

## arquivo convergence_history_30x30_g1_sparse_standard.csv
```csv
Iteration,ResidualNorm
1,3.14724741e+00
2,1.76451774e+00
3,1.65508967e+00
4,1.38614091e+00
5,1.32130562e+00
6,1.30580631e+00
7,1.20217879e+00
8,1.18017450e+00
9,1.17198453e+00
10,1.16368082e+00
11,1.14645899e+00
12,1.13880959e+00
13,1.13426042e+00
14,1.13166436e+00
15,1.12965037e+00
16,1.12896716e+00
17,1.12773387e+00
18,1.12688509e+00
19,1.12631127e+00
20,1.12610340e+00
21,1.12592313e+00
22,1.12577103e+00
23,1.12567318e+00
24,1.12560086e+00
25,1.12558767e+00
26,1.12554878e+00
27,1.12553891e+00
28,1.12553073e+00
29,1.12551931e+00
30,1.12550923e+00
31,1.12550320e+00
32,1.12550141e+00
33,1.12549924e+00
34,1.12549808e+00
35,1.12549791e+00
```

## arquivo lcurve_30x30_g1_sparse_fista.csv
```csv
Iteration,SolutionNorm,ResidualNorm
1,4.77310456e-02,9.42069860e+00
2,9.39234256e-02,9.17847292e+00
3,1.51236560e-01,8.87915877e+00
4,2.18218746e-01,8.53103579e+00
5,2.93461367e-01,8.14225517e+00
6,3.75564562e-01,7.72094960e+00
7,4.63140880e-01,7.27517035e+00
8,5.54831645e-01,6.81279416e+00
9,6.49327570e-01,6.34140210e+00
10,7.45389560e-01,5.86795889e+00
11,8.41862552e-01,5.39800237e+00
12,9.37679178e-01,4.93680954e+00
13,1.03187314e+00,4.48922983e+00
14,1.12357100e+00,4.06016252e+00
15,1.21202718e+00,3.65324586e+00
16,1.29660335e+00,3.27091301e+00
17,1.37674439e+00,2.91129122e+00
18,1.45181741e+00,2.57116589e+00
19,1.52125660e+00,2.25861865e+00
20,1.58471987e+00,1.97973575e+00
21,1.64202233e+00,1.72900419e+00
22,1.69306081e+00,1.50731787e+00
23,1.73781447e+00,1.31426879e+00
24,1.77633109e+00,1.14898195e+00
25,1.80878377e+00,1.01095674e+00
26,1.83543479e+00,9.02273819e-01
27,1.85659725e+00,8.05975387e-01
28,1.87246432e+00,7.18548011e-01
29,1.88334618e+00,6.40088982e-01
30,1.88963060e+00,5.78836252e-01
31,1.89173370e+00,5.45876662e-01
32,1.89014008e+00,5.38198023e-01
33,1.88535512e+00,5.51469796e-01
34,1.87787100e+00,5.84398164e-01
35,1.86818192e+00,6.32904777e-01
36,1.85677119e+00,6.92507182e-01
37,1.84410411e+00,7.59093712e-01
38,1.83062167e+00,8.29215344e-01
39,1.81673511e+00,9.00090845e-01
40,1.80282141e+00,9.69514885e-01
41,1.78921946e+00,1.03575940e+00
42,1.77622712e+00,1.09749430e+00
43,1.76409900e+00,1.15372813e+00
44,1.75304503e+00,1.20376290e+00
45,1.74322979e+00,1.24715726e+00
46,1.73477271e+00,1.28369434e+00
47,1.72774909e+00,1.31335155e+00
48,1.72219189e+00,1.33627155e+00
49,1.71809448e+00,1.35273375e+00
50,1.71541406e+00,1.36312679e+00
```

## arquivo lcurve_30x30_g1_sparse_precond.csv
```csv
Iteration,SolutionNorm,ResidualNorm
1,1.46533723e+00,3.11273808e+00
2,1.60994325e+00,1.75927049e+00
3,1.65488973e+00,1.36499486e+00
4,1.67273151e+00,1.21235878e+00
5,1.67911154e+00,1.15836060e+00
6,1.68161777e+00,1.14049143e+00
7,1.68311702e+00,1.13090605e+00
8,1.68365708e+00,1.12715735e+00
9,1.68367883e+00,1.12655618e+00
10,1.68376853e+00,1.12604232e+00
11,1.68383084e+00,1.12573830e+00
12,1.68384567e+00,1.12565848e+00
13,1.68385839e+00,1.12559848e+00
14,1.68387330e+00,1.12553307e+00
15,1.68387906e+00,1.12550771e+00
16,1.68388122e+00,1.12549822e+00
17,1.68388238e+00,1.12549316e+00
18,1.68388174e+00,1.12549576e+00
19,1.68388168e+00,1.12549598e+00
```

## arquivo lcurve_30x30_g1_sparse_standard.csv
```csv
Iteration,SolutionNorm,ResidualNorm
1,1.44309642e+00,3.14724741e+00
2,1.60734710e+00,1.76451774e+00
3,1.61916667e+00,1.65508967e+00
4,1.65026201e+00,1.38614091e+00
5,1.65794237e+00,1.32130562e+00
6,1.65980422e+00,1.30580631e+00
7,1.67298446e+00,1.20217879e+00
8,1.67590906e+00,1.18017450e+00
9,1.67701813e+00,1.17198453e+00
10,1.67816156e+00,1.16368082e+00
11,1.68061484e+00,1.14645899e+00
12,1.68174315e+00,1.13880959e+00
13,1.68243522e+00,1.13426042e+00
14,1.68284142e+00,1.13166436e+00
15,1.68316484e+00,1.12965037e+00
16,1.68327688e+00,1.12896716e+00
17,1.68348347e+00,1.12773387e+00
18,1.68362948e+00,1.12688509e+00
19,1.68373070e+00,1.12631127e+00
20,1.68376803e+00,1.12610340e+00
21,1.68380082e+00,1.12592313e+00
22,1.68382892e+00,1.12577103e+00
23,1.68384727e+00,1.12567318e+00
24,1.68386105e+00,1.12560086e+00
25,1.68386359e+00,1.12558767e+00
26,1.68387113e+00,1.12554878e+00
27,1.68387307e+00,1.12553891e+00
28,1.68387467e+00,1.12553073e+00
29,1.68387693e+00,1.12551931e+00
30,1.68387895e+00,1.12550923e+00
31,1.68388016e+00,1.12550320e+00
32,1.68388053e+00,1.12550141e+00
33,1.68388097e+00,1.12549924e+00
34,1.68388121e+00,1.12549808e+00
35,1.68388125e+00,1.12549791e+00
```

