# Documentação do Projeto: dis

**Gerado em:** 13/12/2025 às 04:12:41  
**Total de arquivos:** 72  
**Tamanho total:** 246.7KB  
**Extensões incluídas:** txt, cpp, hpp, py, yaml, csv, sh

## Distribuição por tipo de arquivo

- **TXT**: 1 arquivo(s) - 3.5KB
- **CPP**: 7 arquivo(s) - 89.5KB
- **HPP**: 8 arquivo(s) - 45.2KB
- **PY**: 4 arquivo(s) - 11.1KB
- **YAML**: 1 arquivo(s) - 2.2KB
- **CSV**: 50 arquivo(s) - 93.7KB
- **SH**: 1 arquivo(s) - 1.4KB

---

# Estrutura do projeto:
```text
dis/
|-- data
|   |-- H-large.csv (37B)
|   +-- H-parse.csv (5B)
|-- include
|   |-- benchmark_runner.hpp (693B)
|   |-- config.hpp (2.4KB)
|   |-- io_utils.hpp (1.9KB)
|   |-- reporting.hpp (652B)
|   |-- solvers.hpp (4.5KB)
|   |-- types.hpp (3.1KB)
|   +-- utils.hpp (932B)
|-- output_csv
|   |-- convergence_history_30x30_g1_sparse_precond.csv (2.2KB)
|   |-- convergence_history_30x30_g1_sparse_standard.csv (2.2KB)
|   |-- convergence_history_30x30_g2_sparse_precond.csv (2.2KB)
|   |-- convergence_history_30x30_g2_sparse_standard.csv (2.2KB)
|   |-- convergence_history_60x60_G1_sparse_precond.csv (2.2KB)
|   |-- convergence_history_60x60_G1_sparse_standard.csv (2.2KB)
|   |-- convergence_history_60x60_G2_sparse_precond.csv (2.2KB)
|   |-- convergence_history_60x60_G2_sparse_standard.csv (2.2KB)
|   |-- lcurve_30x30_g1_sparse_precond.csv (1.7KB)
|   |-- lcurve_30x30_g1_sparse_standard.csv (1.7KB)
|   |-- lcurve_30x30_g2_sparse_precond.csv (1.7KB)
|   |-- lcurve_30x30_g2_sparse_standard.csv (1.7KB)
|   |-- lcurve_60x60_G1_sparse_precond.csv (1.7KB)
|   |-- lcurve_60x60_G1_sparse_standard.csv (1.7KB)
|   |-- lcurve_60x60_G2_sparse_precond.csv (1.7KB)
|   +-- lcurve_60x60_G2_sparse_standard.csv (1.7KB)
|-- output_runs
|   |-- 13_12_2025_04_07_tol_0.0001_ite_10_omp_8
|   |   |-- convergence_history_30x30_g1_sparse_precond.csv (2.2KB)
|   |   |-- convergence_history_30x30_g1_sparse_standard.csv (2.2KB)
|   |   |-- convergence_history_30x30_g2_sparse_precond.csv (2.2KB)
|   |   |-- convergence_history_30x30_g2_sparse_standard.csv (2.2KB)
|   |   |-- convergence_history_60x60_G1_sparse_precond.csv (2.2KB)
|   |   |-- convergence_history_60x60_G1_sparse_standard.csv (2.2KB)
|   |   |-- convergence_history_60x60_G2_sparse_precond.csv (2.2KB)
|   |   |-- convergence_history_60x60_G2_sparse_standard.csv (2.2KB)
|   |   |-- lcurve_30x30_g1_sparse_precond.csv (1.7KB)
|   |   |-- lcurve_30x30_g1_sparse_standard.csv (1.7KB)
|   |   |-- lcurve_30x30_g2_sparse_precond.csv (1.7KB)
|   |   |-- lcurve_30x30_g2_sparse_standard.csv (1.7KB)
|   |   |-- lcurve_60x60_G1_sparse_precond.csv (1.7KB)
|   |   |-- lcurve_60x60_G1_sparse_standard.csv (1.7KB)
|   |   |-- lcurve_60x60_G2_sparse_precond.csv (1.7KB)
|   |   +-- lcurve_60x60_G2_sparse_standard.csv (1.7KB)
|   +-- 13_12_2025_04_10_tol_0.0001_ite_10_omp_8
|       |-- convergence_history_30x30_g1_sparse_precond.csv (2.2KB)
|       |-- convergence_history_30x30_g1_sparse_standard.csv (2.2KB)
|       |-- convergence_history_30x30_g2_sparse_precond.csv (2.2KB)
|       |-- convergence_history_30x30_g2_sparse_standard.csv (2.2KB)
|       |-- convergence_history_60x60_G1_sparse_precond.csv (2.2KB)
|       |-- convergence_history_60x60_G1_sparse_standard.csv (2.2KB)
|       |-- convergence_history_60x60_G2_sparse_precond.csv (2.2KB)
|       |-- convergence_history_60x60_G2_sparse_standard.csv (2.2KB)
|       |-- lcurve_30x30_g1_sparse_precond.csv (1.7KB)
|       |-- lcurve_30x30_g1_sparse_standard.csv (1.7KB)
|       |-- lcurve_30x30_g2_sparse_precond.csv (1.7KB)
|       |-- lcurve_30x30_g2_sparse_standard.csv (1.7KB)
|       |-- lcurve_60x60_G1_sparse_precond.csv (1.7KB)
|       |-- lcurve_60x60_G1_sparse_standard.csv (1.7KB)
|       |-- lcurve_60x60_G2_sparse_precond.csv (1.7KB)
|       +-- lcurve_60x60_G2_sparse_standard.csv (1.7KB)
|-- scripts
|   |-- combine_animations.py (3.1KB)
|   |-- plot_convergence.py (3.0KB)
|   +-- visualize_iterations.py (3.8KB)
|-- src
|   |-- benchmark_runner.cpp (17.1KB)
|   |-- config.cpp (4.6KB)
|   |-- io_utils.cpp (18.6KB)
|   |-- reporting.cpp (7.8KB)
|   |-- solvers.cpp (23.0KB)
|   +-- utils.cpp (6.1KB)
|-- CMakeLists.txt (3.5KB)
|-- config.yaml (2.2KB)
|-- debug.py (1.2KB)
|-- main.cpp (12.3KB)
|-- run_and_log.sh (1.4KB)
+-- solver_comparison.hpp (31.2KB)
```

---

# Código dos Arquivos

## arquivo CMakeLists.txt
```text
# The MiniCppStarter for Ultrasound Reconstruction
#
# Build and run by calling:
# cmake -S. -B build && cmake --build build && ./build/Playground

cmake_minimum_required(VERSION 3.23)
cmake_policy(VERSION 3.23)

# Garante compatibilidade com pacotes antigos que pedem < 3.5
set(CMAKE_POLICY_VERSION_MINIMUM 3.5)

# Ativar log de comandos de compilação cmake
set(CMAKE_VERBOSE_MAKEFILE OFF)

set(CMAKE_SUPPRESS_DEVELOPER_WARNINGS TRUE CACHE BOOL "Suprimir avisos de desenvolvedor")

# ---- Project ----

project(UltrasoundServer LANGUAGES CXX)

# ---- Fetch CPM ----
# (Esta parte baixa o gerenciador de pacotes CPM, mantemos como está)
file(
        DOWNLOAD
        https://github.com/cpm-cmake/CPM.cmake/releases/download/v0.39.0/CPM.cmake
        ${CMAKE_CURRENT_BINARY_DIR}/cmake/CPM.cmake
        EXPECTED_HASH SHA256=66639BCAC9DD2907B2918DE466783554C1334446B9874E90D38E3778D404C2EF
)
include(${CMAKE_CURRENT_BINARY_DIR}/cmake/CPM.cmake)

# ---- Add dependencies via CPM ----

# MUDANÇA: Usando o repositório oficial do GitLab e a versão 5.0.0.
# O CPM fará o download do código-fonte. Como Eigen é "header-only",
# não há etapa de compilação para a própria biblioteca.
CPMAddPackage(
        NAME Eigen3
        VERSION 5.0.0
        GIT_REPOSITORY "https://gitlab.com/libeigen/eigen.git"
        GIT_TAG "5.0.0"
)

# yaml-cpp
CPMAddPackage(
        NAME yaml-cpp
        GIT_REPOSITORY "https://github.com/jbeder/yaml-cpp.git"
        GIT_TAG "0.8.0"
        OPTIONS
        "YAML_CPP_BUILD_TESTS OFF"
        "YAML_CPP_BUILD_TOOLS OFF"
)

# OpenMP
find_package(OpenMP REQUIRED)

# --- NOVO BLOCO 1: Encontrar o Python ---
# Adicionado para podermos chamar o script de documentação
find_package(Python3 REQUIRED)

# ---- Create executable ----
add_executable(UltrasoundBenchmark
        main.cpp
        src/config.cpp
        src/io_utils.cpp
        src/solvers.cpp
        src/utils.cpp
        src/benchmark_runner.cpp
        src/reporting.cpp
)

# ---- Link Libraries ----
target_link_libraries(UltrasoundBenchmark PRIVATE
        Eigen3::Eigen       # Eigen
        yaml-cpp::yaml-cpp  # yaml-cpp
        OpenMP::OpenMP_CXX  # OpenMP
)

# Necessário para std::filesystem no GCC < 9
if (CMAKE_CXX_COMPILER_ID STREQUAL "GNU" AND CMAKE_CXX_COMPILER_VERSION VERSION_LESS 9.0)
    target_link_libraries(UltrasoundBenchmark PRIVATE -lstdc++fs)
endif ()
if (CMAKE_CXX_COMPILER_ID STREQUAL "Clang" AND CMAKE_CXX_COMPILER_VERSION VERSION_LESS 7.0)
    target_link_libraries(UltrasoundBenchmark PRIVATE -lc++fs)
endif ()


# --- NOVO BLOCO 2: Comando Pós-Compilação ---
# Executa o script documentar.py toda vez que o 'UltrasoundBenchmark'
# for compilado com sucesso.
add_custom_command(
        TARGET UltrasoundBenchmark
        POST_BUILD  # Executa APÓS a compilação
        COMMAND
        # O comando que será executado no terminal
        ${Python3_EXECUTABLE} ${CMAKE_CURRENT_SOURCE_DIR}/documentar.py
        WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}
        COMMENT "Gerando documentação do projeto via documentar.py..."
)


# ---- Target Properties ----
set_target_properties(UltrasoundBenchmark PROPERTIES CXX_STANDARD 23) # Já definido globalmente

# Opcional: Otimizações de compilação para Release
target_compile_options(UltrasoundBenchmark PRIVATE $<$<CONFIG:Release>:-O3 -DNDEBUG>)
# Opcional: Flags de debug
target_compile_options(UltrasoundBenchmark PRIVATE $<$<CONFIG:Debug>:-g>)
```

## arquivo main.cpp
```cpp
#include <algorithm> // Para std::replace
#include <chrono> // Para timing (embora a maior parte esteja no header agora)
#include <filesystem> // Para manipulação de caminhos (C++17)
#include <iomanip>    // Para formatação da tabela
#include <iostream>
#include <omp.h>     // Para OpenMP info
#include <sstream>   // Para formatar speedup
#include <stdexcept> // Para std::runtime_error
#include <string>
#include <vector>

// Inclui o header com a lógica de comparação e funções auxiliares/solvers
#include "include/config.hpp"
#include "include/types.hpp"
#include "solver_comparison.hpp"

// Removida a função create_output_directories daqui pois já existe em
// solver_comparison.hpp

// --- Função Principal (SIMPLIFICADA) ---
int main(int argc, char *argv[]) {
  std::cout << "======================================================"
            << std::endl;
  std::cout << " Comparativo: CGNR Standard vs Pre-condicionado" << std::endl;
  std::cout << "======================================================"
            << std::endl;

  // --- Config Loading Logic ---
  std::string config_file_path = "config.yaml"; // Default
  std::string cmd_output_dir = "";
  if (argc > 2) {
    cmd_output_dir = argv[2];
  }

  // 1. Check if user provided a path via command line
  if (argc > 1) {
    config_file_path = argv[1];
  } else {
    // 2. Try to find config.yaml relative to executable or current path
    std::filesystem::path exe_path(argv[0]);
    std::filesystem::path search_paths[] = {
        std::filesystem::current_path() / "config.yaml",
        exe_path.parent_path() / "config.yaml",
        exe_path.parent_path().parent_path() / "config.yaml",
        exe_path.parent_path().parent_path().parent_path() / "config.yaml"};

    bool found = false;
    for (const auto &p : search_paths) {
      if (std::filesystem::exists(p)) {
        config_file_path = p.string();
        found = true;
        break;
      }
    }

    if (!found) {
      std::cout << "[AVISO] config.yaml nao encontrado nos caminhos padrao. "
                   "Tentando 'config.yaml' no diretorio atual."
                << std::endl;
    }
  }

  std::cout << "[INFO] Tentando carregar configuracao de: " << config_file_path
            << std::endl;

  std::filesystem::path config_path(config_file_path);
  Config config;
  try {
    config = load_config(config_file_path);
  } catch (const std::exception &e) {
    std::cerr << "[ERRO FATAL] Erro ao carregar configuracao: " << e.what()
              << std::endl;
    return 1;
  }

  if (config.run_pipelines.empty()) {
    std::cerr << "[ERRO] Nenhum pipeline definido no arquivo de configuração."
              << std::endl;
    return 1;
  }

  // Pega apenas o primeiro pipeline (Sparse_Comparison)
  const auto &pipeline = config.run_pipelines[0];

  // Prepara o vetor de testes baseado no pipeline
  std::cout << "\n[INFO] Pipeline selecionado: " << pipeline.name << std::endl;
  std::cout << "[INFO] Datasets configurados: ";
  for (const auto &name : pipeline.dataset_names) {
    std::cout << name << " ";
  }
  std::cout << std::endl;

  std::vector<DatasetConfig> tests;
  for (const auto &dataset_name : pipeline.dataset_names) {
    std::cout << "[INFO] Processando dataset: " << dataset_name << std::endl;
    auto it = config.dataset_map.find(dataset_name);
    if (it != config.dataset_map.end()) {
      DatasetConfig dataset_config = *it->second; // Make a copy to modify paths
      std::filesystem::path config_dir = config_path.parent_path();
      dataset_config.h_matrix_csv =
          (config_dir / dataset_config.h_matrix_csv).string();
      dataset_config.g_signal_csv =
          (config_dir / dataset_config.g_signal_csv).string();
      tests.push_back(dataset_config);
      std::cout << "[INFO] Dataset " << dataset_name
                << " adicionado para processamento" << std::endl;
    } else {
      std::cout << "[AVISO] Dataset " << dataset_name
                << " não encontrado no mapa de configurações" << std::endl;
    }
  }

  std::cout << "[INFO] Total de datasets a serem processados: " << tests.size()
            << std::endl;

  // Configuração OpenMP
  Eigen::setNbThreads(omp_get_max_threads());
  std::cout << "\n[INFO] Usando " << Eigen::nbThreads()
            << " threads para os calculos Eigen.\n"
            << std::endl;

  // --- Pré-processamento (Apenas garante que o .sparse.bin existe) ---
  std::cout << "[INFO] Verificando/Criando arquivos binarios esparsos..."
            << std::endl;
  for (const auto &config : tests) {
    std::filesystem::path h_path =
        config.h_matrix_csv; // Correção aqui: usa h_matrix_csv
    if (!std::filesystem::exists(h_path)) {
      std::cerr << "[ERRO] Arquivo CSV da matriz H nao encontrado: "
                << config.h_matrix_csv << std::endl;
      return 1;
    }
    std::filesystem::path data_dir = h_path.parent_path();
    std::filesystem::path sparse_bin_fs_path =
        data_dir / (h_path.filename().string() + ".sparse.bin");
    std::string sparse_bin_path = sparse_bin_fs_path.string();

    if (!std::filesystem::exists(sparse_bin_fs_path)) {
      std::cout << "[AVISO] Criando arquivo binario esparso para "
                << config.h_matrix_csv << " em " << sparse_bin_path << "..."
                << std::endl;
      try {
        saveSparseMatrix(
            convertCsvToSparse(config.h_matrix_csv,
                               config.image_rows * config.image_cols),
            sparse_bin_path);
        std::cout << "[SUCESSO] Arquivo binario esparso criado: "
                  << sparse_bin_path << std::endl;
      } catch (const std::exception &e) {
        std::cerr << "[ERRO] Falha ao criar arquivo binario esparso: "
                  << e.what() << std::endl;
        return 1;
      }
    }
  }
  std::cout << "[INFO] Pre-processamento concluido.\n" << std::endl;

  // Padronizar o caminho de saída para corresponder ao que o Python espera
  std::filesystem::path output_dir;
  if (!cmd_output_dir.empty()) {
    output_dir = cmd_output_dir;
    config.settings.output_base_dir =
        cmd_output_dir; // Update settings used by solvers
  } else {
    output_dir = config.settings.output_base_dir;
  }
  try {
    create_output_directories(
        output_dir); // Usa a função do solver_comparison.hpp
    std::cout << "[INFO] Estrutura de diretorios criada: "
              << std::filesystem::absolute(output_dir) << std::endl;
  } catch (const std::exception &e) {
    std::cerr << "[ERRO] Nao foi possivel criar os diretorios de saida: "
              << e.what() << std::endl;
    return 1;
  }

  // --- Loop Principal de Testes ---
  std::vector<std::tuple<std::string, PerformanceMetrics, PerformanceMetrics>>
      all_results;

  // Verificação adicional para garantir que estamos processando apenas os
  // datasets selecionados
  std::cout << "\n[INFO] Verificando datasets a serem processados:"
            << std::endl;
  for (const auto &test_config : tests) {
    std::cout << "  - Dataset: " << test_config.name << " ("
              << test_config.description << ")" << std::endl;
    bool is_in_pipeline =
        std::find(pipeline.dataset_names.begin(), pipeline.dataset_names.end(),
                  test_config.name) != pipeline.dataset_names.end();
    if (!is_in_pipeline) {
      std::cout << "[AVISO] Dataset " << test_config.name
                << " não está no pipeline atual. Ignorando." << std::endl;
      continue;
    }

    std::cout << "\n========================================\nINICIANDO TESTE: "
              << test_config.description <<
        // Usa .description
        "\n========================================" << std::endl;

    try {
      auto [std_metrics, precond_metrics] =
          run_sparse_comparison(test_config, config.settings);
      all_results.push_back(std::make_tuple(test_config.description,
                                            std_metrics, precond_metrics));
      std::cout << "Teste " << test_config.description
                << " concluido com sucesso." << std::endl;
    } catch (const std::exception &e) {
      std::cerr << "[ERRO FATAL] Falha ao executar comparacao para o teste "
                << test_config.description << ": " << e.what() << std::endl;
    }
  }

  // --- Tabela Final de Resultados ---
  std::cout << "\n\n==========================================================="
               "==============================================================="
               "============================"
            << std::endl;
  std::cout << "                                                    RELATORIO "
               "COMPARATIVO FINAL"
            << std::endl;
  std::cout << "==============================================================="
               "==============================================================="
               "========================"
            << std::endl;
  std::cout << std::left << std::setw(22) << "Teste" << std::setw(28)
            << "Metodo" << std::setw(15) << "RAM (MB)" << std::setw(20)
            << "T. Carga (ms)" << std::setw(20) << "T. Solver (ms)"
            << std::setw(12) << "Iteracoes" << std::setw(15) << "Erro Final"
            << std::setw(15) << "Epsilon Final" << std::setw(15) << "Convergiu"
            << std::setw(15) << "Speedup" << std::endl;
  std::cout << "---------------------------------------------------------------"
               "---------------------------------------------------------------"
               "------------------------"
            << std::endl;

  for (const auto &[test_name, std_metrics, precond_metrics] : all_results) {
    auto print_metric = [&](const PerformanceMetrics &m,
                            const std::string &method_name, bool is_baseline) {
      if (m.load_time_ms <= 0 && m.solve_time_ms <= 0) {
        std::cout << std::left << std::setw(22)
                  << (is_baseline ? test_name : "") << std::setw(28)
                  << method_name << std::setw(15 + 20 + 20 + 12 + 15 + 15 + 15)
                  << " [FALHOU]" << std::setw(14) << std::right
                  << (is_baseline ? "BASELINE" : "N/A") << std::endl;
        return;
      }

      std::cout << std::left << std::setw(22) << (is_baseline ? test_name : "")
                << std::setw(28) << method_name << std::fixed
                << std::setprecision(2) << std::setw(15) << m.estimated_ram_mb
                << std::fixed << std::setprecision(2) << std::setw(20)
                << m.load_time_ms << std::fixed << std::setprecision(2)
                << std::setw(20) << m.solve_time_ms << std::setw(12)
                << m.iterations << std::scientific << std::setprecision(3)
                << std::setw(14) << m.final_error << std::scientific
                << std::setprecision(3) << std::setw(14) << m.final_epsilon
                << std::setw(15) << (m.converged ? "Sim" : "Nao (MaxIt)");

      if (is_baseline) {
        std::cout << std::setw(14) << std::right << "BASELINE";
      } else if (std_metrics.solve_time_ms > 0 && m.solve_time_ms > 0) {
        const double speedup = std_metrics.solve_time_ms / m.solve_time_ms;
        std::stringstream ss;
        ss << std::fixed << std::setprecision(2) << speedup << "x";
        std::cout << std::setw(14) << std::right << ss.str();
      } else {
        std::cout << std::setw(14) << std::right << "N/A";
      }
      std::cout << std::endl;
    };

    print_metric(std_metrics, "CGNR Standard", true);
    print_metric(precond_metrics, "CGNR Pre-condicionado", false);

    std::cout << "-------------------------------------------------------------"
                 "-------------------------------------------------------------"
                 "----------------------------"
              << std::endl;
  }

  std::cout << "\nBenchmark concluido." << std::endl;
  std::cout << "[INFO] Para visualizar os graficos de convergencia, execute:"
            << std::endl;
  std::cout << "[INFO] python scripts/plot_convergence.py ../output_csv/metrics"
            << std::endl;
  std::cout
      << "[INFO] Para gerar animacoes da reconstrucao das imagens, execute:"
      << std::endl;
  std::cout
      << "[INFO] python scripts/visualize_iterations.py ../output_csv/images"
      << std::endl;
  return 0;
}
```

## arquivo benchmark_runner.cpp
```cpp
#include "../include/benchmark_runner.hpp" // Inclui a declaração da função principal do benchmark
#include "../include/types.hpp"           // Inclui as definições das structs (Resultados, Métricas, etc.)
#include "../include/config.hpp"          // Inclui a definição da classe Config
#include "../include/io_utils.hpp"        // Inclui as declarações das funções de I/O (load*, save*)
#include "../include/solvers.hpp"         // Inclui as declarações dos solvers (CGNR, Precondicionado, Fixo)
#include "../include/utils.hpp"           // Inclui a declaração da função de normalização

#include <iostream>                      // Para std::cout, std::cerr
#include <string>                        // Para std::string
#include <vector>                        // Para std::vector
#include <map>                           // Para std::map (armazenar resultados)
#include <chrono>                        // Para medição de tempo (high_resolution_clock)
#include <filesystem>                    // Para manipulação de caminhos (C++17)
#include <stdexcept>                     // Para std::runtime_error
#include <Eigen/Sparse>                  // Para Eigen::SparseMatrix
#include <Eigen/Dense>                   // Para Eigen::MatrixXd (caso reative testes densos)
#include <algorithm>                     // Para std::replace

// --- Implementação da Função Principal do Benchmark ---

BenchmarkResults run_benchmarks(const Config& config) {
    BenchmarkResults benchmark_results; // Estrutura para guardar todos os resultados
    const GlobalSettings& settings = config.settings; // Atalho para configurações globais

    std::cout << "\n======================================================" << std::endl;
    std::cout << "               INICIANDO BENCHMARKS" << std::endl;
    std::cout << "======================================================" << std::endl;

    // Garante que o diretório base de saída exista e cria subdiretório para CSVs
    std::filesystem::path base_output_dir = settings.output_base_dir;
    std::filesystem::path results_csv_dir = base_output_dir / "results_csv";
    try {
        std::filesystem::create_directories(results_csv_dir); // Cria o subdiretório para CSVs
        std::cout << "[INFO] Diretorio de saida CSV verificado/criado: " << std::filesystem::absolute(results_csv_dir) << std::endl;
    } catch (const std::filesystem::filesystem_error& e) {
        // Lança um erro se não conseguir criar o diretório essencial
        throw std::runtime_error("Nao foi possivel criar o diretorio de saida CSV: " + results_csv_dir.string() + " - " + e.what());
    }
    // Poderia criar subpastas para logs e PNGs aqui também, se necessário, de forma similar

    // Itera sobre cada pipeline definido no config.yaml
    for (const auto& pipeline : config.run_pipelines) {
        std::cout << "\n--- Iniciando Pipeline: " << pipeline.name << " (" << pipeline.description << ") ---" << std::endl;

        // Itera sobre cada dataset neste pipeline
        for (const std::string& dataset_name : pipeline.dataset_names) {
            // Encontra a configuração do dataset pelo nome
            auto ds_it = config.dataset_map.find(dataset_name);
            if (ds_it == config.dataset_map.end()) {
                std::cerr << "[AVISO] Dataset '" << dataset_name << "' definido no pipeline '" << pipeline.name << "' nao encontrado na lista de datasets. Pulando." << std::endl;
                continue;
            }
            const DatasetConfig& current_dataset = *ds_it->second;

            std::cout << "\n  -- Processando Dataset: " << current_dataset.description << " --" << std::endl;

            // Garante que a entrada no mapa de resultados para este dataset exista
            benchmark_results.results[current_dataset.name];

            // Itera sobre cada método neste pipeline
            for (const std::string& method_name : pipeline.method_names) {
                // Encontra a configuração do método pelo nome
                auto m_it = config.method_map.find(method_name);
                if (m_it == config.method_map.end()) {
                    std::cerr << "[AVISO] Metodo '" << method_name << "' definido no pipeline '" << pipeline.name << "' nao encontrado na lista de metodos. Pulando." << std::endl;
                    continue;
                }
                const MethodConfig& current_method = *m_it->second;

                std::cout << "\n    - Aplicando Metodo: " << current_method.description << " -" << std::endl;

                // --- Variáveis para esta execução específica ---
                PerformanceMetrics current_metrics;
                ReconstructionResult solver_result;
                // **** CORREÇÃO: Declarações movidas para dentro do loop ****
                std::chrono::high_resolution_clock::time_point load_start, load_end;
                double load_time_ms = 0;
                // **** FIM DA CORREÇÃO ****
                double ram_mb = 0;

                try {
                    // --- Carregamento dos Dados ---
                    // **** CORREÇÃO: Usa h_csv_path consistentemente ****
                    std::filesystem::path h_csv_path = current_dataset.h_matrix_csv;
                    std::filesystem::path data_dir = h_csv_path.parent_path();
                    // **** FIM DA CORREÇÃO ****
                    std::filesystem::path h_load_path; // Caminho final (CSV ou BIN) a ser carregado

                    bool is_sparse = (current_method.solver.find("cgnr") != std::string::npos);

                    if (current_method.use_binary) {
                        std::string bin_suffix = is_sparse ? ".sparse.bin" : ".dense.bin";
                        h_load_path = data_dir / (h_csv_path.filename().string() + bin_suffix); // Usa h_csv_path
                        if (!std::filesystem::exists(h_load_path)) {
                            throw std::runtime_error("Arquivo binario necessario '" + h_load_path.string() + "' nao encontrado (execute o pre-processamento).");
                        }
                         std::cout << "[INFO] Carregando H de: " << h_load_path.string() << std::endl;
                    } else {
                        h_load_path = h_csv_path; // Usa h_csv_path
                         if (!std::filesystem::exists(h_load_path)) {
                             throw std::runtime_error("Arquivo CSV necessario '" + h_load_path.string() + "' nao encontrado.");
                         }
                         std::cout << "[INFO] Carregando H de: " << h_load_path.string() << std::endl;
                    }

                    // Inicia a contagem do tempo de carregamento
                    load_start = std::chrono::high_resolution_clock::now();
                    // **** CORREÇÃO: g_signal_path -> g_signal_csv ****
                    Eigen::VectorXd g = loadVectorData(current_dataset.g_signal_csv);
                    // **** FIM DA CORREÇÃO ****

                    // Carrega H esparso ou denso
                    if (is_sparse) {
                        Eigen::SparseMatrix<double> H_sparse;
                        if (current_method.use_binary) {
                            H_sparse = loadSparseMatrix(h_load_path.string());
                        } else {
                             std::cout << "[INFO] Convertendo CSV esparso para memoria..." << std::endl;
                            H_sparse = convertCsvToSparse(h_load_path.string(), current_dataset.image_rows * current_dataset.image_cols);
                        }
                        // Finaliza a contagem do tempo de carregamento
                        load_end = std::chrono::high_resolution_clock::now();
                        // Calcula RAM estimada
                        ram_mb = static_cast<double>(H_sparse.nonZeros() * (sizeof(double) + sizeof(int)) + (H_sparse.outerSize() + 1) * sizeof(int)) / (1024.0 * 1024.0);

                        // Normalização
                        normalize_system_rows(H_sparse, g);

                        // Debug z0
                        Eigen::VectorXd z0 = H_sparse.transpose() * g;
                        std::cout << "[DEBUG " << current_method.name << "] Norma de z0 (H^T * g norm): " << z0.norm() << std::endl;

                        // Seleciona e Chama o Solver Esparso
                        std::string filename_prefix = "image_" + current_dataset.name + "_" + current_method.name;

                        if (current_method.solver == "cgnr_standard") {
                            std::cout << "[INFO] Chamando solver: cgnr_standard..." << std::endl;
                            solver_result = run_cgnr_solver_epsilon_save_iters(g, H_sparse, settings.epsilon_tolerance, settings.max_iterations,
                                (settings.save_intermediate_images ? filename_prefix : ""), results_csv_dir, current_dataset.image_rows, current_dataset.image_cols);
                        } else if (current_method.solver == "cgnr_preconditioned") {
                             std::cout << "[INFO] Chamando solver: cgnr_preconditioned..." << std::endl;
                             solver_result = run_cgnr_solver_preconditioned_save_iters(g, H_sparse, settings.epsilon_tolerance, settings.max_iterations,
                                (settings.save_intermediate_images ? filename_prefix : ""), results_csv_dir, current_dataset.image_rows, current_dataset.image_cols);
                        }
                        // else if (current_method.solver == "fista") { ... }
                        else {
                            throw std::runtime_error("Solver esparso desconhecido ou nao implementado: " + current_method.solver);
                        }

                         // Gerar CSVs de histórico/L-curve
                         Eigen::SparseMatrix<double> H_fixed;
                         if (current_method.use_binary) H_fixed = loadSparseMatrix(h_load_path.string());
                         else H_fixed = convertCsvToSparse(h_load_path.string(), current_dataset.image_rows * current_dataset.image_cols);
                         // **** CORREÇÃO: g_signal_path -> g_signal_csv ****
                         Eigen::VectorXd g_fixed = loadVectorData(current_dataset.g_signal_csv);
                         // **** FIM DA CORREÇÃO ****
                         normalize_system_rows(H_fixed, g_fixed);
                         ReconstructionResult res_fixed = run_cgnr_solver_fixed_iter(g_fixed, H_fixed, settings.max_iterations);
                         std::filesystem::path hist_path = results_csv_dir / ("convergence_history_" + current_dataset.name + "_" + current_method.name + ".csv");
                         std::filesystem::path lcurve_path = results_csv_dir / ("lcurve_" + current_dataset.name + "_" + current_method.name + ".csv");
                         saveHistoryToCSV(res_fixed.residual_history, hist_path.string());
                         saveLcurveToCSV(res_fixed, lcurve_path.string());

                    } else { // Carrega Denso
                        Eigen::MatrixXd H_dense;
                        if (current_method.use_binary) {
                            H_dense = loadDenseMatrix(h_load_path.string());
                        } else {
                            std::cout << "[INFO] Convertendo CSV denso para memoria..." << std::endl;
                            H_dense = loadDenseData(h_load_path.string());
                        }
                        load_end = std::chrono::high_resolution_clock::now();
                        ram_mb = static_cast<double>(H_dense.rows()) * H_dense.cols() * sizeof(double) / (1024.0 * 1024.0);

                        normalize_system_rows(H_dense, g);
                        Eigen::VectorXd z0 = H_dense.transpose() * g;
                        std::cout << "[DEBUG " << current_method.name << "] Norma de z0 (H^T * g norm): " << z0.norm() << std::endl;

                        std::string filename_prefix = "image_" + current_dataset.name + "_" + current_method.name;
                        if (current_method.solver == "cgnr_standard") {
                             std::cout << "[INFO] Chamando solver: cgnr_standard (Denso)..." << std::endl;
                             solver_result = run_cgnr_solver_epsilon_save_iters(g, H_dense, settings.epsilon_tolerance, settings.max_iterations,
                                (settings.save_intermediate_images ? filename_prefix : ""), results_csv_dir, current_dataset.image_rows, current_dataset.image_cols);
                        }
                        else {
                             throw std::runtime_error("Solver denso desconhecido ou nao suportado: " + current_method.solver);
                        }

                         // Gerar CSVs de histórico/L-curve
                         Eigen::MatrixXd H_fixed;
                         if (current_method.use_binary) H_fixed = loadDenseMatrix(h_load_path.string());
                         else H_fixed = loadDenseData(h_load_path.string());
                         // **** CORREÇÃO: g_signal_path -> g_signal_csv ****
                         Eigen::VectorXd g_fixed = loadVectorData(current_dataset.g_signal_csv);
                         // **** FIM DA CORREÇÃO ****
                         normalize_system_rows(H_fixed, g_fixed);
                         ReconstructionResult res_fixed = run_cgnr_solver_fixed_iter(g_fixed, H_fixed, settings.max_iterations);
                         std::filesystem::path hist_path = results_csv_dir / ("convergence_history_" + current_dataset.name + "_" + current_method.name + ".csv");
                         std::filesystem::path lcurve_path = results_csv_dir / ("lcurve_" + current_dataset.name + "_" + current_method.name + ".csv");
                         saveHistoryToCSV(res_fixed.residual_history, hist_path.string());
                         saveLcurveToCSV(res_fixed, lcurve_path.string());
                    }

                    // --- Coleta Métricas ---
                    // **** CORREÇÃO: Linha que dava erro de 'start_load' ****
                    load_time_ms = std::chrono::duration<double, std::milli>(load_end - load_start).count();
                    // **** FIM DA CORREÇÃO ****
                    current_metrics.load_time_ms = load_time_ms;
                    current_metrics.estimated_ram_mb = ram_mb;
                    current_metrics.solve_time_ms = solver_result.execution_time_ms;
                    current_metrics.iterations = solver_result.iterations;
                    current_metrics.final_error = solver_result.final_error;
                    current_metrics.final_epsilon = solver_result.final_epsilon;
                    current_metrics.converged = solver_result.converged;
                    current_metrics.optimization_type = current_method.solver; // Guarda qual solver foi usado


                    // Salva a imagem final (se não salvou intermediárias)
                    if (!settings.save_intermediate_images && solver_result.image.size() > 0) {
                         std::string final_img_filename = "image_" + current_dataset.name + "_" + current_method.name + "_final.csv";
                         std::filesystem::path final_img_path = results_csv_dir / final_img_filename;
                         try {
                              saveImageVectorToCsv(solver_result.image, final_img_path.string(), current_dataset.image_rows, current_dataset.image_cols);
                         } catch (const std::exception& e) {
                             std::cerr << "[AVISO] Falha ao salvar imagem final: " << e.what() << std::endl;
                         }
                    }


                } catch (const std::exception& e) {
                    std::cerr << "[ERRO] Falha ao processar Metodo '" << current_method.name << "' no Dataset '" << current_dataset.name << "': " << e.what() << std::endl;
                    current_metrics = PerformanceMetrics(); // Zera métricas
                    current_metrics.optimization_type = current_method.solver; // Atribui tipo mesmo em erro
                }

                // Armazena as métricas no mapa de resultados
                benchmark_results.results[current_dataset.name][current_method.name] = current_metrics;

                 if (current_method.is_baseline && benchmark_results.baseline_method == nullptr) {
                    benchmark_results.baseline_method = &current_method;
                 }

                std::cout << "    - Metodo '" << current_method.name << "' concluido." << std::endl;

            } // Fim loop methods
             std::cout << "  -- Dataset '" << current_dataset.name << "' concluido. --" << std::endl;
        } // Fim loop datasets
         std::cout << "--- Pipeline '" << pipeline.name << "' concluido. ---" << std::endl;
    } // Fim loop pipelines

    std::cout << "\n======================================================" << std::endl;
    std::cout << "               BENCHMARKS CONCLUIDOS" << std::endl;
    std::cout << "======================================================" << std::endl;

    return benchmark_results;
}
```

## arquivo config.cpp
```cpp
#include "../include/config.hpp"
#include <yaml-cpp/yaml.h>
#include <iostream>
#include <stdexcept>

Config load_config(const std::string& config_path) {
    Config config;
    try {
        YAML::Node yaml = YAML::LoadFile(config_path);

        // Carrega as configurações globais
        if (yaml["settings"]) {
            auto settings = yaml["settings"];
            config.settings.output_base_dir = settings["output_base_dir"].as<std::string>();
            config.settings.epsilon_tolerance = settings["epsilon_tolerance"].as<double>();
            config.settings.max_iterations = settings["max_iterations"].as<int>();
            config.settings.save_intermediate_images = settings["save_intermediate_images"].as<bool>();
            config.settings.num_omp_threads = settings["num_omp_threads"].as<int>();
        }

        // Carrega os datasets
        if (yaml["datasets"]) {
            for (const auto& dataset : yaml["datasets"]) {
                DatasetConfig dc;
                dc.name = dataset["name"].as<std::string>();
                dc.description = dataset["description"].as<std::string>();
                dc.h_matrix_csv = dataset["h_matrix_csv"].as<std::string>();
                dc.g_signal_csv = dataset["g_signal_csv"].as<std::string>();
                dc.image_rows = dataset["image_rows"].as<int>();
                dc.image_cols = dataset["image_cols"].as<int>();
                config.datasets.push_back(dc);
            }
        }

        // Carrega os métodos
        if (yaml["methods"]) {
            for (const auto& method : yaml["methods"]) {
                MethodConfig mc;
                mc.name = method["name"].as<std::string>();
                mc.description = method["description"].as<std::string>();
                mc.solver = method["solver"].as<std::string>();
                mc.use_binary = method["use_binary"].as<bool>();
                mc.is_baseline = method["is_baseline"].as<bool>();
                config.methods.push_back(mc);
            }
        }

        // Carrega os pipelines
        if (yaml["run_pipelines"]) {
            for (const auto& pipeline : yaml["run_pipelines"]) {
                PipelineConfig pc;
                pc.name = pipeline["name"].as<std::string>();
                pc.description = pipeline["description"].as<std::string>();
                pc.method_names = pipeline["methods"].as<std::vector<std::string>>();
                pc.dataset_names = pipeline["datasets"].as<std::vector<std::string>>();
                config.run_pipelines.push_back(pc);
            }
        }

        // Popula os mapas para acesso rápido
        config.populate_maps();

        // Validação do pipeline
        std::cout << "\n[INFO] Validando pipeline..." << std::endl;
        for (const auto& pipeline : config.run_pipelines) {
            std::cout << "\nPipeline: " << pipeline.name << std::endl;
            std::cout << "Datasets configurados:" << std::endl;
            for (const auto& dataset_name : pipeline.dataset_names) {
                if (config.dataset_map.find(dataset_name) == config.dataset_map.end()) {
                    throw std::runtime_error("Dataset '" + dataset_name + "' configurado no pipeline '" +
                                          pipeline.name + "' não foi encontrado na lista de datasets disponíveis");
                }
                std::cout << "  - " << dataset_name << std::endl;
            }

            std::cout << "Métodos configurados:" << std::endl;
            for (const auto& method_name : pipeline.method_names) {
                if (config.method_map.find(method_name) == config.method_map.end()) {
                    throw std::runtime_error("Método '" + method_name + "' configurado no pipeline '" +
                                          pipeline.name + "' não foi encontrado na lista de métodos disponíveis");
                }
                std::cout << "  - " << method_name << std::endl;
            }
        }

        std::cout << "\n[INFO] Configuração carregada com sucesso de: " << config_path << std::endl;
        if (!config.run_pipelines.empty()) {
            std::cout << "[INFO] Pipeline ativo: " << config.run_pipelines[0].name << std::endl;
            std::cout << "[INFO] Dataset(s) a processar:";
            for (const auto& dataset : config.run_pipelines[0].dataset_names) {
                std::cout << " " << dataset;
            }
            std::cout << std::endl;
        }

    } catch (const YAML::Exception& e) {
        throw std::runtime_error("Erro ao carregar configuração YAML: " + std::string(e.what()));
    }

    return config;
}
```

## arquivo io_utils.cpp
```cpp
#include "../include/io_utils.hpp" // Inclui as declarações
#include <fstream>
#include <sstream>
#include <vector>
#include <string>
#include <stdexcept>
#include <iostream>
#include <algorithm> // Para std::remove_if, std::all_of
#include <cmath>     // Para std::abs, std::sqrt
#include <iomanip>    // Para std::scientific, std::setprecision
#include <Eigen/Dense>
#include <Eigen/Sparse>

// --- Implementações das Funções de Carregamento ---

Eigen::VectorXd loadVectorData(const std::string &path) {
    std::ifstream file(path);
    if (!file.is_open()) throw std::runtime_error("Nao foi possivel abrir o arquivo: " + path);
    std::vector<double> values;
    std::string line;
    int line_num = 0;
    while (std::getline(file, line)) {
        line_num++;
        // C++17 compatível:
        if (line.empty() || std::all_of(line.begin(), line.end(), ::isspace)) continue;
        std::stringstream lineStream(line);
        std::string cell;
        while (std::getline(lineStream, cell, ',')) {
            try {
                // C++17 compatível:
                cell.erase(std::remove_if(cell.begin(), cell.end(), ::isspace), cell.end());
                if (!cell.empty()) {
                    values.push_back(std::stod(cell));
                }
            } catch (const std::invalid_argument &) {
                 std::cerr << "[AVISO] Ignorando valor nao numerico em: " << path << ", linha: " << line_num << ", celula: '" << cell << "'" << std::endl;
            } catch (const std::out_of_range &) {
                 std::cerr << "[AVISO] Ignorando valor fora do range em: " << path << ", linha: " << line_num << ", celula: '" << cell << "'" << std::endl;
            }
        }
    }
     if (values.empty()) {
        throw std::runtime_error("Nenhum dado numerico valido encontrado em: " + path);
    }
    Eigen::Map<Eigen::VectorXd> vec_map(values.data(), values.size());
    return Eigen::VectorXd(vec_map);
}

Eigen::MatrixXd loadDenseData(const std::string &path) {
    std::ifstream file(path);
    if (!file.is_open()) throw std::runtime_error("Nao foi possivel abrir o arquivo: " + path);
    std::vector<double> values;
    std::string line;
    int rows = 0;
    long long cols = -1;
    int line_num = 0;

    while (std::getline(file, line)) {
        line_num++;
        // C++17 compatível:
        if (line.empty() || std::all_of(line.begin(), line.end(), ::isspace)) continue;

        std::stringstream lineStream(line);
        std::string cell;
        long long current_cols = 0;
        std::vector<double> row_values;

        while (std::getline(lineStream, cell, ',')) {
             try {
                 // C++17 compatível:
                 cell.erase(std::remove_if(cell.begin(), cell.end(), ::isspace), cell.end());
                 if (!cell.empty()) {
                    row_values.push_back(std::stod(cell));
                 } else {
                     row_values.push_back(0.0);
                     std::cerr << "[AVISO] Celula vazia encontrada em: " << path << ", linha: " << line_num << ", coluna: " << current_cols+1 << ". Assumindo 0.0." << std::endl;
                 }
                current_cols++;
            } catch (const std::invalid_argument &) {
                 std::cerr << "[AVISO] Ignorando valor nao numerico em: " << path << ", linha: " << line_num << ", celula: '" << cell << "'" << std::endl;
                 row_values.push_back(0.0);
                 current_cols++;
            } catch (const std::out_of_range &) {
                 std::cerr << "[AVISO] Ignorando valor fora do range em: " << path << ", linha: " << line_num << ", celula: '" << cell << "'" << std::endl;
                 row_values.push_back(0.0);
                 current_cols++;
            }
        }

        if (cols == -1) {
             if (current_cols == 0) continue;
             cols = current_cols;
        } else if (current_cols != cols) {
             std::cerr << "[ERRO] Numero inconsistente de colunas na linha " << line_num << " do arquivo " << path << ". Esperado: " << cols << ", Encontrado: " << current_cols << ". Abortando." << std::endl;
             throw std::runtime_error("Inconsistencia de colunas no CSV denso.");
        }

        values.insert(values.end(), row_values.begin(), row_values.end());
        rows++;
    }
     if (rows == 0 || cols <= 0 || values.empty()) {
         throw std::runtime_error("Nao foi possivel carregar dados validos da matriz densa de: " + path + " (rows=" + std::to_string(rows) + ", cols=" + std::to_string(cols) + ")");
     }

    Eigen::Map<Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor> > mat_map(values.data(), rows, cols);
    return Eigen::MatrixXd(mat_map);
}

Eigen::MatrixXd loadDenseMatrix(const std::string &path) {
    std::ifstream file(path, std::ios::binary);
    if (!file.is_open()) throw std::runtime_error("Nao foi possivel abrir o arquivo binario: " + path);
    Eigen::Index rows, cols;
    file.read(reinterpret_cast<char *>(&rows), sizeof(rows));
    file.read(reinterpret_cast<char *>(&cols), sizeof(cols));

    if (!file || file.eof()) throw std::runtime_error("Erro ao ler cabecalho do arquivo binario denso: " + path);
    if (rows <= 0 || cols <= 0) throw std::runtime_error("Dimensoes invalidas ("+ std::to_string(rows) + "x" + std::to_string(cols) +") lidas do arquivo binario denso: " + path);

    Eigen::MatrixXd mat(rows, cols);
    file.read(reinterpret_cast<char *>(mat.data()), static_cast<std::streamsize>(rows) * cols * sizeof(double));
    if (!file){
          if (file.eof() && (static_cast<std::streamsize>(rows) * cols * sizeof(double) > 0)) {
              throw std::runtime_error("Fim de arquivo inesperado ao ler dados do arquivo binario denso: " + path);
         } else if (!file.eof()) {
              throw std::runtime_error("Erro de leitura ao processar dados do arquivo binario denso: " + path);
         }
    }
    return mat;
}

Eigen::SparseMatrix<double> convertCsvToSparse(const std::string &path, int expected_cols) {
    std::ifstream file(path);
    if (!file.is_open()) throw std::runtime_error("Nao foi possivel abrir o arquivo: " + path);
    std::vector<Eigen::Triplet<double> > tripletList;
    std::string line;
    int row = 0;
    long long actual_cols = -1;
    int line_num = 0;

    while (std::getline(file, line)) {
        line_num++;
        // C++17 compatível:
        if (line.empty() || std::all_of(line.begin(), line.end(), ::isspace)) continue;

        std::stringstream lineStream(line);
        std::string cell;
        int col = 0;
        while (std::getline(lineStream, cell, ',')) {
            try {
                // C++17 compatível:
                cell.erase(std::remove_if(cell.begin(), cell.end(), ::isspace), cell.end());
                if (!cell.empty()) {
                    double value = std::stod(cell);
                    if (std::abs(value) > 1e-12) {
                        tripletList.emplace_back(row, col, value);
                    }
                }
            } catch (const std::invalid_argument &) {
                 std::cerr << "[AVISO] Ignorando valor nao numerico em CSV esparso: " << path << ", linha: " << line_num
                           << ", celula: '" << cell << "'" << std::endl;
            } catch (const std::out_of_range &) {
                 std::cerr << "[AVISO] Ignorando valor fora do range em CSV esparso: " << path << ", linha: " << line_num
                           << ", celula: '" << cell << "'" << std::endl;
            }
            col++;
        }
         if (actual_cols == -1) {
            if (col == 0) continue;
             actual_cols = col;
         } else if (col != actual_cols) {
             std::cerr << "[ERRO] Numero inconsistente de colunas na linha " << line_num << " do arquivo esparso " <<
                     path << ". Esperado: " << actual_cols << ", Encontrado: " << col << ". Abortando." << std::endl;
              throw std::runtime_error("Inconsistencia de colunas no CSV esparso.");
         }
        row++;
    }
     if (row == 0 || actual_cols <= 0) {
         throw std::runtime_error("Nao foi possivel ler nenhuma linha/coluna valida do arquivo esparso: " + path);
     }
     if (expected_cols > 0 && actual_cols != expected_cols) {
          std::cerr << "[AVISO] Numero de colunas lido (" << actual_cols << ") difere do esperado (" << expected_cols <<
                   ") para " << path << ". Usando o numero lido." << std::endl;
     }

    Eigen::SparseMatrix<double> mat(row, actual_cols);
    if (!tripletList.empty()) {
        mat.setFromTriplets(tripletList.begin(), tripletList.end());
    } else {
         std::cerr << "[AVISO] Nenhum elemento nao-zero (acima de 1e-12) encontrado em " << path << std::endl;
    }
    mat.makeCompressed();
    return mat;
}


Eigen::SparseMatrix<double> loadSparseMatrix(const std::string &path) {
     std::ifstream file(path, std::ios::binary);
    if (!file.is_open()) throw std::runtime_error("Nao foi possivel abrir o arquivo binario: " + path);
    Eigen::Index rows, cols;
    Eigen::Index nonZeros;
    file.read(reinterpret_cast<char *>(&rows), sizeof(rows));
    file.read(reinterpret_cast<char *>(&cols), sizeof(cols));
    file.read(reinterpret_cast<char *>(&nonZeros), sizeof(nonZeros));

    if (!file || file.eof()) throw std::runtime_error("Erro ao ler cabecalho do arquivo binario esparso: " + path);
    if (rows < 0 || cols < 0 || nonZeros < 0) throw std::runtime_error("Dimensoes invalidas (" + std::to_string(rows) + "x" + std::to_string(cols) + ", nnz=" + std::to_string(nonZeros) + ") lidas do arquivo binario esparso: " + path);

    Eigen::SparseMatrix<double> mat(rows, cols);
    mat.makeCompressed();
    mat.resizeNonZeros(nonZeros);

    if (nonZeros > 0) {
        if (!mat.valuePtr() || !mat.innerIndexPtr()){
            throw std::runtime_error("Ponteiros value/inner invalidos apos resizeNonZeros ao carregar: " + path);
        }
        file.read(reinterpret_cast<char *>(mat.valuePtr()), nonZeros * sizeof(double));
        file.read(reinterpret_cast<char *>(mat.innerIndexPtr()), nonZeros * sizeof(int));
    }

     if (!mat.outerIndexPtr()) {
          throw std::runtime_error("Ponteiro outerIndex invalido apos makeCompressed ao carregar: " + path);
     }
    file.read(reinterpret_cast<char *>(mat.outerIndexPtr()), (mat.outerSize() + 1) * sizeof(int));

    if (!file) {
         if (file.eof()) {
              std::cerr << "[AVISO] Fim de arquivo prematuro ao ler dados de " << path << ". A matriz pode estar incompleta." << std::endl;
              throw std::runtime_error("Fim de arquivo inesperado ao ler dados do arquivo binario esparso: " + path);
         } else {
              throw std::runtime_error("Erro de leitura ao processar dados do arquivo binario esparso: " + path);
         }
    }
    mat.finalize();
    return mat;
}

// --- Implementações das Funções de Salvamento ---

void saveDenseMatrix(const Eigen::MatrixXd &mat, const std::string &path) {
    std::ofstream file(path, std::ios::binary | std::ios::trunc);
    if (!file.is_open()) throw std::runtime_error("Nao foi possivel criar o arquivo binario: " + path);
    const auto rows = mat.rows(), cols = mat.cols();
    file.write(reinterpret_cast<const char *>(&rows), sizeof(rows));
    file.write(reinterpret_cast<const char *>(&cols), sizeof(cols));
    file.write(reinterpret_cast<const char *>(mat.data()), static_cast<std::streamsize>(rows) * cols * sizeof(double));
     if (!file) throw std::runtime_error("Erro ao escrever no arquivo binario denso: " + path);
    file.close();
     if (!file) throw std::runtime_error("Erro ao fechar o arquivo binario denso: " + path);
}

void saveSparseMatrix(const Eigen::SparseMatrix<double> &mat, const std::string &path) {
    std::ofstream file(path, std::ios::binary | std::ios::trunc);
    if (!file.is_open()) throw std::runtime_error("Nao foi possivel criar o arquivo binario: " + path);

    Eigen::SparseMatrix<double> compressed_mat = mat;
    if (!compressed_mat.isCompressed()) {
        compressed_mat.makeCompressed();
    }

    const auto rows = compressed_mat.rows();
    const auto cols = compressed_mat.cols();
    const auto nonZeros = compressed_mat.nonZeros();
    const auto outerSize = compressed_mat.outerSize();

    file.write(reinterpret_cast<const char *>(&rows), sizeof(rows));
    file.write(reinterpret_cast<const char *>(&cols), sizeof(cols));
    file.write(reinterpret_cast<const char *>(&nonZeros), sizeof(nonZeros));

    if (nonZeros > 0) {
        if (!compressed_mat.valuePtr() || !compressed_mat.innerIndexPtr()) {
             throw std::runtime_error("Ponteiros internos invalidos ao salvar matriz esparsa para: " + path);
        }
        file.write(reinterpret_cast<const char *>(compressed_mat.valuePtr()), nonZeros * sizeof(double));
        file.write(reinterpret_cast<const char *>(compressed_mat.innerIndexPtr()), nonZeros * sizeof(int));
    }
     if (!compressed_mat.outerIndexPtr()) {
          throw std::runtime_error("Ponteiro outerIndex invalido ao salvar matriz esparsa para: " + path);
     }
    file.write(reinterpret_cast<const char *>(compressed_mat.outerIndexPtr()), (outerSize + 1) * sizeof(int));

    if (!file) throw std::runtime_error("Erro ao escrever no arquivo binario esparso: " + path);
    file.close();
    if (!file) throw std::runtime_error("Erro ao fechar o arquivo binario esparso: " + path);
}


void saveHistoryToCSV(const std::vector<double>& history, const std::string &filename) {
    std::ofstream file(filename);
    if (!file.is_open()) {
        std::cerr << "[AVISO] Nao foi possivel criar o arquivo de historico: " << filename << std::endl;
        return;
    }
    file << "Iteration,ResidualNorm\n";
    for (size_t i = 0; i < history.size(); ++i) {
        file << i + 1 << "," << std::scientific << std::setprecision(8) << history[i] << "\n";
    }
     if (!file) {
         std::cerr << "[AVISO] Erro ao escrever no arquivo de historico: " << filename << std::endl;
     } else {
        // Removido cout daqui para evitar poluir a saída do benchmark
        // std::cout << "[INFO] Historico de convergencia salvo em: " << filename << std::endl;
     }
    file.close();
}

// Função auxiliar para manter compatibilidade com ReconstructionResult
void saveHistoryToCSV(const ReconstructionResult &result, const std::string &filename) {
    std::ofstream file(filename);
    if (!file.is_open()) {
        std::cerr << "[AVISO] Nao foi possivel criar o arquivo de historico: " << filename << std::endl;
        return;
    }

    // Cabeçalho com mais métricas
    file << "Iteration,ResidualNorm,SolutionNorm,ExecutionTime_ms\n";

    for (size_t i = 0; i < result.residual_history.size(); ++i) {
        file << i + 1 << ", "
                << std::scientific << std::setprecision(8) << result.residual_history[i] << ", "
                << std::scientific << std::setprecision(8) << (i < result.solution_history.size()
                                                                   ? result.solution_history[i]
                                                                   : 0.0) << ", "
                << std::fixed << std::setprecision(2) << result.execution_time_ms << "\n";
    }

    if (!file) {
        std::cerr << "[AVISO] Erro ao escrever no arquivo de historico: " << filename << std::endl;
    } else {
        std::cout << "[INFO] Historico de convergencia salvo em: " << filename << std::endl;
    }
    file.close();
}

void saveLcurveToCSV(const ReconstructionResult &result, const std::string &filename) {
    if (result.residual_history.size() != result.solution_history.size()) {
         std::cerr << "[AVISO] Tamanhos incompativeis (" << result.residual_history.size() << " vs "
                   << result.solution_history.size() << ") de historico de residuo e solucao para L-curve. Nao salvando " << filename << std::endl;
        return;
    }
     if (result.residual_history.empty()) {
         // std::cerr << "[AVISO] Historico vazio, nada para salvar em L-curve: " << filename << std::endl; // Opcional
         return;
     }
    std::ofstream file(filename);
    if (!file.is_open()) {
        std::cerr << "[AVISO] Nao foi possivel criar o arquivo de cotovelo: " << filename << std::endl;
        return;
    }
    file << "Iteration,SolutionNorm,ResidualNorm\n";
    for (size_t i = 0; i < result.residual_history.size(); ++i) {
        file << i + 1 << ","
             << std::scientific << std::setprecision(8) << result.solution_history[i] << ","
             << std::scientific << std::setprecision(8) << result.residual_history[i] << "\n";
    }
    if (!file) {
         std::cerr << "[AVISO] Erro ao escrever no arquivo L-curve: " << filename << std::endl;
     } else {
        // Removido cout daqui
        // std::cout << "[INFO] Dados L-curve salvos em: " << filename << std::endl;
     }
    file.close();
}

void saveImageVectorToCsv(const Eigen::VectorXd& vec, const std::string& filename, int img_rows, int img_cols) {
     if (vec.size() != static_cast<long long>(img_rows) * img_cols) {
         std::cerr << "[AVISO] Tamanho do vetor (" << vec.size() << ") nao corresponde as dimensoes da imagem ("
                   << img_rows << "x" << img_cols << "). Nao salvando imagem: " << filename << std::endl;
         return;
     }
     if (img_rows <= 0 || img_cols <= 0) {
          std::cerr << "[AVISO] Dimensoes invalidas da imagem (" << img_rows << "x" << img_cols
                    << "). Nao salvando imagem: " << filename << std::endl;
          return;
     }

    std::ofstream file(filename);
    if (!file.is_open()) {
        std::cerr << "[AVISO] Nao foi possivel criar o arquivo CSV da imagem: " << filename << std::endl;
        return;
    }

    file << std::scientific << std::setprecision(8);

    for (int i = 0; i < img_rows; ++i) {
        for (int j = 0; j < img_cols; ++j) {
            long long index = static_cast<long long>(j) * img_rows + i; // ColMajor Indexing
            if (index < vec.size()) {
                file << vec(index);
            } else {
                 file << 0.0;
            }
            if (j < img_cols - 1) {
                file << ",";
            }
        }
        file << "\n";
    }

    if (!file) {
         std::cerr << "[AVISO] Erro ao escrever no arquivo CSV da imagem: " << filename << std::endl;
     } else {
         // Removido cout daqui
         // std::cout << "[INFO] Imagem reconstruida salva em: " << filename << std::endl;
     }
    file.close();
}
```

## arquivo reporting.cpp
```cpp
#include "../include/reporting.hpp" // Inclui a declaração da função
#include "../include/types.hpp"   // Para as structs de dados
#include "../include/config.hpp"  // Para acessar descrições, etc.
#include <iostream>
#include <iomanip>    // Para formatação (setw, setprecision, etc.)
#include <sstream>    // Para formatar o speedup
#include <map>
#include <string>
#include <vector>
#include <fstream>    // Para salvar o relatório em arquivo (opcional)
#include <filesystem> // Para construir o caminho do arquivo de relatório

// --- Implementação da Geração do Relatório ---

void generate_report(const BenchmarkResults& benchmark_results, const Config& config) {
    // String stream para construir o relatório (para console e arquivo)
    std::stringstream report_ss;

    // --- Cabeçalho do Relatório ---
    report_ss << "\n\n======================================================================================================================================================" << std::endl;
    report_ss << "                                           RELATORIO COMPARATIVO FINAL (ESPARSO)" << std::endl;
    report_ss << "======================================================================================================================================================" << std::endl;
    report_ss << std::left
              << std::setw(22) << "Teste"
              << std::setw(28) << "Metodo Otimizado"
              << std::setw(15) << "RAM (MB)"
              << std::setw(20) << "T. Carga (ms)"
              << std::setw(20) << "T. Solver (ms)"
              << std::setw(12) << "Iteracoes"
              << std::setw(15) << "Erro Final"
              << std::setw(15) << "Epsilon Final"
              << std::setw(15) << "Convergiu (Eps)"
              << std::setw(15) << "vs Standard" // Comparação vs standard (baseline)
              << std::endl;
    report_ss << "------------------------------------------------------------------------------------------------------------------------------------------------------" << std::endl;

    // --- Itera sobre os resultados por dataset ---
    // Usamos config.datasets para manter a ordem original
    for (const auto& dataset_config : config.datasets) {
        const std::string& dataset_name = dataset_config.name;

        // Verifica se há resultados para este dataset
        auto dataset_results_it = benchmark_results.results.find(dataset_name);
        if (dataset_results_it == benchmark_results.results.end()) {
            continue; // Pula se nenhum método rodou para este dataset
        }
        const auto& method_results_map = dataset_results_it->second;

        // Encontra as métricas do baseline (standard) para este dataset, se existirem
        const PerformanceMetrics* baseline_metrics_ptr = nullptr;
        std::string baseline_method_name = "sparse_standard"; // Assume que este é o baseline
        auto baseline_it = method_results_map.find(baseline_method_name);
        if (baseline_it != method_results_map.end()) {
            baseline_metrics_ptr = &baseline_it->second;
        }
        bool baseline_valid = baseline_metrics_ptr && baseline_metrics_ptr->solve_time_ms > 0;

        bool first_method_for_dataset = true; // Para imprimir o nome do teste só uma vez

        // Itera sobre os métodos na ordem definida na config, para consistência
        for (const auto& method_config : config.methods) {
             // Verifica se este método foi executado para este dataset
             auto metrics_it = method_results_map.find(method_config.name);
             if (metrics_it == method_results_map.end()) {
                 continue; // Pula se este método não rodou para este dataset
             }
             const PerformanceMetrics& m = metrics_it->second;
             bool is_baseline = (method_config.name == baseline_method_name);

             // Imprime a linha da métrica
             // Verifica se houve erro (métricas zeradas na função de comparação)
            if (m.load_time_ms <= 0 && m.solve_time_ms <= 0 && m.estimated_ram_mb <= 0 && m.iterations == 0 && m.optimization_type != "none") {
                 report_ss << std::left
                           << std::setw(22) << (first_method_for_dataset ? dataset_config.description : "") // Nome do Teste
                           << std::setw(28) << method_config.description // Nome do Método
                           << std::setw(15+20+20+12+15+15+15) << " [FALHOU]" // Mensagem de Falha
                           << std::setw(14) << std::right << (is_baseline ? "BASELINE" : " N/A") // Speedup
                           << std::endl;
            } else if (m.optimization_type != "none") { // Imprime apenas se as métricas foram preenchidas
                 report_ss << std::left
                           << std::setw(22) << (first_method_for_dataset ? dataset_config.description : "") // Nome do Teste
                           << std::setw(28) << method_config.description // Nome do Método
                           << std::fixed << std::setprecision(2) << std::setw(15) << m.estimated_ram_mb
                           << std::fixed << std::setprecision(2) << std::setw(20) << m.load_time_ms
                           << std::fixed << std::setprecision(2) << std::setw(20) << m.solve_time_ms
                           << std::setw(12) << m.iterations
                           << std::scientific << std::setprecision(3) << std::setw(14) << m.final_error
                           << std::scientific << std::setprecision(3) << std::setw(14) << m.final_epsilon
                           << std::setw(15) << (m.converged ? "Sim" : "Nao (MaxIt)");

                // Calcula Speedup vs Baseline (Standard)
                if (is_baseline) {
                    report_ss << std::setw(14) << std::right << "BASELINE";
                } else if (baseline_valid && m.solve_time_ms > 0) {
                    const double speedup = baseline_metrics_ptr->solve_time_ms / m.solve_time_ms;
                    std::stringstream ss_speedup;
                    ss_speedup << std::fixed << std::setprecision(2) << speedup << "x";
                    report_ss << std::setw(14) << std::right << ss_speedup.str();
                } else {
                    report_ss << std::setw(14) << std::right << " N/A";
                }
                report_ss << std::endl;
            }
            first_method_for_dataset = false; // Só imprime nome do teste na primeira linha
        } // Fim loop methods

        // Linha separadora entre datasets
        if (!method_results_map.empty()) { // Só imprime se houve resultados para este dataset
            report_ss << "------------------------------------------------------------------------------------------------------------------------------------------------------" << std::endl;
        }
    } // Fim loop datasets

    report_ss << "\nBenchmark concluido." << std::endl;

    // --- Imprime no Console ---
    std::cout << report_ss.str();

    // --- Salva em Arquivo (Opcional) ---
    try {
        std::filesystem::path report_file_path = config.settings.output_base_dir;
        report_file_path /= "summary_report.txt"; // Nome do arquivo de relatório
        std::ofstream report_file(report_file_path);
        if (report_file.is_open()) {
            report_file << report_ss.str();
            report_file.close();
            std::cout << "\n[INFO] Relatorio final salvo em: " << std::filesystem::absolute(report_file_path) << std::endl;
        } else {
            std::cerr << "[AVISO] Nao foi possivel abrir o arquivo de relatorio para escrita: " << report_file_path << std::endl;
        }
    } catch (const std::exception& e) {
        std::cerr << "[AVISO] Erro ao salvar relatorio final em arquivo: " << e.what() << std::endl;
    }
}
```

## arquivo solvers.cpp
```cpp
#include "../include/solvers.hpp" // Inclui as declarações
#include "../include/io_utils.hpp" // Para saveImageVectorToCsv
#include <vector>
#include <string>
#include <cmath>
#include <limits>
#include <iostream>
#include <iomanip>
#include <filesystem>
#include <Eigen/Core>
#include <Eigen/SparseCore>
#include <fstream>

// --- Implementação do Solver CGNR Regularizado (Salva Imagens Intermediárias) ---
template<typename MatrixType>
ReconstructionResult run_cgnr_solver_epsilon_save_iters(
    const Eigen::VectorXd &g_signal, const MatrixType &H_model,
    const double tolerance, const int max_iterations,
    const std::string& base_filename_prefix,
    const std::filesystem::path& output_dir,
    int img_rows, int img_cols)
{
    // Verificações iniciais
    if (H_model.rows() != g_signal.size()) throw std::runtime_error("run_cgnr_solver_epsilon_save_iters: Dimensoes H/g incompativeis. H.rows=" + std::to_string(H_model.rows()) + ", g.size=" + std::to_string(g_signal.size()));
    if (H_model.cols() <= 0) throw std::runtime_error("run_cgnr_solver_epsilon_save_iters: Matriz H tem " + std::to_string(H_model.cols()) + " colunas.");
    if (H_model.rows() == 0) {
        std::cerr << "[AVISO] run_cgnr_solver_epsilon_save_iters: Matriz H ou sinal g estao vazios." << std::endl;
        return ReconstructionResult{};
    }

    const auto start_time = std::chrono::high_resolution_clock::now();

    // Inicialização
    Eigen::VectorXd f = Eigen::VectorXd::Zero(H_model.cols());
    Eigen::VectorXd r = g_signal;
    Eigen::VectorXd z = H_model.transpose() * r;
    Eigen::VectorXd p = z;
    double z_norm_sq = z.squaredNorm();

    // Cálculo do Lambda
    double lambda = 0.0;
    if (z.size() > 0) {
        lambda = z.cwiseAbs().maxCoeff() * 0.10;
        constexpr double min_lambda = 1e-9;
        if (lambda < min_lambda) { lambda = min_lambda; std::cout << "[INFO] Lambda calculado era quase zero, usando piso minimo: " << lambda << std::endl;}
    } else { lambda = 1e-9; std::cout << "[AVISO] Vetor z inicial vazio, usando lambda=" << lambda << " como fallback." << std::endl;}
    std::cout << "[INFO] Lambda (solver standard): " << lambda << std::endl;

    ReconstructionResult result;
    result.iterations = 0; result.converged = false;
    result.residual_history.clear(); result.residual_history.reserve(max_iterations);
    result.solution_history.clear(); result.solution_history.reserve(max_iterations);
    double previous_residual_norm = r.norm();
    double current_residual_norm = previous_residual_norm;
    double epsilon = std::numeric_limits<double>::max();

    // Salva imagem inicial (iter 0)
    bool save_iters = !base_filename_prefix.empty() && img_rows > 0 && img_cols > 0;
    if (save_iters) {
         try {
             std::filesystem::path iter_img_path = output_dir / (base_filename_prefix + "_iter_0.csv");
             saveImageVectorToCsv(f, iter_img_path.string(), img_rows, img_cols);
         } catch (const std::exception& e) {
              std::cerr << "[AVISO] Falha ao salvar imagem iter 0: " << e.what() << std::endl;
         }
    }

    // Loop CGNR
    for (int i = 0; i < max_iterations; ++i) {
        result.iterations = i + 1;
        Eigen::VectorXd w = H_model * p;
        double p_norm_sq = p.squaredNorm();
        double modified_denominator = w.squaredNorm() + lambda * p_norm_sq;

        if (modified_denominator < std::numeric_limits<double>::epsilon()) {
            std::cout << "[INFO] Denominador modificado (" << modified_denominator << ") proximo de zero na iteracao " << i + 1 << ". Parando." << std::endl;
            break;
        }

        double alpha = z_norm_sq / modified_denominator;
        f += alpha * p;
        r -= alpha * w;

        // Salva imagem intermediária
        if (save_iters) {
             try {
                std::filesystem::path iter_img_path = output_dir / (base_filename_prefix + "_iter_" + std::to_string(i + 1) + ".csv");
                saveImageVectorToCsv(f, iter_img_path.string(), img_rows, img_cols);
             } catch (const std::exception& e) {
                 std::cerr << "[AVISO] Falha ao salvar imagem iter " << i+1 << ": " << e.what() << std::endl;
             }
        }

        Eigen::VectorXd z_next = (H_model.transpose() * r) - (lambda * f);
        const double z_next_norm_sq = z_next.squaredNorm();

        current_residual_norm = r.norm(); result.residual_history.push_back(current_residual_norm);
        result.solution_history.push_back(f.norm());
        epsilon = std::abs(current_residual_norm - previous_residual_norm);

        if (epsilon < tolerance) {
            result.converged = true;
            std::cout << "[INFO] Convergencia por epsilon atingida na iteracao " << i+1 << " (epsilon=" << std::scientific << epsilon << " < " << tolerance << ")" << std::defaultfloat << std::endl;
            break;
        }
        previous_residual_norm = current_residual_norm;

        double beta = 0.0;
        if (z_norm_sq >= std::numeric_limits<double>::epsilon()) { beta = z_next_norm_sq / z_norm_sq; }
        else {
            std::cout << "[INFO] ||z||^2 (" << z_norm_sq << ") proximo de zero na iteracao " << i + 1 << ". Usando beta=0 (restart)." << std::endl;
             if (z_next_norm_sq < std::numeric_limits<double>::epsilon()) {
                 std::cout << "[INFO] ||z_next||^2 tambem proximo de zero. Provavelmente estagnou. Parando." << std::endl;
                 break;
             }
        }

        p = z_next + beta * p;
        z = z_next;
        z_norm_sq = z_next_norm_sq;

        if (i == max_iterations - 1 && !result.converged) {
            std::cout << "[INFO] Numero maximo de iteracoes (" << max_iterations << ") atingido sem convergencia por epsilon (ultimo epsilon=" << std::scientific << epsilon << std::defaultfloat << ")." << std::endl;
        }
    } // Fim do loop

    const auto end_time = std::chrono::high_resolution_clock::now();
    result.image = f; result.final_error = current_residual_norm; result.final_epsilon = epsilon;
    result.execution_time_ms = std::chrono::duration<double, std::milli>(end_time - start_time).count();
    return result;
}

// --- Implementação do Solver CGNR Pré-condicionado (Salva Imagens Intermediárias) ---
template<typename MatrixType>
inline ReconstructionResult run_cgnr_solver_preconditioned_save_iters(
    const Eigen::VectorXd &g_signal, const MatrixType &H_model,
    const double tolerance, const int max_iterations,
    const std::string& base_filename_prefix,
    const std::filesystem::path& output_dir,
    int img_rows, int img_cols)
{
    if (H_model.rows() != g_signal.size()) throw std::runtime_error("...");
    if (H_model.cols() <= 0) throw std::runtime_error("...");
    if (H_model.rows() == 0) return ReconstructionResult{};

    const auto start_time = std::chrono::high_resolution_clock::now();

    Eigen::VectorXd f = Eigen::VectorXd::Zero(H_model.cols());
    Eigen::VectorXd r = g_signal;
    Eigen::VectorXd z_unprec = H_model.transpose() * r;

    // Cálculo do pré-condicionador Jacobi
    Eigen::VectorXd preconditioner = Eigen::VectorXd::Ones(H_model.cols());
     if constexpr (std::is_same_v<MatrixType, Eigen::MatrixXd>) { /* Densa */
        #pragma omp parallel for schedule(static)
        for (Eigen::Index j = 0; j < H_model.cols(); ++j) {
            preconditioner(j) = H_model.col(j).squaredNorm();
        }
     } else { // Esparsa
         preconditioner.setZero();
         // Não dá para paralelizar facilmente por coluna em CSC, faz sequencial
         for (int k=0; k<H_model.outerSize(); ++k) {
             for (typename MatrixType::InnerIterator it(H_model,k); it; ++it) {
                 // it.col() é a coluna, it.value() é o valor
                 preconditioner(it.col()) += it.value() * it.value();
             }
         }
     }
    preconditioner = preconditioner.cwiseMax(1e-12).cwiseInverse(); // Inverte (e evita divisão por zero)
    std::cout << "[INFO] Pre-condicionador Jacobi calculado." << std::endl;

    Eigen::VectorXd z = z_unprec.cwiseProduct(preconditioner); // z_0 = M^-1 * (H^T * r_0)
    Eigen::VectorXd p = z; // p_0 = z_0
    double z_precond_dot_z = z_unprec.dot(z); // z_0^T * M^-1 * z_unprec_0

    double lambda = 0.0;
    if (z_unprec.size() > 0) { // Usa z_unprec (H^T g) para calcular lambda
        lambda = z_unprec.cwiseAbs().maxCoeff() * 0.10;
         constexpr double min_lambda = 1e-9;
        if (lambda < min_lambda) { lambda = min_lambda; std::cout << "[INFO] Lambda calculado era quase zero, usando piso minimo: " << lambda << std::endl;}
    } else { lambda = 1e-9; std::cout << "[AVISO] Vetor z inicial (unprec) vazio, usando lambda=" << lambda << " como fallback." << std::endl;}
    std::cout << "[INFO] Lambda (solver precond): " << lambda << std::endl;

    ReconstructionResult result;
    result.iterations = 0; result.converged = false;
    result.residual_history.clear(); result.residual_history.reserve(max_iterations);
    result.solution_history.clear(); result.solution_history.reserve(max_iterations);
    double previous_residual_norm = r.norm();
    double current_residual_norm = previous_residual_norm;
    double epsilon = std::numeric_limits<double>::max();

     // Salva imagem inicial (iter 0)
     bool save_iters = !base_filename_prefix.empty() && img_rows > 0 && img_cols > 0;
     if (save_iters) {
         try {
             std::filesystem::path iter_img_path = output_dir / (base_filename_prefix + "_iter_0.csv");
             saveImageVectorToCsv(f, iter_img_path.string(), img_rows, img_cols);
         } catch (const std::exception& e) {
             std::cerr << "[AVISO] Falha ao salvar imagem iter 0 (precond): " << e.what() << std::endl;
         }
     }

    // Loop CGNR Pré-condicionado
    for (int i = 0; i < max_iterations; ++i) {
        result.iterations = i + 1;
        Eigen::VectorXd w = H_model * p;
        double p_norm_sq = p.squaredNorm();
        double modified_denominator = w.squaredNorm() + lambda * p_norm_sq;

        if (modified_denominator < std::numeric_limits<double>::epsilon()) {
            std::cout << "[INFO] Denominador modificado (" << modified_denominator << ") proximo de zero na iteracao " << i + 1 << ". Parando." << std::endl;
            break;
        }

        double alpha = z_precond_dot_z / modified_denominator; // Usa produto interno modificado

        f += alpha * p;
        r -= alpha * w;

         // Salva imagem intermediária
         if (save_iters) {
             try {
                std::filesystem::path iter_img_path = output_dir / (base_filename_prefix + "_iter_" + std::to_string(i + 1) + ".csv");
                saveImageVectorToCsv(f, iter_img_path.string(), img_rows, img_cols);
             } catch (const std::exception& e) {
                 std::cerr << "[AVISO] Falha ao salvar imagem iter " << i+1 << " (precond): " << e.what() << std::endl;
             }
        }

        Eigen::VectorXd z_next_unprec = (H_model.transpose() * r) - (lambda * f);
        Eigen::VectorXd z_next = z_next_unprec.cwiseProduct(preconditioner); // Aplica pré-condicionador
        double z_next_precond_dot_z_next = z_next_unprec.dot(z_next); // Novo produto interno

        current_residual_norm = r.norm(); result.residual_history.push_back(current_residual_norm);
        result.solution_history.push_back(f.norm());
        epsilon = std::abs(current_residual_norm - previous_residual_norm);

        if (epsilon < tolerance) {
            result.converged = true;
            std::cout << "[INFO] Convergencia por epsilon atingida na iteracao " << i + 1 << " (epsilon=" << std::scientific << epsilon << " < " << tolerance << ")" << std::defaultfloat << std::endl;
            break;
        }
        previous_residual_norm = current_residual_norm;

        double beta = 0.0;
        // Beta usa os produtos internos modificados
        if (z_precond_dot_z >= std::numeric_limits<double>::epsilon()) {
             beta = z_next_precond_dot_z_next / z_precond_dot_z;
        } else {
             std::cout << "[INFO] Produto interno z^T M^-1 z_unprec (" << z_precond_dot_z << ") proximo de zero na iteracao " << i + 1 << ". Usando beta=0 (restart)." << std::endl;
            if (z_next_precond_dot_z_next < std::numeric_limits<double>::epsilon()) {
                std::cout << "[INFO] Produto interno z_next^T M^-1 z_unprec_next tambem proximo de zero. Provavelmente estagnou. Parando." << std::endl;
                break;
            }
        }

        p = z_next + beta * p; // p_{i+1} = z_{i+1} + beta_i * p_i
        z = z_next; // z é o pré-condicionado
        z_precond_dot_z = z_next_precond_dot_z_next; // Atualiza produto interno

        if (i == max_iterations - 1 && !result.converged) {
            std::cout << "[INFO] Numero maximo de iteracoes (" << max_iterations << ") atingido sem convergencia por epsilon (ultimo epsilon=" << std::scientific << epsilon << std::defaultfloat << ")." << std::endl;
        }
    } // Fim do loop

    const auto end_time = std::chrono::high_resolution_clock::now();
    result.image = f; result.final_error = current_residual_norm; result.final_epsilon = epsilon;
    result.execution_time_ms = std::chrono::duration<double, std::milli>(end_time - start_time).count();
    return result;
}


// --- Implementação Solver Fixo (NÃO salva imagens intermediárias) ---
template<typename MatrixType>
inline ReconstructionResult run_cgnr_solver_fixed_iter(const Eigen::VectorXd &g_signal, const MatrixType &H_model,
                                                const int num_iterations) {
    if (H_model.rows() != g_signal.size()) throw std::runtime_error("run_cgnr_solver_fixed_iter: Dimensoes H/g incompativeis");
    if (H_model.cols() <= 0) throw std::runtime_error("run_cgnr_solver_fixed_iter: Matriz H tem 0 colunas");
    if (H_model.rows() == 0) return ReconstructionResult{};

    const auto start_time = std::chrono::high_resolution_clock::now();
    Eigen::VectorXd f = Eigen::VectorXd::Zero(H_model.cols());
    Eigen::VectorXd r = g_signal;
    Eigen::VectorXd z = H_model.transpose() * r;
    Eigen::VectorXd p = z;
    double z_norm_sq = z.squaredNorm();

    ReconstructionResult result;
    result.iterations = 0; result.converged = false;
    result.residual_history.clear(); result.residual_history.reserve(num_iterations);
    result.solution_history.clear(); result.solution_history.reserve(num_iterations);

    for (int i = 0; i < num_iterations; ++i) {
        result.iterations = i + 1;
        double current_residual_norm = r.norm(); result.residual_history.push_back(current_residual_norm);
        double current_solution_norm = f.norm(); result.solution_history.push_back(current_solution_norm);
        Eigen::VectorXd w = H_model * p; double w_norm_sq = w.squaredNorm();
        double alpha = 0.0;
        if (w_norm_sq >= std::numeric_limits<double>::epsilon()) { alpha = z_norm_sq / w_norm_sq; }
        else {
            // Não imprime aviso repetidamente, pode poluir muito
            // std::cout << "[AVISO - FixedIter] ||H*p||^2 proximo de zero na iteracao " << i + 1 << ". Usando alpha=0." << std::endl;
            z_norm_sq = 0.0;
        }
        f += alpha * p; r -= alpha * w;
        Eigen::VectorXd z_next = H_model.transpose() * r; const double z_next_norm_sq = z_next.squaredNorm();
        double beta = 0.0;
        if (z_norm_sq >= std::numeric_limits<double>::epsilon()) { beta = z_next_norm_sq / z_norm_sq; }
        else {
            // Não imprime aviso repetidamente
            // std::cout << "[AVISO - FixedIter] ||z||^2 proximo de zero na iteracao " << i + 1 << ". Usando beta=0." << std::endl;
        }
        p = z_next + beta * p; z = z_next; z_norm_sq = z_next_norm_sq;
    } // Fim do loop

    const auto end_time = std::chrono::high_resolution_clock::now();
    result.image = f; result.final_error = r.norm();
    result.execution_time_ms = std::chrono::duration<double, std::milli>(end_time - start_time).count();
    return result;
}

template<typename MatrixType>
ReconstructionResult run_fista_solver_save_iters(const Eigen::VectorXd &g_signal, const MatrixType &H_model,
    double tolerance, int max_iterations, const std::string &base_filename_prefix,
    const std::filesystem::path &output_dir, int img_rows, int img_cols) {

    const auto start_time = std::chrono::high_resolution_clock::now();
    ReconstructionResult result;
    result.converged = false;

    // Initialize variables
    const int n = H_model.cols();
    Eigen::VectorXd x = Eigen::VectorXd::Zero(n);  // Current solution
    Eigen::VectorXd y = x;                         // Extrapolated point
    Eigen::VectorXd x_prev = x;                    // Previous solution
    double t = 1.0;                                // Initial step size
    double t_prev;
    double L = 1.0;                                // Lipschitz constant estimate

    // Main FISTA iteration loop
    for (int iter = 0; iter < max_iterations; ++iter) {
        result.iterations = iter + 1;

        // Store previous values
        x_prev = x;
        t_prev = t;

        // Gradient step
        Eigen::VectorXd gradient = H_model.transpose() * (H_model * y - g_signal);
        x = y - (1.0/L) * gradient;

        // Soft thresholding (L1 regularization)
        double lambda = 0.1 / L;  // Regularization parameter
        x = (x.array().abs() > lambda).select(
            (x.array().abs() - lambda) * x.array().sign(),
            0.0
        );

        // Update t and y using FISTA update rule
        t = (1.0 + std::sqrt(1.0 + 4.0 * t * t)) / 2.0;
        y = x + ((t_prev - 1.0) / t) * (x - x_prev);

        // Calculate residual and update histories
        Eigen::VectorXd residual = H_model * x - g_signal;
        double current_residual_norm = residual.norm();
        result.residual_history.push_back(current_residual_norm);
        result.solution_history.push_back(x.norm());

        // Save intermediate result to CSV
        if (img_rows > 0 && img_cols > 0) {
            try {
                std::filesystem::path iter_img_path = output_dir / (base_filename_prefix + "_iter_" + std::to_string(iter) + ".csv");
                saveImageVectorToCsv(x, iter_img_path.string(), img_rows, img_cols);
            } catch (const std::exception& e) {
                std::cerr << "[AVISO] Falha ao salvar imagem iter " << iter << " (FISTA): " << e.what() << std::endl;
            }
        }

        // Check convergence
        if (iter > 0) {
            double epsilon = std::abs(result.residual_history[iter] - result.residual_history[iter-1]);
            result.final_epsilon = epsilon;
            if (epsilon < tolerance) {
                result.converged = true;
                break;
            }
        }
    }

    // Set final results
    result.image = x;
    result.final_error = (H_model * x - g_signal).norm();
    const auto end_time = std::chrono::high_resolution_clock::now();
    result.execution_time_ms = std::chrono::duration<double, std::milli>(end_time - start_time).count();

    return result;
}

// --- Instanciações explícitas para os tipos de matrizes ---
// Garante que o compilador gere o código para SparseMatrix<double>
template ReconstructionResult run_cgnr_solver_epsilon_save_iters<Eigen::SparseMatrix<double>>(
    const Eigen::VectorXd &g_signal, const Eigen::SparseMatrix<double> &H_model,
    double tolerance, int max_iterations,
    const std::string& base_filename_prefix, const std::filesystem::path& output_dir,
    int img_rows, int img_cols);

template ReconstructionResult run_cgnr_solver_preconditioned_save_iters<Eigen::SparseMatrix<double>>(
    const Eigen::VectorXd &g_signal, const Eigen::SparseMatrix<double> &H_model,
    double tolerance, int max_iterations,
    const std::string& base_filename_prefix, const std::filesystem::path& output_dir,
    int img_rows, int img_cols);

template ReconstructionResult run_cgnr_solver_fixed_iter<Eigen::SparseMatrix<double>>(
    const Eigen::VectorXd &g_signal, const Eigen::SparseMatrix<double> &H_model,
    int num_iterations);

// **** DESCOMENTE ESTAS LINHAS ****
template ReconstructionResult run_cgnr_solver_epsilon_save_iters<Eigen::MatrixXd>(
    const Eigen::VectorXd &g_signal, const Eigen::MatrixXd &H_model,
    double tolerance, int max_iterations,
    const std::string& base_filename_prefix, const std::filesystem::path& output_dir,
    int img_rows, int img_cols);

/* // Não estamos usando pré-condicionador denso, então esta pode ficar comentada se quiser
template ReconstructionResult run_cgnr_solver_preconditioned_save_iters<Eigen::MatrixXd>(
    const Eigen::VectorXd &g_signal, const Eigen::MatrixXd &H_model,
    double tolerance, int max_iterations,
    const std::string& base_filename_prefix, const std::filesystem::path& output_dir,
    int img_rows, int img_cols);
*/

template ReconstructionResult run_cgnr_solver_fixed_iter<Eigen::MatrixXd>(
    const Eigen::VectorXd &g_signal, const Eigen::MatrixXd &H_model,
    int num_iterations);
// **** FIM DA CORREÇÃO ****

// Se você precisar rodar com Matriz Densa também, descomente estas:
/*
template ReconstructionResult run_cgnr_solver_epsilon_save_iters<Eigen::MatrixXd>(
    const Eigen::VectorXd &g_signal, const Eigen::MatrixXd &H_model,
    double tolerance, int max_iterations,
    const std::string& base_filename_prefix, const std::filesystem::path& output_dir,
    int img_rows, int img_cols);

template ReconstructionResult run_cgnr_solver_preconditioned_save_iters<Eigen::MatrixXd>(
    const Eigen::VectorXd &g_signal, const Eigen::MatrixXd &H_model,
    double tolerance, int max_iterations,
    const std::string& base_filename_prefix, const std::filesystem::path& output_dir,
    int img_rows, int img_cols);

template ReconstructionResult run_cgnr_solver_fixed_iter<Eigen::MatrixXd>(
    const Eigen::VectorXd &g_signal, const Eigen::MatrixXd &H_model,
    int num_iterations);
*/

// Explicit template instantiation for FISTA solver
template ReconstructionResult run_fista_solver_save_iters<Eigen::SparseMatrix<double>>(
    const Eigen::VectorXd &g_signal, const Eigen::SparseMatrix<double> &H_model,
    double tolerance, int max_iterations,
    const std::string& base_filename_prefix, const std::filesystem::path& output_dir,
    int img_rows, int img_cols);

template ReconstructionResult run_fista_solver_save_iters<Eigen::MatrixXd>(
    const Eigen::VectorXd &g_signal, const Eigen::MatrixXd &H_model,
    double tolerance, int max_iterations,
    const std::string& base_filename_prefix, const std::filesystem::path& output_dir,
    int img_rows, int img_cols);

/* // Commented out dense matrix implementations
template ReconstructionResult run_fista_solver_save_iters<Eigen::MatrixXd>(
    const Eigen::VectorXd &g_signal, const Eigen::MatrixXd &H_model,
    double tolerance, int max_iterations,
    const std::string& base_filename_prefix, const std::filesystem::path& output_dir,
    int img_rows, int img_cols);
*/
```

## arquivo utils.cpp
```cpp
#include "../include/utils.hpp" // Inclui as declarações
#include <vector>
#include <cmath>     // Para std::abs, std::sqrt
#include <iostream>
#include <stdexcept>
#include <Eigen/Core>
#include <Eigen/SparseCore>
#include <omp.h>     // Para OpenMP

// --- Implementação da Função de Normalização ---

template<typename MatrixType>
void normalize_system_rows(MatrixType &H, Eigen::VectorXd &g) {
    if (H.rows() != g.size()) {
        throw std::runtime_error(
            "normalize_system_rows: Dimensoes H/g incompativeis. H.rows=" + std::to_string(H.rows()) + ", g.size=" +
            std::to_string(g.size()));
    }
    if (H.rows() == 0) {
        std::cout << "[INFO] Matriz H vazia, nada para normalizar." << std::endl;
        return; // Nada a fazer
    }

    std::cout << "[INFO] Normalizando linhas de H e elementos de g..." << std::endl;
    constexpr double epsilon_norm = 1e-12; // Limiar para evitar divisao por zero

    if constexpr (std::is_same_v<MatrixType, Eigen::MatrixXd>) {
        // --- Versão Densa ---
#pragma omp parallel for schedule(static) // Paraleliza a normalização das linhas
        for (Eigen::Index i = 0; i < H.rows(); ++i) {
            double row_norm = H.row(i).norm();
            if (row_norm > epsilon_norm) {
                H.row(i) /= row_norm;
                g(i) /= row_norm;
            } else {
                // Linha é (quase) zero, zera explicitamente para evitar NaNs
                H.row(i).setZero();
                g(i) = 0.0;
            }
        }
    } else {
        // --- Versão Esparsa ---
        std::vector<double> row_norms_sq(H.rows(), 0.0);

        // Calcula norma ao quadrado de cada linha (iterando pelos não-zeros)
        // Esta parte é inerentemente sequencial por coluna na estrutura CSC do Eigen
        for (int k = 0; k < H.outerSize(); ++k) {
            for (typename MatrixType::InnerIterator it(H, k); it; ++it) {
                row_norms_sq[it.row()] += it.value() * it.value();
            }
        }

        // Modifica os valores da matriz esparsa in-place (paralelizável por coluna)
#pragma omp parallel for schedule(static)
        for (int k = 0; k < H.outerSize(); ++k) {
            for (typename MatrixType::InnerIterator it(H, k); it; ++it) {
                double row_norm = std::sqrt(row_norms_sq[it.row()]);
                if (row_norm > epsilon_norm) {
                    // valueRef() permite modificar o valor
                    it.valueRef() /= row_norm;
                } else {
                    // Se a norma da linha é zero, o valor deve ser zero
                    it.valueRef() = 0.0;
                }
            }
        }
        // Remove explicitamente os zeros que podem ter sido criados (opcional, mas bom para limpeza)
        H.prune(0.0, std::numeric_limits<double>::epsilon()); // Remove valores muito pequenos

        // Normaliza g (paralelizável)
#pragma omp parallel for schedule(static)
        for (Eigen::Index i = 0; i < g.size(); ++i) {
            double row_norm = std::sqrt(row_norms_sq[i]);
            if (row_norm > epsilon_norm) {
                g(i) /= row_norm;
            } else {
                g(i) = 0.0;
            }
        }
    }
    std::cout << "[INFO] Normalizacao concluida." << std::endl;
}

// --- Instanciação explícita para os tipos que vamos usar ---
// Isso garante que o compilador gere o código para MatrixXd e SparseMatrix<double>
// Coloque isso no final do arquivo .cpp
template void normalize_system_rows<Eigen::MatrixXd>(Eigen::MatrixXd &H, Eigen::VectorXd &g);

template void normalize_system_rows<Eigen::SparseMatrix<double> >(Eigen::SparseMatrix<double> &H, Eigen::VectorXd &g);

// --- Implementação de Outras Funções Utilitárias (se houver) ---
// Exemplo: isToeplitz (copiado do solver_comparison.hpp anterior)
/*
template<typename MatrixType>
bool isToeplitz(const MatrixType &H, const double tolerance = 1e-10) {
    const Eigen::Index rows = H.rows();
    const Eigen::Index cols = H.cols();

    if (rows == 0 || cols == 0) return true;

    for (int d = -rows + 1; d < cols; ++d) {
        double first_val = 0.0; // Initialize properly
        bool first = true;

        for (Eigen::Index i = std::max(0, -d); i < std::min(rows, cols - d); ++i) {
            Eigen::Index j = i + d;
            double current_val;

            if constexpr (std::is_same_v<MatrixType, Eigen::MatrixXd>) {
                current_val = H(i, j);
            } else {
                current_val = H.coeff(i, j); // Use coeff for sparse
            }

            if (first) {
                 // Only record the first non-zero (or near-zero) value encountered on the diagonal
                 if (std::abs(current_val) > tolerance * 1e-3) { // Use a smaller tolerance to find the 'first' meaningful value
                     first_val = current_val;
                     first = false;
                 } else if (i == std::min(rows, cols - d) - 1) { // If we reach the end and only found zeros
                     first_val = 0.0; // Consider the diagonal constant zero
                     first = false; // Prevent comparison below
                 }
            } else {
                // Only compare if the current value is also significant
                if (std::abs(current_val) > tolerance * 1e-3 || std::abs(first_val) > tolerance * 1e-3) {
                     if (std::abs(current_val - first_val) > tolerance) {
                         //std::cout << "[DEBUG] Diagonal " << d << " nao e constante na pos (" << i << "," << j << "): "
                         //          << first_val << " vs " << current_val << std::endl;
                         return false;
                     }
                }
                 // If both current_val and first_val are near zero, consider them equal
            }
        }
    }
    return true;
}

// Instanciações explícitas para isToeplitz
template bool isToeplitz<Eigen::MatrixXd>(const Eigen::MatrixXd& H, double tolerance);
template bool isToeplitz<Eigen::SparseMatrix<double>>(const Eigen::SparseMatrix<double>& H, double tolerance);
*/
```

## arquivo benchmark_runner.hpp
```cpp
#ifndef ULTRASOUNDBENCHMARK_BENCHMARK_RUNNER_HPP
#define ULTRASOUNDBENCHMARK_BENCHMARK_RUNNER_HPP

#include "types.hpp"   // Para Config, BenchmarkResults, etc.
#include "config.hpp"  // Para a classe Config

/**
 * @brief Executa os pipelines de benchmark definidos na configuração.
 * Carrega dados, chama os solvers apropriados, coleta métricas e
 * preenche a estrutura BenchmarkResults.
 *
 * @param config Objeto Config contendo toda a configuração lida do YAML.
 * @return BenchmarkResults Estrutura contendo os resultados de todos os testes executados.
 */
BenchmarkResults run_benchmarks(const Config& config);


#endif //ULTRASOUNDBENCHMARK_BENCHMARK_RUNNER_HPP
```

## arquivo config.hpp
```cpp
#ifndef ULTRASOUNDBENCHMARK_CONFIG_HPP
#define ULTRASOUNDBENCHMARK_CONFIG_HPP

#include <iostream>
#include "types.hpp" // Inclui as definições de structs (DatasetConfig, MethodConfig, etc.)
#include <string>
#include <vector>
#include <map>

// Classe para armazenar a configuração completa lida do YAML
class Config {
public:
    GlobalSettings settings; // Configurações globais
    std::vector<DatasetConfig> datasets; // Lista de datasets disponíveis
    std::vector<MethodConfig> methods; // Lista de métodos disponíveis
    std::vector<PipelineConfig> run_pipelines; // Lista de pipelines a executar

    // Mapas para acesso rápido por nome (preenchidos após carregar)
    std::map<std::string, const DatasetConfig*> dataset_map;
    std::map<std::string, const MethodConfig*> method_map;

    // Construtor padrão
    Config() = default;

    // Função para preencher os mapas após carregar os vetores
    void populate_maps() {
        dataset_map.clear();
        method_map.clear();

        std::cout << "\n[INFO] Populando mapas de configuração..." << std::endl;

        std::cout << "[INFO] Datasets disponíveis:" << std::endl;
        for (const auto& dataset : datasets) {
            dataset_map[dataset.name] = &dataset;
            std::cout << "  - " << dataset.name << std::endl;
        }

        std::cout << "[INFO] Métodos disponíveis:" << std::endl;
        for (const auto& method : methods) {
            method_map[method.name] = &method;
            std::cout << "  - " << method.name << std::endl;
        }

        std::cout << "[INFO] Pipelines configurados:" << std::endl;
        for (const auto& pipeline : run_pipelines) {
            std::cout << "  Pipeline: " << pipeline.name << std::endl;
            std::cout << "    Datasets: ";
            for (const auto& dataset : pipeline.dataset_names) {
                std::cout << dataset << " ";
            }
            std::cout << std::endl;
            std::cout << "    Métodos: ";
            for (const auto& method : pipeline.method_names) {
                std::cout << method << " ";
            }
            std::cout << std::endl;
        }
    }
};

// Declaração da função que carregará a configuração do arquivo YAML
Config load_config(const std::string& config_path);


#endif //ULTRASOUNDBENCHMARK_CONFIG_HPP
```

## arquivo io_utils.hpp
```cpp
#ifndef ULTRASOUNDBENCHMARK_IO_UTILS_HPP
#define ULTRASOUNDBENCHMARK_IO_UTILS_HPP

#include <string>
#include <vector>
#include <Eigen/Core>
#include <Eigen/SparseCore>
#include "types.hpp" // Para ReconstructionResult

// --- Declarações das Funções de Carregamento ---

// Carrega um vetor de um arquivo CSV (uma coluna ou linha longa)
Eigen::VectorXd loadVectorData(const std::string& path);

// Carrega uma matriz densa de um arquivo CSV
Eigen::MatrixXd loadDenseData(const std::string& path);

// Carrega uma matriz densa de um arquivo binário
Eigen::MatrixXd loadDenseMatrix(const std::string& path);

// Converte um CSV para uma matriz esparsa
Eigen::SparseMatrix<double> convertCsvToSparse(const std::string& path, int expected_cols);

// Carrega uma matriz esparsa de um arquivo binário
Eigen::SparseMatrix<double> loadSparseMatrix(const std::string& path);

// --- Declarações das Funções de Salvamento ---

// Salva uma matriz densa em um arquivo binário
void saveDenseMatrix(const Eigen::MatrixXd& mat, const std::string& path);

// Salva uma matriz esparsa em um arquivo binário
void saveSparseMatrix(const Eigen::SparseMatrix<double>& mat, const std::string& path);

// Salva o histórico de normas de resíduo em CSV
void saveHistoryToCSV(const std::vector<double>& history, const std::string& filename);

// Salva o histórico de convergência a partir de um ReconstructionResult
void saveHistoryToCSV(const ReconstructionResult& result, const std::string& filename);

// Salva os dados para a L-curve (norma da solução vs norma do resíduo) em CSV
void saveLcurveToCSV(const ReconstructionResult& result, const std::string& filename);

// Salva o vetor da imagem reconstruída (f) em formato CSV (matricial)
void saveImageVectorToCsv(const Eigen::VectorXd& vec, const std::string& filename, int img_rows, int img_cols);


#endif //ULTRASOUNDBENCHMARK_IO_UTILS_HPP
```

## arquivo reporting.hpp
```cpp
#ifndef ULTRASOUNDBENCHMARK_REPORTING_HPP
#define ULTRASOUNDBENCHMARK_REPORTING_HPP

#include "types.hpp"   // Para BenchmarkResults, Config
#include "config.hpp"  // Para Config
#include <string>

/**
 * @brief Gera a tabela de relatório comparativo final.
 * Imprime a tabela no console e, opcionalmente, salva em um arquivo.
 *
 * @param benchmark_results Estrutura contendo os resultados de todos os testes.
 * @param config Objeto Config contendo a configuração global e dos métodos/datasets.
 */
void generate_report(const BenchmarkResults& benchmark_results, const Config& config);

#endif //ULTRASOUNDBENCHMARK_REPORTING_HPP
```

## arquivo solvers.hpp
```cpp
#ifndef ULTRASOUNDBENCHMARK_SOLVERS_HPP
#define ULTRASOUNDBENCHMARK_SOLVERS_HPP

#include "types.hpp" // Para ReconstructionResult
#include <Eigen/Core>
#include <Eigen/SparseCore>
#include <vector>
#include <string>
#include <filesystem> // Para std::filesystem::path

// --- Declarações dos Solvers ---

/**
 * @brief Executa o solver CGNR padrão com Regularização de Tikhonov (Salva Imagens Intermediárias).
 * Assume que H e g já foram normalizados. Para quando epsilon < tolerance ou max_iterations.
 * @param g_signal Sinal medido (vetor g) normalizado.
 * @param H_model Matriz do sistema (H) normalizada.
 * @param tolerance Tolerância para o critério de parada epsilon.
 * @param max_iterations Número máximo de iterações.
 * @param base_filename_prefix Prefixo para os nomes dos arquivos CSV das imagens intermediárias.
 * @param output_dir Diretório para salvar as imagens intermediárias.
 * @param img_rows Número de linhas da imagem para salvar CSV.
 * @param img_cols Número de colunas da imagem para salvar CSV.
 * @return ReconstructionResult Contendo a imagem final, métricas e histórico.
 */
template<typename MatrixType>
ReconstructionResult run_cgnr_solver_epsilon_save_iters(
    const Eigen::VectorXd &g_signal, const MatrixType &H_model,
    double tolerance, int max_iterations,
    const std::string& base_filename_prefix,
    const std::filesystem::path& output_dir,
    int img_rows, int img_cols);

/**
 * @brief Executa o solver CGNR com Pré-condicionador Jacobi e Regularização de Tikhonov (Salva Imagens Intermediárias).
 * Assume que H e g já foram normalizados. Para quando epsilon < tolerance ou max_iterations.
 * @param g_signal Sinal medido (vetor g) normalizado.
 * @param H_model Matriz do sistema (H) normalizada.
 * @param tolerance Tolerância para o critério de parada epsilon.
 * @param max_iterations Número máximo de iterações.
 * @param base_filename_prefix Prefixo para os nomes dos arquivos CSV das imagens intermediárias.
 * @param output_dir Diretório para salvar as imagens intermediárias.
 * @param img_rows Número de linhas da imagem para salvar CSV.
 * @param img_cols Número de colunas da imagem para salvar CSV.
 * @return ReconstructionResult Contendo a imagem final, métricas e histórico.
 */
template<typename MatrixType>
ReconstructionResult run_cgnr_solver_preconditioned_save_iters(
    const Eigen::VectorXd &g_signal, const MatrixType &H_model,
    double tolerance, int max_iterations,
    const std::string& base_filename_prefix,
    const std::filesystem::path& output_dir,
    int img_rows, int img_cols);


/**
 * @brief Executa o solver CGNR padrão (sem regularização explícita aqui) por um número FIXO de iterações.
 * Usado para gerar dados consistentes para os CSVs de convergência e L-curve.
 * Assume que H e g já foram normalizados. NÃO salva imagens intermediárias.
 * @param g_signal Sinal medido (vetor g) normalizado.
 * @param H_model Matriz do sistema (H) normalizada.
 * @param num_iterations Número exato de iterações a executar.
 * @return ReconstructionResult Contendo histórico de resíduo e solução.
 */
template<typename MatrixType>
ReconstructionResult run_cgnr_solver_fixed_iter(
    const Eigen::VectorXd &g_signal, const MatrixType &H_model,
    int num_iterations);


/**
 * @brief Executa o solver FISTA (Fast Iterative Shrinkage-Thresholding Algorithm) com salvamento de iterações.
 * Usa regularização L1 (soft thresholding) e atualização de momento FISTA.
 * @param g_signal Sinal medido (vetor g) normalizado.
 * @param H_model Matriz do sistema (H) normalizada.
 * @param tolerance Tolerância para o critério de parada epsilon.
 * @param max_iterations Número máximo de iterações.
 * @param base_filename_prefix Prefixo para os nomes dos arquivos CSV das imagens intermediárias.
 * @param output_dir Diretório para salvar as imagens intermediárias.
 * @param img_rows Número de linhas da imagem para salvar CSV.
 * @param img_cols Número de colunas da imagem para salvar CSV.
 * @return ReconstructionResult Contendo a imagem final, métricas e histórico.
 */
template<typename MatrixType>
ReconstructionResult run_fista_solver_save_iters(
    const Eigen::VectorXd &g_signal, const MatrixType &H_model,
    double tolerance, int max_iterations,
    const std::string& base_filename_prefix,
    const std::filesystem::path& output_dir,
    int img_rows, int img_cols);

#endif //ULTRASOUNDBENCHMARK_SOLVERS_HPP
```

## arquivo types.hpp
```cpp
#ifndef ULTRASOUNDBENCHMARK_TYPES_HPP
#define ULTRASOUNDBENCHMARK_TYPES_HPP

#include <vector>
#include <string>
#include <map> // Para std::map
#include <Eigen/Core> // Para Eigen::VectorXd

// Estrutura para armazenar o resultado de uma reconstrução
struct ReconstructionResult {
    Eigen::VectorXd image; // Vetor f reconstruído
    int iterations{};
    double final_error{}; // Norma do resíduo final ||r||
    double final_epsilon{}; // Valor final de epsilon = | ||r_i+1|| - ||r_i|| |
    double execution_time_ms{};
    bool converged{}; // Indica se parou pela tolerância epsilon
    std::vector<double> residual_history; // Histórico da norma ||r_i||
    std::vector<double> solution_history; // Histórico da norma ||f_i||
};

// Estrutura para configurar um conjunto de dados de teste (lido do YAML)
struct DatasetConfig {
    std::string name;           // Nome curto (ex: "60x60_G1")
    std::string description;    // Descrição (ex: "60x60 (Sinal G-1)")
    std::string h_matrix_csv;   // Caminho para o CSV da matriz H
    std::string g_signal_csv;   // Caminho para o CSV do sinal G
    int image_rows = 0;
    int image_cols = 0;
};

// Estrutura para configurar um método de reconstrução (lido do YAML)
struct MethodConfig {
    std::string name;           // Nome curto (ex: "sparse_standard")
    std::string description;    // Descrição (ex: "Esparso / Binario (Standard)")
    std::string solver;         // Identificador do solver (ex: "cgnr_standard")
    bool use_binary = true;     // Usar .bin em vez de .csv para H?
    bool is_baseline = false;   // É a referência para speedup?
};

// Estrutura para configurar um pipeline de execução (lido do YAML)
struct PipelineConfig {
    std::string name;
    std::string description;
    std::vector<std::string> method_names; // Nomes dos métodos a rodar
    std::vector<std::string> dataset_names; // Nomes dos datasets a usar
};

// Estrutura para armazenar as métricas de desempenho de uma execução
struct PerformanceMetrics {
    std::string optimization_type;  // "standard", "jacobi", "fista"
    double load_time_ms = 0.0;
    double solve_time_ms = 0.0;
    double estimated_ram_mb = 0.0; // RAM estimada apenas para H
    int iterations = 0;
    double final_error = 0.0; // ||r|| final
    double final_epsilon = 0.0; // Epsilon final
    bool converged = false;
};

// Estrutura para guardar todos os resultados de um pipeline
struct BenchmarkResults {
    // Mapeia nome do dataset -> (Mapeia nome do método -> Métricas)
    std::map<std::string, std::map<std::string, PerformanceMetrics>> results;
    // Guarda ponteiros para a config original para referência
    const MethodConfig* baseline_method = nullptr;
};

// Estrutura global para as configurações lidas do YAML
struct GlobalSettings {
    std::string output_base_dir = "../output";
    double epsilon_tolerance = 1.0e-4;
    int max_iterations = 10;
    bool save_intermediate_images = false;
    int num_omp_threads = 0; // 0 = padrão
};


#endif //ULTRASOUNDBENCHMARK_TYPES_HPP
```

## arquivo utils.hpp
```cpp
#ifndef ULTRASOUNDBENCHMARK_UTILS_HPP
#define ULTRASOUNDBENCHMARK_UTILS_HPP

#include <Eigen/Core>
#include <Eigen/SparseCore>
#include <vector>
#include <string>

// --- Declaração da Função de Normalização ---

/**
 * @brief Normaliza as linhas da matriz H e os elementos correspondentes do vetor g.
 * Modifica H e g no local.
 * @tparam MatrixType Eigen::MatrixXd ou Eigen::SparseMatrix<double>
 * @param H Matriz do sistema (será modificada).
 * @param g Vetor do sinal medido (será modificado).
 */
template<typename MatrixType>
void normalize_system_rows(MatrixType& H, Eigen::VectorXd& g);

// --- Declaração de Outras Funções Utilitárias (se houver) ---
// Exemplo: Função para verificar estrutura Toeplitz (se ainda for útil para análise)
// template<typename MatrixType>
// bool isToeplitz(const MatrixType& H, double tolerance = 1e-10);


#endif //ULTRASOUNDBENCHMARK_UTILS_HPP
```

## arquivo solver_comparison.hpp
```cpp
#ifndef ULTRASOUNDSERVER_SOLVER_COMPARISON_HPP
#define ULTRASOUNDSERVER_SOLVER_COMPARISON_HPP

#include <Eigen/Core>
#include <Eigen/Dense>
#include <Eigen/Sparse>
#include <algorithm>
#include <chrono>
#include <cmath>
#include <filesystem>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <limits>
#include <numeric>
#include <omp.h>
#include <sstream>
#include <stdexcept>
#include <string>
#include <vector>


// Inclui as definições de structs do seu próprio projeto
#include "include/io_utils.hpp" // Incluir o cabeçalho com as declarações
#include "include/types.hpp"


// --- Funções Auxiliares (Implementações Completas) ---
// (As 11 funções: loadVectorData, convertCsvToSparse, saveSparseMatrix,
// loadSparseMatrix, loadDenseData, loadDenseMatrix, saveDenseMatrix,
// saveHistoryToCSV, saveLcurveToCSV, saveImageVectorToCsv,
// normalize_system_rows... ESTÃO AQUI)

template <typename MatrixType>
inline void normalize_system_rows(MatrixType &H, Eigen::VectorXd &g) {
  if (H.rows() != g.size()) {
    throw std::runtime_error(
        "normalize_system_rows: Dimensoes H/g incompativeis.");
  }
  if (H.rows() == 0)
    return;

  std::cout << "[INFO] Normalizando linhas de H e elementos de g..."
            << std::endl;
  constexpr double epsilon_norm = 1e-12;

  if constexpr (std::is_same_v<MatrixType, Eigen::MatrixXd>) {
#pragma omp parallel for
    for (Eigen::Index i = 0; i < H.rows(); ++i) {
      double row_norm = H.row(i).norm();
      if (row_norm > epsilon_norm) {
        H.row(i) /= row_norm;
        g(i) /= row_norm;
      } else {
        H.row(i).setZero();
        g(i) = 0.0;
      }
    }
  } else {
    // Esparsa
    std::vector<double> row_norms_sq(H.rows(), 0.0);
    for (int k = 0; k < H.outerSize(); ++k) {
      for (typename MatrixType::InnerIterator it(H, k); it; ++it) {
        row_norms_sq[it.row()] += it.value() * it.value();
      }
    }
    std::vector<Eigen::Triplet<double>> triplets_normalized;
    triplets_normalized.reserve(H.nonZeros());
    for (int k = 0; k < H.outerSize(); ++k) {
      for (typename MatrixType::InnerIterator it(H, k); it; ++it) {
        double row_norm = std::sqrt(row_norms_sq[it.row()]);
        if (row_norm > epsilon_norm) {
          triplets_normalized.emplace_back(it.row(), it.col(),
                                           it.value() / row_norm);
        }
      }
    }
    H.setFromTriplets(triplets_normalized.begin(), triplets_normalized.end());
#pragma omp parallel for
    for (Eigen::Index i = 0; i < g.size(); ++i) {
      double row_norm = std::sqrt(row_norms_sq[i]);
      if (row_norm > epsilon_norm) {
        g(i) /= row_norm;
      } else {
        g(i) = 0.0;
      }
    }
  }
  std::cout << "[INFO] Normalizacao concluida." << std::endl;
}

// --- Solver CGNR Regularizado (Salva Imagens Intermediárias) ---
template <typename MatrixType>
inline ReconstructionResult run_cgnr_solver_epsilon_save_iters(
    const Eigen::VectorXd &g_signal, const MatrixType &H_model,
    const double tolerance, const int max_iterations,
    const std::string &base_filename_prefix, const std::string &output_dir_str,
    int img_rows, int img_cols, bool save_intermediate_images) {
  if (H_model.rows() != g_signal.size())
    throw std::runtime_error(
        "Dimensoes incompativeis: H.rows()!=" + std::to_string(H_model.rows()) +
        " vs g.size()=" + std::to_string(g_signal.size()));
  if (H_model.cols() <= 0)
    throw std::runtime_error("Matriz H tem " + std::to_string(H_model.cols()) +
                             " colunas.");
  if (H_model.rows() == 0)
    return ReconstructionResult{};

  const auto start_time = std::chrono::high_resolution_clock::now();
  const std::filesystem::path output_dir(output_dir_str);

  Eigen::VectorXd f = Eigen::VectorXd::Zero(H_model.cols());
  Eigen::VectorXd r = g_signal;
  Eigen::VectorXd z = H_model.transpose() * r;
  Eigen::VectorXd p = z;
  double z_norm_sq = z.squaredNorm();

  double lambda = 0.0;
  if (z.size() > 0) {
    lambda = z.cwiseAbs().maxCoeff() * 0.10;
    constexpr double min_lambda = 1e-9;
    if (lambda < min_lambda) {
      lambda = min_lambda;
      std::cout
          << "[INFO] Lambda calculado era quase zero, usando piso minimo: "
          << lambda << std::endl;
    }
  } else {
    lambda = 1e-9;
    std::cout << "[AVISO] Vetor z inicial vazio, usando lambda=" << lambda
              << " como fallback." << std::endl;
  }
  std::cout << "[INFO] Lambda (solver standard): " << lambda << std::endl;

  ReconstructionResult result;
  result.iterations = 0;
  result.converged = false;
  result.residual_history.clear();
  result.residual_history.reserve(max_iterations);
  result.solution_history.clear();
  result.solution_history.reserve(max_iterations);
  double previous_residual_norm = r.norm();
  double current_residual_norm = previous_residual_norm;
  double epsilon = std::numeric_limits<double>::max();

  bool save_iters = save_intermediate_images && !base_filename_prefix.empty() &&
                    img_rows > 0 && img_cols > 0;
  if (save_iters) {
    try {
      std::filesystem::path iter_img_path =
          output_dir / "images" / (base_filename_prefix + "_iter_0.csv");
      saveImageVectorToCsv(f, iter_img_path.string(), img_rows, img_cols);
    } catch (const std::exception &e) {
      std::cerr << "[AVISO] Falha ao salvar imagem iter 0: " << e.what()
                << std::endl;
    }
  }

  for (int i = 0; i < max_iterations; ++i) {
    result.iterations = i + 1;
    Eigen::VectorXd w = H_model * p;
    double p_norm_sq = p.squaredNorm();
    double modified_denominator = w.squaredNorm() + lambda * p_norm_sq;

    if (modified_denominator < std::numeric_limits<double>::epsilon()) {
      std::cout
          << "[INFO] Denominador modificado (...) proximo de zero na iteracao "
          << i + 1 << ". Parando." << std::endl;
      break;
    }

    double alpha = z_norm_sq / modified_denominator;
    f += alpha * p;
    r -= alpha * w;

    if (save_iters) {
      try {
        std::filesystem::path iter_img_path =
            output_dir / "images" /
            (base_filename_prefix + "_iter_" + std::to_string(i + 1) + ".csv");
        saveImageVectorToCsv(f, iter_img_path.string(), img_rows, img_cols);
      } catch (const std::exception &e) {
        std::cerr << "[AVISO] Falha ao salvar imagem iter " << i + 1 << ": "
                  << e.what() << std::endl;
      }
    }

    Eigen::VectorXd z_next = (H_model.transpose() * r) - (lambda * f);
    const double z_next_norm_sq = z_next.squaredNorm();

    current_residual_norm = r.norm();
    result.residual_history.push_back(current_residual_norm);
    result.solution_history.push_back(f.norm());
    epsilon = std::abs(current_residual_norm - previous_residual_norm);

    if (epsilon < tolerance) {
      result.converged = true;
      std::cout << "[INFO] Convergencia por epsilon atingida na iteracao "
                << i + 1 << " (epsilon=" << std::scientific << epsilon << " < "
                << tolerance << ")" << std::defaultfloat << std::endl;
      break;
    }
    previous_residual_norm = current_residual_norm;

    double beta = 0.0;
    if (z_norm_sq >= std::numeric_limits<double>::epsilon()) {
      beta = z_next_norm_sq / z_norm_sq;
    } else {
      std::cout << "[INFO] ||z||^2 (...) proximo de zero na iteracao " << i + 1
                << ". Usando beta=0 (restart)." << std::endl;
      if (z_next_norm_sq < std::numeric_limits<double>::epsilon()) {
        std::cout << "[INFO] ||z_next||^2 tambem proximo de zero. "
                     "Provavelmente estagnou. Parando."
                  << std::endl;
        break;
      }
    }

    p = z_next + beta * p;
    z = z_next;
    z_norm_sq = z_next_norm_sq;

    if (i == max_iterations - 1 && !result.converged) {
      std::cout << "[INFO] Numero maximo de iteracoes (" << max_iterations
                << ") atingido sem convergencia por epsilon (ultimo epsilon="
                << std::scientific << epsilon << std::defaultfloat << ")."
                << std::endl;
    }
  }

  const auto end_time = std::chrono::high_resolution_clock::now();
  result.image = f;
  result.final_error = current_residual_norm;
  result.final_epsilon = epsilon;
  result.execution_time_ms =
      std::chrono::duration<double, std::milli>(end_time - start_time).count();
  return result;
}

// --- Solver CGNR Pré-condicionado (Salva Imagens Intermediárias) ---
template <typename MatrixType>
inline ReconstructionResult run_cgnr_solver_preconditioned_save_iters(
    const Eigen::VectorXd &g_signal, const MatrixType &H_model,
    const double tolerance, const int max_iterations,
    const std::string &base_filename_prefix, const std::string &output_dir_str,
    int img_rows, int img_cols, bool save_intermediate_images) {
  if (H_model.rows() != g_signal.size())
    throw std::runtime_error("...");
  if (H_model.cols() <= 0)
    throw std::runtime_error("...");
  if (H_model.rows() == 0)
    return ReconstructionResult{};

  const auto start_time = std::chrono::high_resolution_clock::now();
  const std::filesystem::path output_dir(output_dir_str);

  Eigen::VectorXd f = Eigen::VectorXd::Zero(H_model.cols());
  Eigen::VectorXd r = g_signal;
  Eigen::VectorXd z_unprec = H_model.transpose() * r;

  Eigen::VectorXd preconditioner = Eigen::VectorXd::Ones(H_model.cols());
  if constexpr (std::is_same_v<MatrixType, Eigen::MatrixXd>) {
#pragma omp parallel for schedule(static)
    for (Eigen::Index j = 0; j < H_model.cols(); ++j) {
      preconditioner(j) = H_model.col(j).squaredNorm();
    }
  } else {
    // Esparsa
    preconditioner.setZero();
    for (int k = 0; k < H_model.outerSize(); ++k) {
      for (typename MatrixType::InnerIterator it(H_model, k); it; ++it) {
        preconditioner(it.col()) += it.value() * it.value();
      }
    }
  }
  preconditioner = preconditioner.cwiseMax(1e-12).cwiseInverse();
  std::cout << "[INFO] Pre-condicionador Jacobi calculado." << std::endl;

  Eigen::VectorXd z = z_unprec.cwiseProduct(preconditioner);
  Eigen::VectorXd p = z;
  double z_precond_dot_z = z_unprec.dot(z);

  double lambda = 0.0;
  if (z_unprec.size() > 0) {
    lambda = z_unprec.cwiseAbs().maxCoeff() * 0.10;
    constexpr double min_lambda = 1e-9;
    if (lambda < min_lambda) {
      lambda = min_lambda;
      std::cout
          << "[INFO] Lambda calculado era quase zero, usando piso minimo: "
          << lambda << std::endl;
    }
  } else {
    lambda = 1e-9;
    std::cout << "[AVISO] Vetor z inicial (unprec) vazio, usando lambda="
              << lambda << " como fallback." << std::endl;
  }
  std::cout << "[INFO] Lambda (solver precond): " << lambda << std::endl;

  ReconstructionResult result;
  result.iterations = 0;
  result.converged = false;
  result.residual_history.clear();
  result.residual_history.reserve(max_iterations);
  result.solution_history.clear();
  result.solution_history.reserve(max_iterations);
  double previous_residual_norm = r.norm();
  double current_residual_norm = previous_residual_norm;
  double epsilon = std::numeric_limits<double>::max();

  bool save_iters = save_intermediate_images && !base_filename_prefix.empty() &&
                    img_rows > 0 && img_cols > 0;
  if (save_iters) {
    try {
      std::filesystem::path iter_img_path =
          output_dir / "images" / (base_filename_prefix + "_iter_0.csv");
      saveImageVectorToCsv(f, iter_img_path.string(), img_rows, img_cols);
    } catch (const std::exception &e) {
      std::cerr << "[AVISO] Falha ao salvar imagem iter 0 (precond): "
                << e.what() << std::endl;
    }
  }

  for (int i = 0; i < max_iterations; ++i) {
    result.iterations = i + 1;
    Eigen::VectorXd w = H_model * p;
    double p_norm_sq = p.squaredNorm();
    double modified_denominator = w.squaredNorm() + lambda * p_norm_sq;

    if (modified_denominator < std::numeric_limits<double>::epsilon()) {
      std::cout
          << "[INFO] Denominador modificado (...) proximo de zero na iteracao "
          << i + 1 << ". Parando." << std::endl;
      break;
    }

    double alpha = z_precond_dot_z / modified_denominator;
    f += alpha * p;
    r -= alpha * w;

    if (save_iters) {
      try {
        std::filesystem::path iter_img_path =
            output_dir / "images" /
            (base_filename_prefix + "_iter_" + std::to_string(i + 1) + ".csv");
        saveImageVectorToCsv(f, iter_img_path.string(), img_rows, img_cols);
      } catch (const std::exception &e) {
        std::cerr << "[AVISO] Falha ao salvar imagem iter " << i + 1
                  << " (precond): " << e.what() << std::endl;
      }
    }

    Eigen::VectorXd z_next_unprec = (H_model.transpose() * r) - (lambda * f);
    Eigen::VectorXd z_next = z_next_unprec.cwiseProduct(preconditioner);
    double z_next_precond_dot_z_next = z_next_unprec.dot(z_next);

    current_residual_norm = r.norm();
    result.residual_history.push_back(current_residual_norm);
    result.solution_history.push_back(f.norm());
    epsilon = std::abs(current_residual_norm - previous_residual_norm);

    if (epsilon < tolerance) {
      result.converged = true;
      std::cout << "[INFO] Convergencia por epsilon atingida na iteracao "
                << i + 1 << " (epsilon=" << std::scientific << epsilon << " < "
                << tolerance << ")" << std::defaultfloat << std::endl;
      break;
    }
    previous_residual_norm = current_residual_norm;

    double beta = 0.0;
    if (z_precond_dot_z >= std::numeric_limits<double>::epsilon()) {
      beta = z_next_precond_dot_z_next / z_precond_dot_z;
    } else {
      std::cout << "[INFO] ||z||^2 (...) proximo de zero na iteracao " << i + 1
                << ". Usando beta=0 (restart)." << std::endl;
      if (z_next_precond_dot_z_next < std::numeric_limits<double>::epsilon()) {
        std::cout << "[INFO] ||z_next||^2 tambem proximo de zero. "
                     "Provavelmente estagnou. Parando."
                  << std::endl;
        break;
      }
    }

    p = z_next + beta * p;
    z = z_next;
    z_precond_dot_z = z_next_precond_dot_z_next;

    if (i == max_iterations - 1 && !result.converged) {
      std::cout << "[INFO] Numero maximo de iteracoes (" << max_iterations
                << ") atingido sem convergencia por epsilon (ultimo epsilon="
                << std::scientific << epsilon << std::defaultfloat << ")."
                << std::endl;
    }
  }

  const auto end_time = std::chrono::high_resolution_clock::now();
  result.image = f;
  result.final_error = current_residual_norm;
  result.final_epsilon = epsilon;
  result.execution_time_ms =
      std::chrono::duration<double, std::milli>(end_time - start_time).count();
  return result;
}

// Solver Fixo (NÃO salva imagens intermediárias)
template <typename MatrixType>
inline ReconstructionResult
run_cgnr_solver_fixed_iter(const Eigen::VectorXd &g_signal,
                           const MatrixType &H_model,
                           const int num_iterations) {
  if (H_model.rows() != g_signal.size())
    throw std::runtime_error("...");
  if (H_model.cols() <= 0)
    throw std::runtime_error("...");
  if (H_model.rows() == 0)
    return ReconstructionResult{};

  const auto start_time = std::chrono::high_resolution_clock::now();
  Eigen::VectorXd f = Eigen::VectorXd::Zero(H_model.cols());
  Eigen::VectorXd r = g_signal;
  Eigen::VectorXd z = H_model.transpose() * r;
  Eigen::VectorXd p = z;
  double z_norm_sq = z.squaredNorm();
  ReconstructionResult result;
  result.iterations = 0;
  result.converged = false;
  result.residual_history.clear();
  result.residual_history.reserve(num_iterations);
  result.solution_history.clear();
  result.solution_history.reserve(num_iterations);

  for (int i = 0; i < num_iterations; ++i) {
    result.iterations = i + 1;
    double current_residual_norm = r.norm();
    result.residual_history.push_back(current_residual_norm);
    double current_solution_norm = f.norm();
    result.solution_history.push_back(current_solution_norm);
    Eigen::VectorXd w = H_model * p;
    double w_norm_sq = w.squaredNorm();
    double alpha = 0.0;
    if (w_norm_sq >= std::numeric_limits<double>::epsilon()) {
      alpha = z_norm_sq / w_norm_sq;
    } else {
      /* std::cout << "[AVISO - FixedIter] ||H*p||^2 proximo de zero..." <<
       * std::endl; */
      z_norm_sq = 0.0;
    }
    f += alpha * p;
    r -= alpha * w;
    Eigen::VectorXd z_next = H_model.transpose() * r;
    const double z_next_norm_sq = z_next.squaredNorm();
    double beta = 0.0;
    if (z_norm_sq >= std::numeric_limits<double>::epsilon()) {
      beta = z_next_norm_sq / z_norm_sq;
    } else {
      /* std::cout << "[AVISO - FixedIter] ||z||^2 proximo de zero..." <<
       * std::endl; */
    }
    p = z_next + beta * p;
    z = z_next;
    z_norm_sq = z_next_norm_sq;
  }
  const auto end_time = std::chrono::high_resolution_clock::now();
  result.image = f;
  result.final_error = r.norm();
  result.execution_time_ms =
      std::chrono::duration<double, std::milli>(end_time - start_time).count();
  return result;
}

// --- Instanciações explícitas para os tipos de matrizes ---
template ReconstructionResult
run_cgnr_solver_epsilon_save_iters<Eigen::SparseMatrix<double>>(
    const Eigen::VectorXd &g_signal, const Eigen::SparseMatrix<double> &H_model,
    double tolerance, int max_iterations,
    const std::string &base_filename_prefix, const std::string &output_dir,
    int img_rows, int img_cols, bool save_intermediate_images);

template ReconstructionResult
run_cgnr_solver_preconditioned_save_iters<Eigen::SparseMatrix<double>>(
    const Eigen::VectorXd &g_signal, const Eigen::SparseMatrix<double> &H_model,
    double tolerance, int max_iterations,
    const std::string &base_filename_prefix, const std::string &output_dir,
    int img_rows, int img_cols, bool save_intermediate_images);

template ReconstructionResult
run_cgnr_solver_fixed_iter<Eigen::SparseMatrix<double>>(
    const Eigen::VectorXd &g_signal, const Eigen::SparseMatrix<double> &H_model,
    int num_iterations);

// Instanciações para Matriz Densa (para reativar testes densos se necessário)
template ReconstructionResult
run_cgnr_solver_epsilon_save_iters<Eigen::MatrixXd>(
    const Eigen::VectorXd &g_signal, const Eigen::MatrixXd &H_model,
    double tolerance, int max_iterations,
    const std::string &base_filename_prefix, const std::string &output_dir,
    int img_rows, int img_cols, bool save_intermediate_images);

template ReconstructionResult
run_cgnr_solver_preconditioned_save_iters<Eigen::MatrixXd>(
    const Eigen::VectorXd &g_signal, const Eigen::MatrixXd &H_model,
    double tolerance, int max_iterations,
    const std::string &base_filename_prefix, const std::string &output_dir,
    int img_rows, int img_cols, bool save_intermediate_images);

template ReconstructionResult
run_cgnr_solver_fixed_iter<Eigen::MatrixXd>(const Eigen::VectorXd &g_signal,
                                            const Eigen::MatrixXd &H_model,
                                            int num_iterations);

// --- Função Principal de Comparação Esparsa ---
// **** CORREÇÃO: TestConfig -> DatasetConfig ****
// Função para encontrar o ponto ótimo na curva L (declarada antes de ser usada)
inline int find_l_curve_corner(const std::vector<double> &residual_norms,
                               const std::vector<double> &solution_norms) {
  if (residual_norms.size() < 3)
    return residual_norms.size() - 1;

  // Usa log dos valores para melhor análise
  std::vector<double> log_residual(residual_norms.size());
  std::vector<double> log_solution(solution_norms.size());

  // Calcula os logs e normaliza
  const double min_res = *std::ranges::min_element(residual_norms);
  const double max_res = *std::ranges::max_element(residual_norms);
  const double min_sol = *std::ranges::min_element(solution_norms);
  const double max_sol = *std::ranges::max_element(solution_norms);

  for (size_t i = 0; i < residual_norms.size(); ++i) {
    log_residual[i] = (std::log(residual_norms[i]) - std::log(min_res)) /
                      (std::log(max_res) - std::log(min_res));
    log_solution[i] = (std::log(solution_norms[i]) - std::log(min_sol)) /
                      (std::log(max_sol) - std::log(min_sol));
  }

  // Encontra o ponto de máxima curvatura
  double max_curvature = -1;
  int corner_idx = 1;

  for (size_t i = 1; i < log_residual.size() - 1; ++i) {
    // Vetores para os pontos adjacentes
    double dx1 = log_residual[i] - log_residual[i - 1];
    double dy1 = log_solution[i] - log_solution[i - 1];
    double dx2 = log_residual[i + 1] - log_residual[i];
    double dy2 = log_solution[i + 1] - log_solution[i];

    // Normaliza os vetores
    double len1 = std::sqrt(dx1 * dx1 + dy1 * dy1);
    double len2 = std::sqrt(dx2 * dx2 + dy2 * dy2);

    if (len1 > 1e-10 && len2 > 1e-10) {
      dx1 /= len1;
      dy1 /= len1;
      dx2 /= len2;
      dy2 /= len2;

      // Calcula o ângulo entre os vetores
      double cos_theta = dx1 * dx2 + dy1 * dy2;
      double curvature = 1.0 - cos_theta; // Simplificação da curvatura

      if (curvature > max_curvature) {
        max_curvature = curvature;
        corner_idx = i;
      }
    }
  }

  return corner_idx;
}

inline std::pair<PerformanceMetrics, PerformanceMetrics>
run_sparse_comparison(const DatasetConfig &config,
                      const GlobalSettings &settings) {
  PerformanceMetrics standard_metrics;
  PerformanceMetrics precond_metrics;
  standard_metrics.optimization_type = "standard";
  precond_metrics.optimization_type = "jacobi";

  // Primeiro roda com iterações suficientes para encontrar o ponto ótimo
  constexpr int initial_iterations =
      50; // Número de iterações para construir a curva L
  const int max_iterations = settings.max_iterations;
  const double epsilon_tolerance = settings.epsilon_tolerance;

  std::cout << "\n-----------------------------------------------------"
            << std::endl;
  // **** CORREÇÃO: test_name -> description ****
  std::cout << "Iniciando Comparacao Esparsa para: " << config.description
            << std::endl;
  std::cout << "-----------------------------------------------------"
            << std::endl;

  // **** CORREÇÃO: test_name -> name ****
  std::string base_filename = config.name; // Usa o nome curto para arquivos
  // C++17 compatível replace:
  std::ranges::replace(base_filename, ' ', '_');
  std::ranges::replace(base_filename, '(', '_');
  std::ranges::replace(base_filename, ')', '_');
  std::ranges::replace(base_filename, '-', '_');

  std::filesystem::path output_dir = settings.output_base_dir;
  // **** CORREÇÃO: h_matrix_path -> h_matrix_csv ****
  std::filesystem::path h_path = config.h_matrix_csv;
  std::filesystem::path data_dir = h_path.parent_path();
  std::filesystem::path sparse_bin_fs_path =
      data_dir / (h_path.filename().string() + ".sparse.bin");

  // --- Teste 1: CGNR Padrão ---
  try {
    std::cout << "\n--- Rodando CGNR Esparso Padrao (Binario) ---\n";
    auto start_load = std::chrono::high_resolution_clock::now();
    Eigen::SparseMatrix<double> H_std =
        loadSparseMatrix(sparse_bin_fs_path.string());
    // **** CORREÇÃO: g_signal_path -> g_signal_csv ****
    Eigen::VectorXd g_std = loadVectorData(config.g_signal_csv);
    auto end_load = std::chrono::high_resolution_clock::now();
    standard_metrics.load_time_ms =
        std::chrono::duration<double, std::milli>(end_load - start_load)
            .count();
    standard_metrics.estimated_ram_mb =
        static_cast<double>(H_std.nonZeros() * (sizeof(double) + sizeof(int)) +
                            (H_std.outerSize() + 1) * sizeof(int)) /
        (1024.0 * 1024.0);

    normalize_system_rows(H_std, g_std);
    Eigen::VectorXd z0_std = H_std.transpose() * g_std;
    std::cout << "[DEBUG Standard] Norma de z0 (H^T * g norm): "
              << z0_std.norm() << std::endl;

    // Define o prefixo do arquivo para o FISTA
    std::string filename_prefix_std =
        "image_" + base_filename + "_sparse_standard";
    std::string filename_prefix_fista =
        "image_" + base_filename + "_sparse_fista";
    ReconstructionResult res_std = run_cgnr_solver_epsilon_save_iters(
        g_std, H_std, epsilon_tolerance, max_iterations, filename_prefix_std,
        output_dir.string(), config.image_rows, config.image_cols,
        settings.save_intermediate_images);

    standard_metrics.solve_time_ms = res_std.execution_time_ms;
    standard_metrics.iterations = res_std.iterations;
    standard_metrics.final_error = res_std.final_error;
    standard_metrics.final_epsilon = res_std.final_epsilon;
    standard_metrics.converged = res_std.converged;

    // Primeiro executa com iterações suficientes para construir a curva L
    ReconstructionResult res_std_initial =
        run_cgnr_solver_fixed_iter(g_std, H_std, initial_iterations);

    // Encontra o ponto ótimo na curva L
    int optimal_iter = find_l_curve_corner(res_std_initial.residual_history,
                                           res_std_initial.solution_history);
    std::filesystem::path hist_path_std =
        output_dir /
        ("convergence_history_" + base_filename + "_sparse_standard.csv");
    std::filesystem::path lcurve_path_std =
        output_dir / ("lcurve_" + base_filename + "_sparse_standard.csv");
    saveHistoryToCSV(res_std_initial, hist_path_std.string());
    saveLcurveToCSV(res_std_initial, lcurve_path_std.string());

    // Executa novamente com o número ótimo de iterações
    std::cout << "[INFO] Ponto otimo da curva L encontrado na iteracao "
              << optimal_iter << std::endl;
    ReconstructionResult res_std_optimal =
        run_cgnr_solver_fixed_iter(g_std, H_std, optimal_iter);
  } catch (const std::exception &e) {
    std::cerr << "[ERRO - Esparso Padrao] " << e.what() << std::endl;
    standard_metrics = PerformanceMetrics();
    standard_metrics.optimization_type = "standard";
  }

  // --- Teste 2: CGNR Pré-condicionado ---
  try {
    std::cout << "\n--- Rodando CGNR Esparso Pre-condicionado (Binario) ---\n";
    auto start_load = std::chrono::high_resolution_clock::now();
    Eigen::SparseMatrix<double> H_pre =
        loadSparseMatrix(sparse_bin_fs_path.string());
    // **** CORREÇÃO: g_signal_path -> g_signal_csv ****
    Eigen::VectorXd g_pre = loadVectorData(config.g_signal_csv);
    auto end_load = std::chrono::high_resolution_clock::now();
    precond_metrics.load_time_ms =
        std::chrono::duration<double, std::milli>(end_load - start_load)
            .count();
    precond_metrics.estimated_ram_mb =
        static_cast<double>(H_pre.nonZeros() * (sizeof(double) + sizeof(int)) +
                            (H_pre.outerSize() + 1) * sizeof(int)) /
        (1024.0 * 1024.0);

    normalize_system_rows(H_pre, g_pre);
    Eigen::VectorXd z0_pre = H_pre.transpose() * g_pre;
    std::cout << "[DEBUG Precond] Norma de z0 (H^T * g norm): " << z0_pre.norm()
              << std::endl;

    std::string filename_prefix_pre =
        "image_" + base_filename + "_sparse_precond";
    ReconstructionResult res_pre = run_cgnr_solver_preconditioned_save_iters(
        g_pre, H_pre, epsilon_tolerance, max_iterations, filename_prefix_pre,
        output_dir.string(), config.image_rows, config.image_cols,
        settings.save_intermediate_images);

    precond_metrics.solve_time_ms = res_pre.execution_time_ms;
    precond_metrics.iterations = res_pre.iterations;
    precond_metrics.final_error = res_pre.final_error;
    precond_metrics.final_epsilon = res_pre.final_epsilon;
    precond_metrics.converged = res_pre.converged;

    // **** CORREÇÃO: g_signal_path -> g_signal_csv ****
    // Primeiro executa com iterações suficientes para construir a curva L
    ReconstructionResult res_pre_initial =
        run_cgnr_solver_fixed_iter(g_pre, H_pre, initial_iterations);

    // Encontra o ponto ótimo na curva L
    int optimal_iter_pre = find_l_curve_corner(
        res_pre_initial.residual_history, res_pre_initial.solution_history);
    std::cout << "[INFO] Ponto otimo da curva L (precondicionado) encontrado "
                 "na iteracao "
              << optimal_iter_pre << std::endl;

    // Executa novamente com o número ótimo de iterações
    ReconstructionResult res_pre_optimal =
        run_cgnr_solver_fixed_iter(g_pre, H_pre, optimal_iter_pre);
    std::filesystem::path hist_path_pre =
        output_dir /
        ("convergence_history_" + base_filename + "_sparse_precond.csv");
    // **** CORREÇÃO: Typo "lcurve_"to_string() ****
    std::filesystem::path lcurve_path_pre =
        output_dir / ("lcurve_" + base_filename + "_sparse_precond.csv");
    saveHistoryToCSV(res_pre_initial, hist_path_pre.string());
    saveLcurveToCSV(res_pre_initial, lcurve_path_pre.string());
  } catch (const std::exception &e) {
    std::cerr << "[ERRO - Esparso Precondicionado] " << e.what() << std::endl;
    precond_metrics = PerformanceMetrics();
    precond_metrics.optimization_type = "jacobi";
  }

  return {standard_metrics, precond_metrics};
}

// --- Criação de Diretórios de Saída ---
inline void create_output_directories(const std::filesystem::path &output_dir) {
  auto images_dir = output_dir / "images";
  auto metrics_dir = output_dir / "metrics";
  auto lcurve_dir = output_dir / "lcurve";

  std::filesystem::create_directories(images_dir);
  std::filesystem::create_directories(metrics_dir);
  std::filesystem::create_directories(lcurve_dir);

  std::cout << "[INFO] Diretorios de saida criados:" << std::endl;
  std::cout << "  - Imagens: " << images_dir << std::endl;
  std::cout << "  - Metricas: " << metrics_dir << std::endl;
  std::cout << "  - Curvas L: " << lcurve_dir << std::endl;
}

inline void save_iteration_image(const Eigen::VectorXd &vec,
                                 const std::filesystem::path &output_dir,
                                 const std::string &base_filename_prefix,
                                 int iteration, int img_rows, int img_cols) {
  auto images_dir = output_dir / "images";
  std::filesystem::create_directories(images_dir);
  std::filesystem::path iter_img_path =
      images_dir /
      (base_filename_prefix + "_iter_" + std::to_string(iteration) + ".csv");
  saveImageVectorToCsv(vec, iter_img_path.string(), img_rows, img_cols);
}

inline void save_convergence_data(const ReconstructionResult &result,
                                  const std::filesystem::path &output_dir,
                                  const std::string &base_filename) {
  auto metrics_dir = output_dir / "metrics";
  auto lcurve_dir = output_dir / "lcurve";

  std::filesystem::create_directories(metrics_dir);
  std::filesystem::create_directories(lcurve_dir);

  const std::filesystem::path hist_path =
      metrics_dir / ("convergence_history_" + base_filename + ".csv");
  const std::filesystem::path lcurve_path =
      lcurve_dir / ("lcurve_" + base_filename + ".csv");

  saveHistoryToCSV(result, hist_path.string());
  saveLcurveToCSV(result, lcurve_path.string());
}
#endif // ULTRASOUNDSERVER_SOLVER_COMPARISON_HPP
```

## arquivo debug.py
```python
# python
import os
import sys
import inspect

def _caller_dir():
    # percorre a pilha e retorna a primeira filename diferente deste arquivo
    this = os.path.abspath(__file__)
    for frame_info in inspect.stack()[1:]:
        fn = os.path.abspath(frame_info.filename)
        if fn != this:
            return os.path.dirname(fn)
    # fallback
    return os.path.dirname(os.path.abspath(sys.argv[0])) if sys.argv and sys.argv[0] else os.getcwd()

def debug_files(which='module'):
    """
    which: 'module' -> pasta deste módulo (`debug.py`)
           'caller' -> pasta do arquivo que chamou esta função
           'cwd'    -> diretório de trabalho atual
    """
    if which == 'module':
        script_dir = os.path.dirname(os.path.abspath(__file__))
    elif which == 'caller':
        script_dir = _caller_dir()
    elif which == 'cwd':
        script_dir = os.getcwd()
    else:
        raise ValueError("which must be 'module', 'caller' or 'cwd'")

    print(f"Rodando a partir da pasta: {script_dir}")
    print("Arquivos:")
    for f in os.listdir(script_dir):
        print(" -", f)


if __name__ == "__main__":
    debug_files()
```

## arquivo combine_animations.py
```python
import imageio
import numpy as np
from pathlib import Path
import argparse

def resample_frames(frames, target_count):
    """Reamostra uma lista de frames para um número alvo de frames."""
    if not frames:
        return []

    resampled = []
    ratio = len(frames) / target_count
    for i in range(target_count):
        original_index = int(i * ratio)
        # Garante que o índice não saia dos limites
        original_index = min(original_index, len(frames) - 1)
        resampled.append(frames[original_index])
    return resampled

def combine_animations(precond_path, standard_path, output_path, duration_per_gif=10, fps=10):
    """Combina duas animações GIF em uma só, reamostrando os frames para que cada parte dure o tempo especificado."""
    try:
        # Carrega os dois GIFs
        reader_precond = imageio.get_reader(precond_path)
        reader_standard = imageio.get_reader(standard_path)

        # Pega os frames de cada GIF
        frames_precond = [reader_precond.get_data(i) for i in range(len(reader_precond))]
        frames_standard = [reader_standard.get_data(i) for i in range(len(reader_standard))]

        if not frames_precond or not frames_standard:
            print("[ERRO] Um dos GIFs de entrada está vazio ou não pôde ser lido.")
            return

        # Calcula o número de frames necessários para cada parte para atingir a duração desejada com o FPS alvo
        target_frames_per_part = int(duration_per_gif * fps)

        # Reamostra os frames de cada animação
        resampled_precond = resample_frames(frames_precond, target_frames_per_part)
        resampled_standard = resample_frames(frames_standard, target_frames_per_part)

        # Concatena os frames reamostrados
        combined_frames = resampled_precond + resampled_standard

        # Salva o novo GIF com um FPS constante
        imageio.mimsave(output_path, combined_frames, fps=fps)
        print(f"[SUCESSO] Animação combinada salva em: {output_path}")

    except FileNotFoundError as e:
        print(f"[ERRO] Arquivo não encontrado: {e}. Verifique os caminhos.")
    except Exception as e:
        print(f"[ERRO] Falha ao combinar animações: {e}")

def main():
    parser = argparse.ArgumentParser(
        description="Combina as animações 'precond' e 'standard' em um único GIF."
    )
    parser.add_argument(
        "animations_folder",
        type=str,
        help="Caminho para a pasta contendo as animações (ex: output_csv/animations)."
    )
    parser.add_argument(
        "base_name",
        type=str,
        help="Nome base dos arquivos a serem combinados (ex: image_30x30_g1_sparse)."
    )
    args = parser.parse_args()

    animations_folder = Path(args.animations_folder)
    precond_gif = animations_folder / f"{args.base_name}_precond_animation.gif"
    standard_gif = animations_folder / f"{args.base_name}_standard_animation.gif"
    combined_gif = animations_folder / f"{args.base_name}_combined_animation.gif"

    print("--- Combinador de Animações ---")
    combine_animations(precond_gif, standard_gif, combined_gif)

if __name__ == "__main__":
    main()
```

## arquivo plot_convergence.py
```python
import argparse
import glob
import os
from pathlib import Path

import matplotlib.pyplot as plt
import numpy as np


def plot_convergence(metrics_folder, base_names):
    """Plota as curvas de convergência para um ou mais resultados."""
    plt.style.use('seaborn-v0_8-whitegrid')
    fig, ax = plt.subplots(figsize=(12, 8))

    if not base_names:
        # Se nenhum nome base for fornecido, encontra todos os arquivos de histórico
        search_pattern = os.path.join(metrics_folder, "convergence_history_*.csv")
        all_files = glob.glob(search_pattern)
        if not all_files:
            print("[AVISO] Nenhum arquivo 'convergence_history_*.csv' encontrado na pasta de métricas.")
            return

        # Extrai os nomes dos testes para a legenda
        labels = ['_'.join(Path(f).stem.split('_')[2:]) for f in all_files]
        files_to_plot = all_files
    else:
        # Monta os caminhos dos arquivos a partir dos nomes base
        files_to_plot = [os.path.join(metrics_folder, f"convergence_history_{name}.csv") for name in base_names]
        labels = base_names

    for i, file_path in enumerate(files_to_plot):
        try:
            # Carrega os dados: Iteration,ResidualNorm,SolutionNorm,ExecutionTime_ms
            data = np.loadtxt(file_path, delimiter=',', skiprows=1)
            iterations = data[:, 0]
            residual_norm = data[:, 1]

            # Usa o nome do arquivo (sem prefixo/sufixo) como legenda
            label = labels[i]
            ax.plot(iterations, residual_norm, marker='o', linestyle='-', markersize=4, label=label)

        except Exception as e:
            print(f"[AVISO] Não foi possível processar o arquivo '{file_path}': {e}")
            continue

    ax.set_yscale('log')
    ax.set_title('Curva de Convergência (Norma do Resíduo)', fontsize=16)
    ax.set_xlabel('Iteração', fontsize=12)
    ax.set_ylabel('Norma do Resíduo (log)', fontsize=12)
    ax.legend(fontsize=10)
    ax.grid(True, which="both", ls="--")

    # Salva o gráfico
    output_path = Path(metrics_folder).parent / "convergence_plot.png"
    plt.savefig(output_path, dpi=300, bbox_inches='tight')

    print(f"\n[SUCESSO] Gráfico de convergência salvo em: {output_path}")
    plt.show()


def main():
    parser = argparse.ArgumentParser(
        description="Plota as curvas de convergência a partir dos arquivos de histórico gerados pelo benchmark."
    )
    parser.add_argument(
        "metrics_folder",
        type=str,
        help="Caminho para a pasta contendo os arquivos CSV de métricas (ex: ../output_csv/metrics)."
    )
    parser.add_argument(
        "base_name",
        nargs='*',
        help="Nomes base dos resultados a serem plotados (ex: 30x30_g1_sparse_standard). Se omitido, plota todos."
    )
    args = parser.parse_args()

    plot_convergence(args.metrics_folder, args.base_name)


if __name__ == "__main__":
    print("--- Plotter de Curva de Convergência ---")
    print("Requer: pip install matplotlib numpy")
    main()

```

## arquivo visualize_iterations.py
```python
import argparse
import glob
import os
from pathlib import Path

import imageio
import matplotlib.pyplot as plt
import numpy as np


def create_animation(image_folder, base_name, output_folder):
    """Gera um GIF animado a partir de uma sequência de imagens CSV."""
    print(f"\nProcessando: {base_name}")
    search_pattern = f"{base_name}_iter_*.csv"
    file_paths = sorted(
        glob.glob(os.path.join(image_folder, search_pattern)),
        key=lambda x: int(Path(x).stem.split('_')[-1])
    )

    if not file_paths:
        print(f"  [AVISO] Nenhum arquivo de imagem encontrado para '{base_name}'. Pulando.")
        return

    images = []
    solver_type = base_name.split('_')[-1]  # Extrai 'precond' ou 'standard'

    for i, file_path in enumerate(file_paths):
        try:
            # Carrega a imagem CSV e a remodela
            img_data = np.loadtxt(file_path, delimiter=',')

            # Cria o plot
            fig, ax = plt.subplots(figsize=(6, 6))
            fig.suptitle(solver_type.capitalize(), fontsize=16)
            im = ax.imshow(img_data, cmap='viridis', vmin=np.min(img_data), vmax=np.max(img_data))
            ax.set_title(f"Iteração {i}")
            ax.set_xlabel("X")
            ax.set_ylabel("Y")

            # Adiciona uma colorbar para referência de intensidade
            fig.colorbar(im, ax=ax, orientation='vertical', fraction=0.046, pad=0.04)

            # Converte o plot para uma imagem em memória
            fig.canvas.draw()
            image_buffer = fig.canvas.buffer_rgba()
            image = np.frombuffer(image_buffer, dtype='uint8')
            image = image.reshape(fig.canvas.get_width_height()[::-1] + (4,))
            images.append(image[:, :, :3]) # Converte de RGBA para RGB
            plt.close(fig)

        except Exception as e:
            print(f"  [ERRO] Falha ao processar {file_path}: {e}")
            continue

    if not images:
        print(f"  [ERRO] Nenhuma imagem pôde ser gerada para '{base_name}'.")
        return

    # Salva o GIF
    output_path = os.path.join(output_folder, f"{base_name}_animation.gif")
    try:
        imageio.mimsave(output_path, images, fps=5)
        print(f"  [SUCESSO] Animação salva em: {output_path}")
    except Exception as e:
        print(f"  [ERRO] Falha ao salvar o GIF em {output_path}: {e}")


def main():
    parser = argparse.ArgumentParser(
        description="Cria animações GIF a partir dos CSVs de iteração gerados pelo benchmark."
    )
    parser.add_argument(
        "image_folder",
        type=str,
        help="Caminho para a pasta contendo os arquivos CSV das imagens (ex: ../output_csv/images)."
    )
    parser.add_argument(
        "base_name",
        nargs='*',
        help="Nomes base para agrupar as imagens (ex: image_30x30_g1_sparse_standard). Se omitido, processa todos."
    )
    args = parser.parse_args()

    output_folder = Path(args.image_folder).parent / "animations"
    output_folder.mkdir(exist_ok=True)
    print(f"Pasta de saída para animações: {output_folder}")

    if not args.base_name:
        # Encontra todos os prefixos únicos na pasta
        all_files = glob.glob(os.path.join(args.image_folder, "*_iter_*.csv"))
        base_names = sorted(list(set('_'.join(Path(f).stem.split('_')[:-2]) for f in all_files)))
        if not base_names:
            print("[AVISO] Nenhum arquivo de iteração encontrado na pasta especificada.")
            return
    else:
        base_names = args.base_name

    for name in base_names:
        create_animation(args.image_folder, name, output_folder)


if __name__ == "__main__":
    print("--- Gerador de Animação de Iterações ---")
    print("Requer: pip install imageio matplotlib numpy")
    main()
```

## arquivo config.yaml
```yaml
# config.yaml

# Configurações Globais do Benchmark
settings:
  output_base_dir: "output_csv" # Diretório base relativo ao diretório de build
  epsilon_tolerance: 1.0e-4
  max_iterations: 10
  save_intermediate_images: true # true para salvar imagem a cada iteração, false para salvar só a final
  num_omp_threads: 8 # 0 para usar o máximo padrão do OpenMP, ou especifique um número

# Definição dos Conjuntos de Teste Disponíveis
datasets:
  - name: "60x60_G1"
    description: "60x60 (Sinal G-1)"
    h_matrix_csv: "data/H-1.csv"
    g_signal_csv: "data/G-1.csv"
    image_rows: 60
    image_cols: 60

  - name: "60x60_G2"
    description: "60x60 (Sinal G-2)"
    h_matrix_csv: "data/H-1.csv"
    g_signal_csv: "data/G-2.csv"
    image_rows: 60
    image_cols: 60

  - name: "60x60_A1"
    description: "60x60 (Sinal A-1)"
    h_matrix_csv: "data/H-1.csv"
    g_signal_csv: "data/A-1.csv"
    image_rows: 60
    image_cols: 60

  - name: "30x30_g1"
    description: "30x30 (Sinal g-1)"
    h_matrix_csv: "data/H-2.csv"
    g_signal_csv: "data/g-30x30-1.csv"
    image_rows: 30
    image_cols: 30

  - name: "30x30_g2"
    description: "30x30 (Sinal g-2)"
    h_matrix_csv: "data/H-2.csv"
    g_signal_csv: "data/g-30x30-2.csv"
    image_rows: 30
    image_cols: 30

  - name: "30x30_A1"
    description: "30x30 (Sinal A-1)"
    h_matrix_csv: "data/H-2.csv"
    g_signal_csv: "data/A-1.csv"
    image_rows: 30
    image_cols: 30

# Definição dos Métodos de Reconstrução a serem testados
methods:
  - name: "sparse_standard"
    description: "CGNR esparso padrao"
    solver: "cgnr_standard"
    use_binary: true
    is_baseline: true

  - name: "sparse_jacobi"
    description: "CGNR esparso com pre-condicionador Jacobi"
    solver: "cgnr_jacobi"
    use_binary: true
    is_baseline: false

# Quais comparações/pipelines executar
run_pipelines:
  - name: "Sparse_Comparison"
    description: "Compara os metodos esparsos CGNR e Jacobi"
    methods:
      - "sparse_standard"
      - "sparse_jacobi"
    datasets:
      - "30x30_g1"
      - "30x30_g2"
      - "60x60_G1"
      - "60x60_G2"
      - "60x60_A1"
      - "30x30_A1"
```

## arquivo H-large.csv
```csv
Dummy CSV for H-large. See .dense.bin
```

## arquivo H-parse.csv
```csv
Dummy
```

## arquivo convergence_history_30x30_g1_sparse_precond.csv
```csv
Iteration,ResidualNorm,SolutionNorm,ExecutionTime_ms
1, 9.67196382e+00, 0.00000000e+00, 414.23
2, 3.07252139e+00, 1.55898777e+00, 414.23
3, 1.53729417e+00, 1.77603493e+00, 414.23
4, 1.39883468e+00, 1.79399258e+00, 414.23
5, 1.01019361e+00, 1.84883524e+00, 414.23
6, 8.97468112e-01, 1.86481978e+00, 414.23
7, 8.68404273e-01, 1.86894946e+00, 414.23
8, 6.28412797e-01, 1.90461444e+00, 414.23
9, 5.59264782e-01, 1.91467888e+00, 414.23
10, 5.30052585e-01, 1.91887859e+00, 414.23
11, 4.97479833e-01, 1.92355181e+00, 414.23
12, 4.14268921e-01, 1.93544815e+00, 414.23
13, 3.65674578e-01, 1.94220317e+00, 414.23
14, 3.29254234e-01, 1.94721209e+00, 414.23
15, 3.03495583e-01, 1.95075872e+00, 414.23
16, 2.78732101e-01, 1.95419823e+00, 414.23
17, 2.68664181e-01, 1.95561550e+00, 414.23
18, 2.46373566e-01, 1.95882596e+00, 414.23
19, 2.25538000e-01, 1.96191567e+00, 414.23
20, 2.05668964e-01, 1.96495649e+00, 414.23
21, 1.96093519e-01, 1.96645522e+00, 414.23
22, 1.85659999e-01, 1.96812171e+00, 414.23
23, 1.73864957e-01, 1.97005770e+00, 414.23
24, 1.63240358e-01, 1.97185532e+00, 414.23
25, 1.51970632e-01, 1.97383060e+00, 414.23
26, 1.48852344e-01, 1.97438909e+00, 414.23
27, 1.37982239e-01, 1.97638024e+00, 414.23
28, 1.32656763e-01, 1.97737932e+00, 414.23
29, 1.25749048e-01, 1.97870045e+00, 414.23
30, 1.23607305e-01, 1.97911473e+00, 414.23
31, 1.14523371e-01, 1.98090328e+00, 414.23
32, 1.05095830e-01, 1.98280764e+00, 414.23
33, 1.00734155e-01, 1.98370216e+00, 414.23
34, 9.27383430e-02, 1.98536222e+00, 414.23
35, 8.60193691e-02, 1.98676886e+00, 414.23
36, 8.39698276e-02, 1.98719857e+00, 414.23
37, 7.80321740e-02, 1.98844424e+00, 414.23
38, 7.32812572e-02, 1.98943704e+00, 414.23
39, 6.74433522e-02, 1.99064716e+00, 414.23
40, 6.44618592e-02, 1.99125831e+00, 414.23
41, 6.15617841e-02, 1.99184752e+00, 414.23
42, 5.77193876e-02, 1.99261786e+00, 414.23
43, 5.69357620e-02, 1.99277308e+00, 414.23
44, 5.17399209e-02, 1.99378588e+00, 414.23
45, 4.77952867e-02, 1.99453063e+00, 414.23
46, 4.13555914e-02, 1.99568957e+00, 414.23
47, 4.05709750e-02, 1.99582484e+00, 414.23
48, 3.69892680e-02, 1.99642400e+00, 414.23
49, 3.31973231e-02, 1.99702200e+00, 414.23
50, 3.12226361e-02, 1.99731703e+00, 414.23
```

## arquivo convergence_history_30x30_g1_sparse_standard.csv
```csv
Iteration,ResidualNorm,SolutionNorm,ExecutionTime_ms
1, 9.67196382e+00, 0.00000000e+00, 414.45
2, 3.07252139e+00, 1.55898777e+00, 414.45
3, 1.53729417e+00, 1.77603493e+00, 414.45
4, 1.39883468e+00, 1.79399258e+00, 414.45
5, 1.01019361e+00, 1.84883524e+00, 414.45
6, 8.97468112e-01, 1.86481978e+00, 414.45
7, 8.68404273e-01, 1.86894946e+00, 414.45
8, 6.28412797e-01, 1.90461444e+00, 414.45
9, 5.59264782e-01, 1.91467888e+00, 414.45
10, 5.30052585e-01, 1.91887859e+00, 414.45
11, 4.97479833e-01, 1.92355181e+00, 414.45
12, 4.14268921e-01, 1.93544815e+00, 414.45
13, 3.65674578e-01, 1.94220317e+00, 414.45
14, 3.29254234e-01, 1.94721209e+00, 414.45
15, 3.03495583e-01, 1.95075872e+00, 414.45
16, 2.78732101e-01, 1.95419823e+00, 414.45
17, 2.68664181e-01, 1.95561550e+00, 414.45
18, 2.46373566e-01, 1.95882596e+00, 414.45
19, 2.25538000e-01, 1.96191567e+00, 414.45
20, 2.05668964e-01, 1.96495649e+00, 414.45
21, 1.96093519e-01, 1.96645522e+00, 414.45
22, 1.85659999e-01, 1.96812171e+00, 414.45
23, 1.73864957e-01, 1.97005770e+00, 414.45
24, 1.63240358e-01, 1.97185532e+00, 414.45
25, 1.51970632e-01, 1.97383060e+00, 414.45
26, 1.48852344e-01, 1.97438909e+00, 414.45
27, 1.37982239e-01, 1.97638024e+00, 414.45
28, 1.32656763e-01, 1.97737932e+00, 414.45
29, 1.25749048e-01, 1.97870045e+00, 414.45
30, 1.23607305e-01, 1.97911473e+00, 414.45
31, 1.14523371e-01, 1.98090328e+00, 414.45
32, 1.05095830e-01, 1.98280764e+00, 414.45
33, 1.00734155e-01, 1.98370216e+00, 414.45
34, 9.27383430e-02, 1.98536222e+00, 414.45
35, 8.60193691e-02, 1.98676886e+00, 414.45
36, 8.39698276e-02, 1.98719857e+00, 414.45
37, 7.80321740e-02, 1.98844424e+00, 414.45
38, 7.32812572e-02, 1.98943704e+00, 414.45
39, 6.74433522e-02, 1.99064716e+00, 414.45
40, 6.44618592e-02, 1.99125831e+00, 414.45
41, 6.15617841e-02, 1.99184752e+00, 414.45
42, 5.77193876e-02, 1.99261786e+00, 414.45
43, 5.69357620e-02, 1.99277308e+00, 414.45
44, 5.17399209e-02, 1.99378588e+00, 414.45
45, 4.77952867e-02, 1.99453063e+00, 414.45
46, 4.13555914e-02, 1.99568957e+00, 414.45
47, 4.05709750e-02, 1.99582484e+00, 414.45
48, 3.69892680e-02, 1.99642400e+00, 414.45
49, 3.31973231e-02, 1.99702200e+00, 414.45
50, 3.12226361e-02, 1.99731703e+00, 414.45
```

## arquivo convergence_history_30x30_g2_sparse_precond.csv
```csv
Iteration,ResidualNorm,SolutionNorm,ExecutionTime_ms
1, 1.20736878e+01, 0.00000000e+00, 389.64
2, 4.02351777e+00, 1.87462201e+00, 389.64
3, 3.65398977e+00, 1.92042055e+00, 389.64
4, 2.89073698e+00, 2.02751235e+00, 389.64
5, 2.36115773e+00, 2.10462469e+00, 389.64
6, 1.84100587e+00, 2.17845004e+00, 389.64
7, 1.65829698e+00, 2.20365158e+00, 389.64
8, 1.52680971e+00, 2.22203672e+00, 389.64
9, 1.29867800e+00, 2.25500822e+00, 389.64
10, 1.04314309e+00, 2.29328838e+00, 389.64
11, 9.52876436e-01, 2.30689009e+00, 389.64
12, 8.36827460e-01, 2.32457823e+00, 389.64
13, 7.05063906e-01, 2.34472561e+00, 389.64
14, 6.21843740e-01, 2.35726912e+00, 389.64
15, 5.42210316e-01, 2.36910719e+00, 389.64
16, 4.71904883e-01, 2.37946642e+00, 389.64
17, 4.22139493e-01, 2.38676801e+00, 389.64
18, 3.79399672e-01, 2.39307923e+00, 389.64
19, 3.47102850e-01, 2.39790904e+00, 389.64
20, 3.23602566e-01, 2.40146776e+00, 389.64
21, 2.91820472e-01, 2.40635206e+00, 389.64
22, 2.66636569e-01, 2.41026993e+00, 389.64
23, 2.50468187e-01, 2.41281187e+00, 389.64
24, 2.42540978e-01, 2.41406651e+00, 389.64
25, 2.26735977e-01, 2.41658517e+00, 389.64
26, 2.15403395e-01, 2.41840525e+00, 389.64
27, 2.09439014e-01, 2.41936889e+00, 389.64
28, 1.96883253e-01, 2.42141240e+00, 389.64
29, 1.79024616e-01, 2.42434817e+00, 389.64
30, 1.62278098e-01, 2.42713125e+00, 389.64
31, 1.49359351e-01, 2.42929646e+00, 389.64
32, 1.40612539e-01, 2.43076747e+00, 389.64
33, 1.28604897e-01, 2.43279226e+00, 389.64
34, 1.23590971e-01, 2.43363739e+00, 389.64
35, 1.17413038e-01, 2.43467614e+00, 389.64
36, 1.06360514e-01, 2.43652404e+00, 389.64
37, 9.82513480e-02, 2.43786257e+00, 389.64
38, 9.44520797e-02, 2.43848301e+00, 389.64
39, 8.92032748e-02, 2.43933224e+00, 389.64
40, 8.16144141e-02, 2.44054084e+00, 389.64
41, 7.80644355e-02, 2.44109713e+00, 389.64
42, 7.34411349e-02, 2.44181197e+00, 389.64
43, 6.70947154e-02, 2.44277183e+00, 389.64
44, 6.43651366e-02, 2.44317600e+00, 389.64
45, 6.20965302e-02, 2.44350750e+00, 389.64
46, 5.68552688e-02, 2.44425717e+00, 389.64
47, 5.16576625e-02, 2.44497562e+00, 389.64
48, 4.66946130e-02, 2.44563559e+00, 389.64
49, 4.23960938e-02, 2.44618314e+00, 389.64
50, 3.81925719e-02, 2.44669296e+00, 389.64
```

## arquivo convergence_history_30x30_g2_sparse_standard.csv
```csv
Iteration,ResidualNorm,SolutionNorm,ExecutionTime_ms
1, 1.20736878e+01, 0.00000000e+00, 377.43
2, 4.02351777e+00, 1.87462201e+00, 377.43
3, 3.65398977e+00, 1.92042055e+00, 377.43
4, 2.89073698e+00, 2.02751235e+00, 377.43
5, 2.36115773e+00, 2.10462469e+00, 377.43
6, 1.84100587e+00, 2.17845004e+00, 377.43
7, 1.65829698e+00, 2.20365158e+00, 377.43
8, 1.52680971e+00, 2.22203672e+00, 377.43
9, 1.29867800e+00, 2.25500822e+00, 377.43
10, 1.04314309e+00, 2.29328838e+00, 377.43
11, 9.52876436e-01, 2.30689009e+00, 377.43
12, 8.36827460e-01, 2.32457823e+00, 377.43
13, 7.05063906e-01, 2.34472561e+00, 377.43
14, 6.21843740e-01, 2.35726912e+00, 377.43
15, 5.42210316e-01, 2.36910719e+00, 377.43
16, 4.71904883e-01, 2.37946642e+00, 377.43
17, 4.22139493e-01, 2.38676801e+00, 377.43
18, 3.79399672e-01, 2.39307923e+00, 377.43
19, 3.47102850e-01, 2.39790904e+00, 377.43
20, 3.23602566e-01, 2.40146776e+00, 377.43
21, 2.91820472e-01, 2.40635206e+00, 377.43
22, 2.66636569e-01, 2.41026993e+00, 377.43
23, 2.50468187e-01, 2.41281187e+00, 377.43
24, 2.42540978e-01, 2.41406651e+00, 377.43
25, 2.26735977e-01, 2.41658517e+00, 377.43
26, 2.15403395e-01, 2.41840525e+00, 377.43
27, 2.09439014e-01, 2.41936889e+00, 377.43
28, 1.96883253e-01, 2.42141240e+00, 377.43
29, 1.79024616e-01, 2.42434817e+00, 377.43
30, 1.62278098e-01, 2.42713125e+00, 377.43
31, 1.49359351e-01, 2.42929646e+00, 377.43
32, 1.40612539e-01, 2.43076747e+00, 377.43
33, 1.28604897e-01, 2.43279226e+00, 377.43
34, 1.23590971e-01, 2.43363739e+00, 377.43
35, 1.17413038e-01, 2.43467614e+00, 377.43
36, 1.06360514e-01, 2.43652404e+00, 377.43
37, 9.82513480e-02, 2.43786257e+00, 377.43
38, 9.44520797e-02, 2.43848301e+00, 377.43
39, 8.92032748e-02, 2.43933224e+00, 377.43
40, 8.16144141e-02, 2.44054084e+00, 377.43
41, 7.80644355e-02, 2.44109713e+00, 377.43
42, 7.34411349e-02, 2.44181197e+00, 377.43
43, 6.70947154e-02, 2.44277183e+00, 377.43
44, 6.43651366e-02, 2.44317600e+00, 377.43
45, 6.20965302e-02, 2.44350750e+00, 377.43
46, 5.68552688e-02, 2.44425717e+00, 377.43
47, 5.16576625e-02, 2.44497562e+00, 377.43
48, 4.66946130e-02, 2.44563559e+00, 377.43
49, 4.23960938e-02, 2.44618314e+00, 377.43
50, 3.81925719e-02, 2.44669296e+00, 377.43
```

## arquivo convergence_history_60x60_G1_sparse_precond.csv
```csv
Iteration,ResidualNorm,SolutionNorm,ExecutionTime_ms
1, 1.54640017e+01, 0.00000000e+00, 1779.16
2, 6.17186055e+00, 2.95333226e+00, 1779.16
3, 3.55670287e+00, 3.53454207e+00, 1779.16
4, 2.99761919e+00, 3.65843662e+00, 1779.16
5, 2.39219064e+00, 3.79383539e+00, 1779.16
6, 2.20794552e+00, 3.83375295e+00, 1779.16
7, 2.06309467e+00, 3.86563639e+00, 1779.16
8, 1.65101719e+00, 3.95979300e+00, 1779.16
9, 1.53108700e+00, 3.98705940e+00, 1779.16
10, 1.48873863e+00, 3.99666487e+00, 1779.16
11, 1.27397610e+00, 4.04632060e+00, 1779.16
12, 1.09950505e+00, 4.08665265e+00, 1779.16
13, 1.01686809e+00, 4.10543978e+00, 1779.16
14, 9.62496045e-01, 4.11776744e+00, 1779.16
15, 8.30742658e-01, 4.14771050e+00, 1779.16
16, 7.54658503e-01, 4.16472755e+00, 1779.16
17, 6.97633203e-01, 4.17736234e+00, 1779.16
18, 6.09044074e-01, 4.19699293e+00, 1779.16
19, 5.74370142e-01, 4.20463616e+00, 1779.16
20, 5.47074792e-01, 4.21067073e+00, 1779.16
21, 4.93735822e-01, 4.22259198e+00, 1779.16
22, 4.60063338e-01, 4.23017365e+00, 1779.16
23, 4.36327929e-01, 4.23556708e+00, 1779.16
24, 4.22122183e-01, 4.23882770e+00, 1779.16
25, 4.07458113e-01, 4.24221920e+00, 1779.16
26, 3.86592624e-01, 4.24709560e+00, 1779.16
27, 3.67773193e-01, 4.25156603e+00, 1779.16
28, 3.51352487e-01, 4.25554085e+00, 1779.16
29, 3.37303201e-01, 4.25900523e+00, 1779.16
30, 3.32705820e-01, 4.26015230e+00, 1779.16
31, 3.16792358e-01, 4.26419592e+00, 1779.16
32, 3.02864662e-01, 4.26783713e+00, 1779.16
33, 2.92696259e-01, 4.27056620e+00, 1779.16
34, 2.79480043e-01, 4.27422411e+00, 1779.16
35, 2.69498835e-01, 4.27707327e+00, 1779.16
36, 2.60982189e-01, 4.27956963e+00, 1779.16
37, 2.55407974e-01, 4.28123787e+00, 1779.16
38, 2.44748328e-01, 4.28450471e+00, 1779.16
39, 2.34985558e-01, 4.28758357e+00, 1779.16
40, 2.24014319e-01, 4.29114831e+00, 1779.16
41, 2.20511592e-01, 4.29230893e+00, 1779.16
42, 2.15047233e-01, 4.29414141e+00, 1779.16
43, 2.10788939e-01, 4.29558664e+00, 1779.16
44, 2.00735989e-01, 4.29905867e+00, 1779.16
45, 1.88971778e-01, 4.30321700e+00, 1779.16
46, 1.78014403e-01, 4.30716195e+00, 1779.16
47, 1.71872318e-01, 4.30939586e+00, 1779.16
48, 1.68601238e-01, 4.31059084e+00, 1779.16
49, 1.59768365e-01, 4.31382943e+00, 1779.16
50, 1.53117654e-01, 4.31627224e+00, 1779.16
```

## arquivo convergence_history_60x60_G1_sparse_standard.csv
```csv
Iteration,ResidualNorm,SolutionNorm,ExecutionTime_ms
1, 1.54640017e+01, 0.00000000e+00, 1815.83
2, 6.17186055e+00, 2.95333226e+00, 1815.83
3, 3.55670287e+00, 3.53454207e+00, 1815.83
4, 2.99761919e+00, 3.65843662e+00, 1815.83
5, 2.39219064e+00, 3.79383539e+00, 1815.83
6, 2.20794552e+00, 3.83375295e+00, 1815.83
7, 2.06309467e+00, 3.86563639e+00, 1815.83
8, 1.65101719e+00, 3.95979300e+00, 1815.83
9, 1.53108700e+00, 3.98705940e+00, 1815.83
10, 1.48873863e+00, 3.99666487e+00, 1815.83
11, 1.27397610e+00, 4.04632060e+00, 1815.83
12, 1.09950505e+00, 4.08665265e+00, 1815.83
13, 1.01686809e+00, 4.10543978e+00, 1815.83
14, 9.62496045e-01, 4.11776744e+00, 1815.83
15, 8.30742658e-01, 4.14771050e+00, 1815.83
16, 7.54658503e-01, 4.16472755e+00, 1815.83
17, 6.97633203e-01, 4.17736234e+00, 1815.83
18, 6.09044074e-01, 4.19699293e+00, 1815.83
19, 5.74370142e-01, 4.20463616e+00, 1815.83
20, 5.47074792e-01, 4.21067073e+00, 1815.83
21, 4.93735822e-01, 4.22259198e+00, 1815.83
22, 4.60063338e-01, 4.23017365e+00, 1815.83
23, 4.36327929e-01, 4.23556708e+00, 1815.83
24, 4.22122183e-01, 4.23882770e+00, 1815.83
25, 4.07458113e-01, 4.24221920e+00, 1815.83
26, 3.86592624e-01, 4.24709560e+00, 1815.83
27, 3.67773193e-01, 4.25156603e+00, 1815.83
28, 3.51352487e-01, 4.25554085e+00, 1815.83
29, 3.37303201e-01, 4.25900523e+00, 1815.83
30, 3.32705820e-01, 4.26015230e+00, 1815.83
31, 3.16792358e-01, 4.26419592e+00, 1815.83
32, 3.02864662e-01, 4.26783713e+00, 1815.83
33, 2.92696259e-01, 4.27056620e+00, 1815.83
34, 2.79480043e-01, 4.27422411e+00, 1815.83
35, 2.69498835e-01, 4.27707327e+00, 1815.83
36, 2.60982189e-01, 4.27956963e+00, 1815.83
37, 2.55407974e-01, 4.28123787e+00, 1815.83
38, 2.44748328e-01, 4.28450471e+00, 1815.83
39, 2.34985558e-01, 4.28758357e+00, 1815.83
40, 2.24014319e-01, 4.29114831e+00, 1815.83
41, 2.20511592e-01, 4.29230893e+00, 1815.83
42, 2.15047233e-01, 4.29414141e+00, 1815.83
43, 2.10788939e-01, 4.29558664e+00, 1815.83
44, 2.00735989e-01, 4.29905867e+00, 1815.83
45, 1.88971778e-01, 4.30321700e+00, 1815.83
46, 1.78014403e-01, 4.30716195e+00, 1815.83
47, 1.71872318e-01, 4.30939586e+00, 1815.83
48, 1.68601238e-01, 4.31059084e+00, 1815.83
49, 1.59768365e-01, 4.31382943e+00, 1815.83
50, 1.53117654e-01, 4.31627224e+00, 1815.83
```

## arquivo convergence_history_60x60_G2_sparse_precond.csv
```csv
Iteration,ResidualNorm,SolutionNorm,ExecutionTime_ms
1, 2.72014132e+01, 0.00000000e+00, 1747.03
2, 8.78975958e+00, 5.18085941e+00, 1747.03
3, 5.12351791e+00, 5.79821908e+00, 1747.03
4, 4.14430725e+00, 5.97246712e+00, 1747.03
5, 3.38780189e+00, 6.11609297e+00, 1747.03
6, 3.23059750e+00, 6.14586604e+00, 1747.03
7, 3.02412857e+00, 6.18577967e+00, 1747.03
8, 2.66597172e+00, 6.25856680e+00, 1747.03
9, 2.31106204e+00, 6.33345313e+00, 1747.03
10, 2.18561181e+00, 6.36020514e+00, 1747.03
11, 2.11826524e+00, 6.37467736e+00, 1747.03
12, 1.80702862e+00, 6.44401203e+00, 1747.03
13, 1.64602144e+00, 6.48088560e+00, 1747.03
14, 1.58552775e+00, 6.49496220e+00, 1747.03
15, 1.47557885e+00, 6.52118275e+00, 1747.03
16, 1.36978702e+00, 6.54722155e+00, 1747.03
17, 1.29300295e+00, 6.56667185e+00, 1747.03
18, 1.23487904e+00, 6.58185788e+00, 1747.03
19, 1.13326610e+00, 6.60969358e+00, 1747.03
20, 1.08815655e+00, 6.62253628e+00, 1747.03
21, 1.05133480e+00, 6.63333116e+00, 1747.03
22, 9.66160851e-01, 6.65954139e+00, 1747.03
23, 9.26190593e-01, 6.67241909e+00, 1747.03
24, 8.63703021e-01, 6.69353034e+00, 1747.03
25, 8.37768116e-01, 6.70263124e+00, 1747.03
26, 8.26667351e-01, 6.70659592e+00, 1747.03
27, 7.90428543e-01, 6.71986170e+00, 1747.03
28, 7.61820110e-01, 6.73067650e+00, 1747.03
29, 7.35038148e-01, 6.74110382e+00, 1747.03
30, 7.13673675e-01, 6.74964894e+00, 1747.03
31, 7.07278408e-01, 6.75224706e+00, 1747.03
32, 6.76311067e-01, 6.76512932e+00, 1747.03
33, 6.52025527e-01, 6.77556899e+00, 1747.03
34, 6.24402267e-01, 6.78783872e+00, 1747.03
35, 6.00520763e-01, 6.79878969e+00, 1747.03
36, 5.75033134e-01, 6.81083635e+00, 1747.03
37, 5.56581723e-01, 6.81978796e+00, 1747.03
38, 5.43583213e-01, 6.82620307e+00, 1747.03
39, 5.14613674e-01, 6.84081709e+00, 1747.03
40, 4.88693549e-01, 6.85421596e+00, 1747.03
41, 4.61734302e-01, 6.86842760e+00, 1747.03
42, 4.53434153e-01, 6.87284817e+00, 1747.03
43, 4.31372554e-01, 6.88468598e+00, 1747.03
44, 4.24927622e-01, 6.88816216e+00, 1747.03
45, 4.03899413e-01, 6.89955280e+00, 1747.03
46, 3.79463832e-01, 6.91282348e+00, 1747.03
47, 3.52241882e-01, 6.92758657e+00, 1747.03
48, 3.42441288e-01, 6.93287875e+00, 1747.03
49, 3.32917285e-01, 6.93800372e+00, 1747.03
50, 3.17716165e-01, 6.94614282e+00, 1747.03
```

## arquivo convergence_history_60x60_G2_sparse_standard.csv
```csv
Iteration,ResidualNorm,SolutionNorm,ExecutionTime_ms
1, 2.72014132e+01, 0.00000000e+00, 1831.87
2, 8.78975958e+00, 5.18085941e+00, 1831.87
3, 5.12351791e+00, 5.79821908e+00, 1831.87
4, 4.14430725e+00, 5.97246712e+00, 1831.87
5, 3.38780189e+00, 6.11609297e+00, 1831.87
6, 3.23059750e+00, 6.14586604e+00, 1831.87
7, 3.02412857e+00, 6.18577967e+00, 1831.87
8, 2.66597172e+00, 6.25856680e+00, 1831.87
9, 2.31106204e+00, 6.33345313e+00, 1831.87
10, 2.18561181e+00, 6.36020514e+00, 1831.87
11, 2.11826524e+00, 6.37467736e+00, 1831.87
12, 1.80702862e+00, 6.44401203e+00, 1831.87
13, 1.64602144e+00, 6.48088560e+00, 1831.87
14, 1.58552775e+00, 6.49496220e+00, 1831.87
15, 1.47557885e+00, 6.52118275e+00, 1831.87
16, 1.36978702e+00, 6.54722155e+00, 1831.87
17, 1.29300295e+00, 6.56667185e+00, 1831.87
18, 1.23487904e+00, 6.58185788e+00, 1831.87
19, 1.13326610e+00, 6.60969358e+00, 1831.87
20, 1.08815655e+00, 6.62253628e+00, 1831.87
21, 1.05133480e+00, 6.63333116e+00, 1831.87
22, 9.66160851e-01, 6.65954139e+00, 1831.87
23, 9.26190593e-01, 6.67241909e+00, 1831.87
24, 8.63703021e-01, 6.69353034e+00, 1831.87
25, 8.37768116e-01, 6.70263124e+00, 1831.87
26, 8.26667351e-01, 6.70659592e+00, 1831.87
27, 7.90428543e-01, 6.71986170e+00, 1831.87
28, 7.61820110e-01, 6.73067650e+00, 1831.87
29, 7.35038148e-01, 6.74110382e+00, 1831.87
30, 7.13673675e-01, 6.74964894e+00, 1831.87
31, 7.07278408e-01, 6.75224706e+00, 1831.87
32, 6.76311067e-01, 6.76512932e+00, 1831.87
33, 6.52025527e-01, 6.77556899e+00, 1831.87
34, 6.24402267e-01, 6.78783872e+00, 1831.87
35, 6.00520763e-01, 6.79878969e+00, 1831.87
36, 5.75033134e-01, 6.81083635e+00, 1831.87
37, 5.56581723e-01, 6.81978796e+00, 1831.87
38, 5.43583213e-01, 6.82620307e+00, 1831.87
39, 5.14613674e-01, 6.84081709e+00, 1831.87
40, 4.88693549e-01, 6.85421596e+00, 1831.87
41, 4.61734302e-01, 6.86842760e+00, 1831.87
42, 4.53434153e-01, 6.87284817e+00, 1831.87
43, 4.31372554e-01, 6.88468598e+00, 1831.87
44, 4.24927622e-01, 6.88816216e+00, 1831.87
45, 4.03899413e-01, 6.89955280e+00, 1831.87
46, 3.79463832e-01, 6.91282348e+00, 1831.87
47, 3.52241882e-01, 6.92758657e+00, 1831.87
48, 3.42441288e-01, 6.93287875e+00, 1831.87
49, 3.32917285e-01, 6.93800372e+00, 1831.87
50, 3.17716165e-01, 6.94614282e+00, 1831.87
```

## arquivo lcurve_30x30_g1_sparse_precond.csv
```csv
Iteration,SolutionNorm,ResidualNorm
1,0.00000000e+00,9.67196382e+00
2,1.55898777e+00,3.07252139e+00
3,1.77603493e+00,1.53729417e+00
4,1.79399258e+00,1.39883468e+00
5,1.84883524e+00,1.01019361e+00
6,1.86481978e+00,8.97468112e-01
7,1.86894946e+00,8.68404273e-01
8,1.90461444e+00,6.28412797e-01
9,1.91467888e+00,5.59264782e-01
10,1.91887859e+00,5.30052585e-01
11,1.92355181e+00,4.97479833e-01
12,1.93544815e+00,4.14268921e-01
13,1.94220317e+00,3.65674578e-01
14,1.94721209e+00,3.29254234e-01
15,1.95075872e+00,3.03495583e-01
16,1.95419823e+00,2.78732101e-01
17,1.95561550e+00,2.68664181e-01
18,1.95882596e+00,2.46373566e-01
19,1.96191567e+00,2.25538000e-01
20,1.96495649e+00,2.05668964e-01
21,1.96645522e+00,1.96093519e-01
22,1.96812171e+00,1.85659999e-01
23,1.97005770e+00,1.73864957e-01
24,1.97185532e+00,1.63240358e-01
25,1.97383060e+00,1.51970632e-01
26,1.97438909e+00,1.48852344e-01
27,1.97638024e+00,1.37982239e-01
28,1.97737932e+00,1.32656763e-01
29,1.97870045e+00,1.25749048e-01
30,1.97911473e+00,1.23607305e-01
31,1.98090328e+00,1.14523371e-01
32,1.98280764e+00,1.05095830e-01
33,1.98370216e+00,1.00734155e-01
34,1.98536222e+00,9.27383430e-02
35,1.98676886e+00,8.60193691e-02
36,1.98719857e+00,8.39698276e-02
37,1.98844424e+00,7.80321740e-02
38,1.98943704e+00,7.32812572e-02
39,1.99064716e+00,6.74433522e-02
40,1.99125831e+00,6.44618592e-02
41,1.99184752e+00,6.15617841e-02
42,1.99261786e+00,5.77193876e-02
43,1.99277308e+00,5.69357620e-02
44,1.99378588e+00,5.17399209e-02
45,1.99453063e+00,4.77952867e-02
46,1.99568957e+00,4.13555914e-02
47,1.99582484e+00,4.05709750e-02
48,1.99642400e+00,3.69892680e-02
49,1.99702200e+00,3.31973231e-02
50,1.99731703e+00,3.12226361e-02
```

## arquivo lcurve_30x30_g1_sparse_standard.csv
```csv
Iteration,SolutionNorm,ResidualNorm
1,0.00000000e+00,9.67196382e+00
2,1.55898777e+00,3.07252139e+00
3,1.77603493e+00,1.53729417e+00
4,1.79399258e+00,1.39883468e+00
5,1.84883524e+00,1.01019361e+00
6,1.86481978e+00,8.97468112e-01
7,1.86894946e+00,8.68404273e-01
8,1.90461444e+00,6.28412797e-01
9,1.91467888e+00,5.59264782e-01
10,1.91887859e+00,5.30052585e-01
11,1.92355181e+00,4.97479833e-01
12,1.93544815e+00,4.14268921e-01
13,1.94220317e+00,3.65674578e-01
14,1.94721209e+00,3.29254234e-01
15,1.95075872e+00,3.03495583e-01
16,1.95419823e+00,2.78732101e-01
17,1.95561550e+00,2.68664181e-01
18,1.95882596e+00,2.46373566e-01
19,1.96191567e+00,2.25538000e-01
20,1.96495649e+00,2.05668964e-01
21,1.96645522e+00,1.96093519e-01
22,1.96812171e+00,1.85659999e-01
23,1.97005770e+00,1.73864957e-01
24,1.97185532e+00,1.63240358e-01
25,1.97383060e+00,1.51970632e-01
26,1.97438909e+00,1.48852344e-01
27,1.97638024e+00,1.37982239e-01
28,1.97737932e+00,1.32656763e-01
29,1.97870045e+00,1.25749048e-01
30,1.97911473e+00,1.23607305e-01
31,1.98090328e+00,1.14523371e-01
32,1.98280764e+00,1.05095830e-01
33,1.98370216e+00,1.00734155e-01
34,1.98536222e+00,9.27383430e-02
35,1.98676886e+00,8.60193691e-02
36,1.98719857e+00,8.39698276e-02
37,1.98844424e+00,7.80321740e-02
38,1.98943704e+00,7.32812572e-02
39,1.99064716e+00,6.74433522e-02
40,1.99125831e+00,6.44618592e-02
41,1.99184752e+00,6.15617841e-02
42,1.99261786e+00,5.77193876e-02
43,1.99277308e+00,5.69357620e-02
44,1.99378588e+00,5.17399209e-02
45,1.99453063e+00,4.77952867e-02
46,1.99568957e+00,4.13555914e-02
47,1.99582484e+00,4.05709750e-02
48,1.99642400e+00,3.69892680e-02
49,1.99702200e+00,3.31973231e-02
50,1.99731703e+00,3.12226361e-02
```

## arquivo lcurve_30x30_g2_sparse_precond.csv
```csv
Iteration,SolutionNorm,ResidualNorm
1,0.00000000e+00,1.20736878e+01
2,1.87462201e+00,4.02351777e+00
3,1.92042055e+00,3.65398977e+00
4,2.02751235e+00,2.89073698e+00
5,2.10462469e+00,2.36115773e+00
6,2.17845004e+00,1.84100587e+00
7,2.20365158e+00,1.65829698e+00
8,2.22203672e+00,1.52680971e+00
9,2.25500822e+00,1.29867800e+00
10,2.29328838e+00,1.04314309e+00
11,2.30689009e+00,9.52876436e-01
12,2.32457823e+00,8.36827460e-01
13,2.34472561e+00,7.05063906e-01
14,2.35726912e+00,6.21843740e-01
15,2.36910719e+00,5.42210316e-01
16,2.37946642e+00,4.71904883e-01
17,2.38676801e+00,4.22139493e-01
18,2.39307923e+00,3.79399672e-01
19,2.39790904e+00,3.47102850e-01
20,2.40146776e+00,3.23602566e-01
21,2.40635206e+00,2.91820472e-01
22,2.41026993e+00,2.66636569e-01
23,2.41281187e+00,2.50468187e-01
24,2.41406651e+00,2.42540978e-01
25,2.41658517e+00,2.26735977e-01
26,2.41840525e+00,2.15403395e-01
27,2.41936889e+00,2.09439014e-01
28,2.42141240e+00,1.96883253e-01
29,2.42434817e+00,1.79024616e-01
30,2.42713125e+00,1.62278098e-01
31,2.42929646e+00,1.49359351e-01
32,2.43076747e+00,1.40612539e-01
33,2.43279226e+00,1.28604897e-01
34,2.43363739e+00,1.23590971e-01
35,2.43467614e+00,1.17413038e-01
36,2.43652404e+00,1.06360514e-01
37,2.43786257e+00,9.82513480e-02
38,2.43848301e+00,9.44520797e-02
39,2.43933224e+00,8.92032748e-02
40,2.44054084e+00,8.16144141e-02
41,2.44109713e+00,7.80644355e-02
42,2.44181197e+00,7.34411349e-02
43,2.44277183e+00,6.70947154e-02
44,2.44317600e+00,6.43651366e-02
45,2.44350750e+00,6.20965302e-02
46,2.44425717e+00,5.68552688e-02
47,2.44497562e+00,5.16576625e-02
48,2.44563559e+00,4.66946130e-02
49,2.44618314e+00,4.23960938e-02
50,2.44669296e+00,3.81925719e-02
```

## arquivo lcurve_30x30_g2_sparse_standard.csv
```csv
Iteration,SolutionNorm,ResidualNorm
1,0.00000000e+00,1.20736878e+01
2,1.87462201e+00,4.02351777e+00
3,1.92042055e+00,3.65398977e+00
4,2.02751235e+00,2.89073698e+00
5,2.10462469e+00,2.36115773e+00
6,2.17845004e+00,1.84100587e+00
7,2.20365158e+00,1.65829698e+00
8,2.22203672e+00,1.52680971e+00
9,2.25500822e+00,1.29867800e+00
10,2.29328838e+00,1.04314309e+00
11,2.30689009e+00,9.52876436e-01
12,2.32457823e+00,8.36827460e-01
13,2.34472561e+00,7.05063906e-01
14,2.35726912e+00,6.21843740e-01
15,2.36910719e+00,5.42210316e-01
16,2.37946642e+00,4.71904883e-01
17,2.38676801e+00,4.22139493e-01
18,2.39307923e+00,3.79399672e-01
19,2.39790904e+00,3.47102850e-01
20,2.40146776e+00,3.23602566e-01
21,2.40635206e+00,2.91820472e-01
22,2.41026993e+00,2.66636569e-01
23,2.41281187e+00,2.50468187e-01
24,2.41406651e+00,2.42540978e-01
25,2.41658517e+00,2.26735977e-01
26,2.41840525e+00,2.15403395e-01
27,2.41936889e+00,2.09439014e-01
28,2.42141240e+00,1.96883253e-01
29,2.42434817e+00,1.79024616e-01
30,2.42713125e+00,1.62278098e-01
31,2.42929646e+00,1.49359351e-01
32,2.43076747e+00,1.40612539e-01
33,2.43279226e+00,1.28604897e-01
34,2.43363739e+00,1.23590971e-01
35,2.43467614e+00,1.17413038e-01
36,2.43652404e+00,1.06360514e-01
37,2.43786257e+00,9.82513480e-02
38,2.43848301e+00,9.44520797e-02
39,2.43933224e+00,8.92032748e-02
40,2.44054084e+00,8.16144141e-02
41,2.44109713e+00,7.80644355e-02
42,2.44181197e+00,7.34411349e-02
43,2.44277183e+00,6.70947154e-02
44,2.44317600e+00,6.43651366e-02
45,2.44350750e+00,6.20965302e-02
46,2.44425717e+00,5.68552688e-02
47,2.44497562e+00,5.16576625e-02
48,2.44563559e+00,4.66946130e-02
49,2.44618314e+00,4.23960938e-02
50,2.44669296e+00,3.81925719e-02
```

## arquivo lcurve_60x60_G1_sparse_precond.csv
```csv
Iteration,SolutionNorm,ResidualNorm
1,0.00000000e+00,1.54640017e+01
2,2.95333226e+00,6.17186055e+00
3,3.53454207e+00,3.55670287e+00
4,3.65843662e+00,2.99761919e+00
5,3.79383539e+00,2.39219064e+00
6,3.83375295e+00,2.20794552e+00
7,3.86563639e+00,2.06309467e+00
8,3.95979300e+00,1.65101719e+00
9,3.98705940e+00,1.53108700e+00
10,3.99666487e+00,1.48873863e+00
11,4.04632060e+00,1.27397610e+00
12,4.08665265e+00,1.09950505e+00
13,4.10543978e+00,1.01686809e+00
14,4.11776744e+00,9.62496045e-01
15,4.14771050e+00,8.30742658e-01
16,4.16472755e+00,7.54658503e-01
17,4.17736234e+00,6.97633203e-01
18,4.19699293e+00,6.09044074e-01
19,4.20463616e+00,5.74370142e-01
20,4.21067073e+00,5.47074792e-01
21,4.22259198e+00,4.93735822e-01
22,4.23017365e+00,4.60063338e-01
23,4.23556708e+00,4.36327929e-01
24,4.23882770e+00,4.22122183e-01
25,4.24221920e+00,4.07458113e-01
26,4.24709560e+00,3.86592624e-01
27,4.25156603e+00,3.67773193e-01
28,4.25554085e+00,3.51352487e-01
29,4.25900523e+00,3.37303201e-01
30,4.26015230e+00,3.32705820e-01
31,4.26419592e+00,3.16792358e-01
32,4.26783713e+00,3.02864662e-01
33,4.27056620e+00,2.92696259e-01
34,4.27422411e+00,2.79480043e-01
35,4.27707327e+00,2.69498835e-01
36,4.27956963e+00,2.60982189e-01
37,4.28123787e+00,2.55407974e-01
38,4.28450471e+00,2.44748328e-01
39,4.28758357e+00,2.34985558e-01
40,4.29114831e+00,2.24014319e-01
41,4.29230893e+00,2.20511592e-01
42,4.29414141e+00,2.15047233e-01
43,4.29558664e+00,2.10788939e-01
44,4.29905867e+00,2.00735989e-01
45,4.30321700e+00,1.88971778e-01
46,4.30716195e+00,1.78014403e-01
47,4.30939586e+00,1.71872318e-01
48,4.31059084e+00,1.68601238e-01
49,4.31382943e+00,1.59768365e-01
50,4.31627224e+00,1.53117654e-01
```

## arquivo lcurve_60x60_G1_sparse_standard.csv
```csv
Iteration,SolutionNorm,ResidualNorm
1,0.00000000e+00,1.54640017e+01
2,2.95333226e+00,6.17186055e+00
3,3.53454207e+00,3.55670287e+00
4,3.65843662e+00,2.99761919e+00
5,3.79383539e+00,2.39219064e+00
6,3.83375295e+00,2.20794552e+00
7,3.86563639e+00,2.06309467e+00
8,3.95979300e+00,1.65101719e+00
9,3.98705940e+00,1.53108700e+00
10,3.99666487e+00,1.48873863e+00
11,4.04632060e+00,1.27397610e+00
12,4.08665265e+00,1.09950505e+00
13,4.10543978e+00,1.01686809e+00
14,4.11776744e+00,9.62496045e-01
15,4.14771050e+00,8.30742658e-01
16,4.16472755e+00,7.54658503e-01
17,4.17736234e+00,6.97633203e-01
18,4.19699293e+00,6.09044074e-01
19,4.20463616e+00,5.74370142e-01
20,4.21067073e+00,5.47074792e-01
21,4.22259198e+00,4.93735822e-01
22,4.23017365e+00,4.60063338e-01
23,4.23556708e+00,4.36327929e-01
24,4.23882770e+00,4.22122183e-01
25,4.24221920e+00,4.07458113e-01
26,4.24709560e+00,3.86592624e-01
27,4.25156603e+00,3.67773193e-01
28,4.25554085e+00,3.51352487e-01
29,4.25900523e+00,3.37303201e-01
30,4.26015230e+00,3.32705820e-01
31,4.26419592e+00,3.16792358e-01
32,4.26783713e+00,3.02864662e-01
33,4.27056620e+00,2.92696259e-01
34,4.27422411e+00,2.79480043e-01
35,4.27707327e+00,2.69498835e-01
36,4.27956963e+00,2.60982189e-01
37,4.28123787e+00,2.55407974e-01
38,4.28450471e+00,2.44748328e-01
39,4.28758357e+00,2.34985558e-01
40,4.29114831e+00,2.24014319e-01
41,4.29230893e+00,2.20511592e-01
42,4.29414141e+00,2.15047233e-01
43,4.29558664e+00,2.10788939e-01
44,4.29905867e+00,2.00735989e-01
45,4.30321700e+00,1.88971778e-01
46,4.30716195e+00,1.78014403e-01
47,4.30939586e+00,1.71872318e-01
48,4.31059084e+00,1.68601238e-01
49,4.31382943e+00,1.59768365e-01
50,4.31627224e+00,1.53117654e-01
```

## arquivo lcurve_60x60_G2_sparse_precond.csv
```csv
Iteration,SolutionNorm,ResidualNorm
1,0.00000000e+00,2.72014132e+01
2,5.18085941e+00,8.78975958e+00
3,5.79821908e+00,5.12351791e+00
4,5.97246712e+00,4.14430725e+00
5,6.11609297e+00,3.38780189e+00
6,6.14586604e+00,3.23059750e+00
7,6.18577967e+00,3.02412857e+00
8,6.25856680e+00,2.66597172e+00
9,6.33345313e+00,2.31106204e+00
10,6.36020514e+00,2.18561181e+00
11,6.37467736e+00,2.11826524e+00
12,6.44401203e+00,1.80702862e+00
13,6.48088560e+00,1.64602144e+00
14,6.49496220e+00,1.58552775e+00
15,6.52118275e+00,1.47557885e+00
16,6.54722155e+00,1.36978702e+00
17,6.56667185e+00,1.29300295e+00
18,6.58185788e+00,1.23487904e+00
19,6.60969358e+00,1.13326610e+00
20,6.62253628e+00,1.08815655e+00
21,6.63333116e+00,1.05133480e+00
22,6.65954139e+00,9.66160851e-01
23,6.67241909e+00,9.26190593e-01
24,6.69353034e+00,8.63703021e-01
25,6.70263124e+00,8.37768116e-01
26,6.70659592e+00,8.26667351e-01
27,6.71986170e+00,7.90428543e-01
28,6.73067650e+00,7.61820110e-01
29,6.74110382e+00,7.35038148e-01
30,6.74964894e+00,7.13673675e-01
31,6.75224706e+00,7.07278408e-01
32,6.76512932e+00,6.76311067e-01
33,6.77556899e+00,6.52025527e-01
34,6.78783872e+00,6.24402267e-01
35,6.79878969e+00,6.00520763e-01
36,6.81083635e+00,5.75033134e-01
37,6.81978796e+00,5.56581723e-01
38,6.82620307e+00,5.43583213e-01
39,6.84081709e+00,5.14613674e-01
40,6.85421596e+00,4.88693549e-01
41,6.86842760e+00,4.61734302e-01
42,6.87284817e+00,4.53434153e-01
43,6.88468598e+00,4.31372554e-01
44,6.88816216e+00,4.24927622e-01
45,6.89955280e+00,4.03899413e-01
46,6.91282348e+00,3.79463832e-01
47,6.92758657e+00,3.52241882e-01
48,6.93287875e+00,3.42441288e-01
49,6.93800372e+00,3.32917285e-01
50,6.94614282e+00,3.17716165e-01
```

## arquivo lcurve_60x60_G2_sparse_standard.csv
```csv
Iteration,SolutionNorm,ResidualNorm
1,0.00000000e+00,2.72014132e+01
2,5.18085941e+00,8.78975958e+00
3,5.79821908e+00,5.12351791e+00
4,5.97246712e+00,4.14430725e+00
5,6.11609297e+00,3.38780189e+00
6,6.14586604e+00,3.23059750e+00
7,6.18577967e+00,3.02412857e+00
8,6.25856680e+00,2.66597172e+00
9,6.33345313e+00,2.31106204e+00
10,6.36020514e+00,2.18561181e+00
11,6.37467736e+00,2.11826524e+00
12,6.44401203e+00,1.80702862e+00
13,6.48088560e+00,1.64602144e+00
14,6.49496220e+00,1.58552775e+00
15,6.52118275e+00,1.47557885e+00
16,6.54722155e+00,1.36978702e+00
17,6.56667185e+00,1.29300295e+00
18,6.58185788e+00,1.23487904e+00
19,6.60969358e+00,1.13326610e+00
20,6.62253628e+00,1.08815655e+00
21,6.63333116e+00,1.05133480e+00
22,6.65954139e+00,9.66160851e-01
23,6.67241909e+00,9.26190593e-01
24,6.69353034e+00,8.63703021e-01
25,6.70263124e+00,8.37768116e-01
26,6.70659592e+00,8.26667351e-01
27,6.71986170e+00,7.90428543e-01
28,6.73067650e+00,7.61820110e-01
29,6.74110382e+00,7.35038148e-01
30,6.74964894e+00,7.13673675e-01
31,6.75224706e+00,7.07278408e-01
32,6.76512932e+00,6.76311067e-01
33,6.77556899e+00,6.52025527e-01
34,6.78783872e+00,6.24402267e-01
35,6.79878969e+00,6.00520763e-01
36,6.81083635e+00,5.75033134e-01
37,6.81978796e+00,5.56581723e-01
38,6.82620307e+00,5.43583213e-01
39,6.84081709e+00,5.14613674e-01
40,6.85421596e+00,4.88693549e-01
41,6.86842760e+00,4.61734302e-01
42,6.87284817e+00,4.53434153e-01
43,6.88468598e+00,4.31372554e-01
44,6.88816216e+00,4.24927622e-01
45,6.89955280e+00,4.03899413e-01
46,6.91282348e+00,3.79463832e-01
47,6.92758657e+00,3.52241882e-01
48,6.93287875e+00,3.42441288e-01
49,6.93800372e+00,3.32917285e-01
50,6.94614282e+00,3.17716165e-01
```

## arquivo convergence_history_30x30_g1_sparse_precond.csv
```csv
Iteration,ResidualNorm,SolutionNorm,ExecutionTime_ms
1, 9.67196382e+00, 0.00000000e+00, 407.88
2, 3.07252139e+00, 1.55898777e+00, 407.88
3, 1.53729417e+00, 1.77603493e+00, 407.88
4, 1.39883468e+00, 1.79399258e+00, 407.88
5, 1.01019361e+00, 1.84883524e+00, 407.88
6, 8.97468112e-01, 1.86481978e+00, 407.88
7, 8.68404273e-01, 1.86894946e+00, 407.88
8, 6.28412797e-01, 1.90461444e+00, 407.88
9, 5.59264782e-01, 1.91467888e+00, 407.88
10, 5.30052585e-01, 1.91887859e+00, 407.88
11, 4.97479833e-01, 1.92355181e+00, 407.88
12, 4.14268921e-01, 1.93544815e+00, 407.88
13, 3.65674578e-01, 1.94220317e+00, 407.88
14, 3.29254234e-01, 1.94721209e+00, 407.88
15, 3.03495583e-01, 1.95075872e+00, 407.88
16, 2.78732101e-01, 1.95419823e+00, 407.88
17, 2.68664181e-01, 1.95561550e+00, 407.88
18, 2.46373566e-01, 1.95882596e+00, 407.88
19, 2.25538000e-01, 1.96191567e+00, 407.88
20, 2.05668964e-01, 1.96495649e+00, 407.88
21, 1.96093519e-01, 1.96645522e+00, 407.88
22, 1.85659999e-01, 1.96812171e+00, 407.88
23, 1.73864957e-01, 1.97005770e+00, 407.88
24, 1.63240358e-01, 1.97185532e+00, 407.88
25, 1.51970632e-01, 1.97383060e+00, 407.88
26, 1.48852344e-01, 1.97438909e+00, 407.88
27, 1.37982239e-01, 1.97638024e+00, 407.88
28, 1.32656763e-01, 1.97737932e+00, 407.88
29, 1.25749048e-01, 1.97870045e+00, 407.88
30, 1.23607305e-01, 1.97911473e+00, 407.88
31, 1.14523371e-01, 1.98090328e+00, 407.88
32, 1.05095830e-01, 1.98280764e+00, 407.88
33, 1.00734155e-01, 1.98370216e+00, 407.88
34, 9.27383430e-02, 1.98536222e+00, 407.88
35, 8.60193691e-02, 1.98676886e+00, 407.88
36, 8.39698276e-02, 1.98719857e+00, 407.88
37, 7.80321740e-02, 1.98844424e+00, 407.88
38, 7.32812572e-02, 1.98943704e+00, 407.88
39, 6.74433522e-02, 1.99064716e+00, 407.88
40, 6.44618592e-02, 1.99125831e+00, 407.88
41, 6.15617841e-02, 1.99184752e+00, 407.88
42, 5.77193876e-02, 1.99261786e+00, 407.88
43, 5.69357620e-02, 1.99277308e+00, 407.88
44, 5.17399209e-02, 1.99378588e+00, 407.88
45, 4.77952867e-02, 1.99453063e+00, 407.88
46, 4.13555914e-02, 1.99568957e+00, 407.88
47, 4.05709750e-02, 1.99582484e+00, 407.88
48, 3.69892680e-02, 1.99642400e+00, 407.88
49, 3.31973231e-02, 1.99702200e+00, 407.88
50, 3.12226361e-02, 1.99731703e+00, 407.88
```

## arquivo convergence_history_30x30_g1_sparse_standard.csv
```csv
Iteration,ResidualNorm,SolutionNorm,ExecutionTime_ms
1, 9.67196382e+00, 0.00000000e+00, 414.07
2, 3.07252139e+00, 1.55898777e+00, 414.07
3, 1.53729417e+00, 1.77603493e+00, 414.07
4, 1.39883468e+00, 1.79399258e+00, 414.07
5, 1.01019361e+00, 1.84883524e+00, 414.07
6, 8.97468112e-01, 1.86481978e+00, 414.07
7, 8.68404273e-01, 1.86894946e+00, 414.07
8, 6.28412797e-01, 1.90461444e+00, 414.07
9, 5.59264782e-01, 1.91467888e+00, 414.07
10, 5.30052585e-01, 1.91887859e+00, 414.07
11, 4.97479833e-01, 1.92355181e+00, 414.07
12, 4.14268921e-01, 1.93544815e+00, 414.07
13, 3.65674578e-01, 1.94220317e+00, 414.07
14, 3.29254234e-01, 1.94721209e+00, 414.07
15, 3.03495583e-01, 1.95075872e+00, 414.07
16, 2.78732101e-01, 1.95419823e+00, 414.07
17, 2.68664181e-01, 1.95561550e+00, 414.07
18, 2.46373566e-01, 1.95882596e+00, 414.07
19, 2.25538000e-01, 1.96191567e+00, 414.07
20, 2.05668964e-01, 1.96495649e+00, 414.07
21, 1.96093519e-01, 1.96645522e+00, 414.07
22, 1.85659999e-01, 1.96812171e+00, 414.07
23, 1.73864957e-01, 1.97005770e+00, 414.07
24, 1.63240358e-01, 1.97185532e+00, 414.07
25, 1.51970632e-01, 1.97383060e+00, 414.07
26, 1.48852344e-01, 1.97438909e+00, 414.07
27, 1.37982239e-01, 1.97638024e+00, 414.07
28, 1.32656763e-01, 1.97737932e+00, 414.07
29, 1.25749048e-01, 1.97870045e+00, 414.07
30, 1.23607305e-01, 1.97911473e+00, 414.07
31, 1.14523371e-01, 1.98090328e+00, 414.07
32, 1.05095830e-01, 1.98280764e+00, 414.07
33, 1.00734155e-01, 1.98370216e+00, 414.07
34, 9.27383430e-02, 1.98536222e+00, 414.07
35, 8.60193691e-02, 1.98676886e+00, 414.07
36, 8.39698276e-02, 1.98719857e+00, 414.07
37, 7.80321740e-02, 1.98844424e+00, 414.07
38, 7.32812572e-02, 1.98943704e+00, 414.07
39, 6.74433522e-02, 1.99064716e+00, 414.07
40, 6.44618592e-02, 1.99125831e+00, 414.07
41, 6.15617841e-02, 1.99184752e+00, 414.07
42, 5.77193876e-02, 1.99261786e+00, 414.07
43, 5.69357620e-02, 1.99277308e+00, 414.07
44, 5.17399209e-02, 1.99378588e+00, 414.07
45, 4.77952867e-02, 1.99453063e+00, 414.07
46, 4.13555914e-02, 1.99568957e+00, 414.07
47, 4.05709750e-02, 1.99582484e+00, 414.07
48, 3.69892680e-02, 1.99642400e+00, 414.07
49, 3.31973231e-02, 1.99702200e+00, 414.07
50, 3.12226361e-02, 1.99731703e+00, 414.07
```

## arquivo convergence_history_30x30_g2_sparse_precond.csv
```csv
Iteration,ResidualNorm,SolutionNorm,ExecutionTime_ms
1, 1.20736878e+01, 0.00000000e+00, 394.07
2, 4.02351777e+00, 1.87462201e+00, 394.07
3, 3.65398977e+00, 1.92042055e+00, 394.07
4, 2.89073698e+00, 2.02751235e+00, 394.07
5, 2.36115773e+00, 2.10462469e+00, 394.07
6, 1.84100587e+00, 2.17845004e+00, 394.07
7, 1.65829698e+00, 2.20365158e+00, 394.07
8, 1.52680971e+00, 2.22203672e+00, 394.07
9, 1.29867800e+00, 2.25500822e+00, 394.07
10, 1.04314309e+00, 2.29328838e+00, 394.07
11, 9.52876436e-01, 2.30689009e+00, 394.07
12, 8.36827460e-01, 2.32457823e+00, 394.07
13, 7.05063906e-01, 2.34472561e+00, 394.07
14, 6.21843740e-01, 2.35726912e+00, 394.07
15, 5.42210316e-01, 2.36910719e+00, 394.07
16, 4.71904883e-01, 2.37946642e+00, 394.07
17, 4.22139493e-01, 2.38676801e+00, 394.07
18, 3.79399672e-01, 2.39307923e+00, 394.07
19, 3.47102850e-01, 2.39790904e+00, 394.07
20, 3.23602566e-01, 2.40146776e+00, 394.07
21, 2.91820472e-01, 2.40635206e+00, 394.07
22, 2.66636569e-01, 2.41026993e+00, 394.07
23, 2.50468187e-01, 2.41281187e+00, 394.07
24, 2.42540978e-01, 2.41406651e+00, 394.07
25, 2.26735977e-01, 2.41658517e+00, 394.07
26, 2.15403395e-01, 2.41840525e+00, 394.07
27, 2.09439014e-01, 2.41936889e+00, 394.07
28, 1.96883253e-01, 2.42141240e+00, 394.07
29, 1.79024616e-01, 2.42434817e+00, 394.07
30, 1.62278098e-01, 2.42713125e+00, 394.07
31, 1.49359351e-01, 2.42929646e+00, 394.07
32, 1.40612539e-01, 2.43076747e+00, 394.07
33, 1.28604897e-01, 2.43279226e+00, 394.07
34, 1.23590971e-01, 2.43363739e+00, 394.07
35, 1.17413038e-01, 2.43467614e+00, 394.07
36, 1.06360514e-01, 2.43652404e+00, 394.07
37, 9.82513480e-02, 2.43786257e+00, 394.07
38, 9.44520797e-02, 2.43848301e+00, 394.07
39, 8.92032748e-02, 2.43933224e+00, 394.07
40, 8.16144141e-02, 2.44054084e+00, 394.07
41, 7.80644355e-02, 2.44109713e+00, 394.07
42, 7.34411349e-02, 2.44181197e+00, 394.07
43, 6.70947154e-02, 2.44277183e+00, 394.07
44, 6.43651366e-02, 2.44317600e+00, 394.07
45, 6.20965302e-02, 2.44350750e+00, 394.07
46, 5.68552688e-02, 2.44425717e+00, 394.07
47, 5.16576625e-02, 2.44497562e+00, 394.07
48, 4.66946130e-02, 2.44563559e+00, 394.07
49, 4.23960938e-02, 2.44618314e+00, 394.07
50, 3.81925719e-02, 2.44669296e+00, 394.07
```

## arquivo convergence_history_30x30_g2_sparse_standard.csv
```csv
Iteration,ResidualNorm,SolutionNorm,ExecutionTime_ms
1, 1.20736878e+01, 0.00000000e+00, 414.10
2, 4.02351777e+00, 1.87462201e+00, 414.10
3, 3.65398977e+00, 1.92042055e+00, 414.10
4, 2.89073698e+00, 2.02751235e+00, 414.10
5, 2.36115773e+00, 2.10462469e+00, 414.10
6, 1.84100587e+00, 2.17845004e+00, 414.10
7, 1.65829698e+00, 2.20365158e+00, 414.10
8, 1.52680971e+00, 2.22203672e+00, 414.10
9, 1.29867800e+00, 2.25500822e+00, 414.10
10, 1.04314309e+00, 2.29328838e+00, 414.10
11, 9.52876436e-01, 2.30689009e+00, 414.10
12, 8.36827460e-01, 2.32457823e+00, 414.10
13, 7.05063906e-01, 2.34472561e+00, 414.10
14, 6.21843740e-01, 2.35726912e+00, 414.10
15, 5.42210316e-01, 2.36910719e+00, 414.10
16, 4.71904883e-01, 2.37946642e+00, 414.10
17, 4.22139493e-01, 2.38676801e+00, 414.10
18, 3.79399672e-01, 2.39307923e+00, 414.10
19, 3.47102850e-01, 2.39790904e+00, 414.10
20, 3.23602566e-01, 2.40146776e+00, 414.10
21, 2.91820472e-01, 2.40635206e+00, 414.10
22, 2.66636569e-01, 2.41026993e+00, 414.10
23, 2.50468187e-01, 2.41281187e+00, 414.10
24, 2.42540978e-01, 2.41406651e+00, 414.10
25, 2.26735977e-01, 2.41658517e+00, 414.10
26, 2.15403395e-01, 2.41840525e+00, 414.10
27, 2.09439014e-01, 2.41936889e+00, 414.10
28, 1.96883253e-01, 2.42141240e+00, 414.10
29, 1.79024616e-01, 2.42434817e+00, 414.10
30, 1.62278098e-01, 2.42713125e+00, 414.10
31, 1.49359351e-01, 2.42929646e+00, 414.10
32, 1.40612539e-01, 2.43076747e+00, 414.10
33, 1.28604897e-01, 2.43279226e+00, 414.10
34, 1.23590971e-01, 2.43363739e+00, 414.10
35, 1.17413038e-01, 2.43467614e+00, 414.10
36, 1.06360514e-01, 2.43652404e+00, 414.10
37, 9.82513480e-02, 2.43786257e+00, 414.10
38, 9.44520797e-02, 2.43848301e+00, 414.10
39, 8.92032748e-02, 2.43933224e+00, 414.10
40, 8.16144141e-02, 2.44054084e+00, 414.10
41, 7.80644355e-02, 2.44109713e+00, 414.10
42, 7.34411349e-02, 2.44181197e+00, 414.10
43, 6.70947154e-02, 2.44277183e+00, 414.10
44, 6.43651366e-02, 2.44317600e+00, 414.10
45, 6.20965302e-02, 2.44350750e+00, 414.10
46, 5.68552688e-02, 2.44425717e+00, 414.10
47, 5.16576625e-02, 2.44497562e+00, 414.10
48, 4.66946130e-02, 2.44563559e+00, 414.10
49, 4.23960938e-02, 2.44618314e+00, 414.10
50, 3.81925719e-02, 2.44669296e+00, 414.10
```

## arquivo convergence_history_60x60_G1_sparse_precond.csv
```csv
Iteration,ResidualNorm,SolutionNorm,ExecutionTime_ms
1, 1.54640017e+01, 0.00000000e+00, 1793.85
2, 6.17186055e+00, 2.95333226e+00, 1793.85
3, 3.55670287e+00, 3.53454207e+00, 1793.85
4, 2.99761919e+00, 3.65843662e+00, 1793.85
5, 2.39219064e+00, 3.79383539e+00, 1793.85
6, 2.20794552e+00, 3.83375295e+00, 1793.85
7, 2.06309467e+00, 3.86563639e+00, 1793.85
8, 1.65101719e+00, 3.95979300e+00, 1793.85
9, 1.53108700e+00, 3.98705940e+00, 1793.85
10, 1.48873863e+00, 3.99666487e+00, 1793.85
11, 1.27397610e+00, 4.04632060e+00, 1793.85
12, 1.09950505e+00, 4.08665265e+00, 1793.85
13, 1.01686809e+00, 4.10543978e+00, 1793.85
14, 9.62496045e-01, 4.11776744e+00, 1793.85
15, 8.30742658e-01, 4.14771050e+00, 1793.85
16, 7.54658503e-01, 4.16472755e+00, 1793.85
17, 6.97633203e-01, 4.17736234e+00, 1793.85
18, 6.09044074e-01, 4.19699293e+00, 1793.85
19, 5.74370142e-01, 4.20463616e+00, 1793.85
20, 5.47074792e-01, 4.21067073e+00, 1793.85
21, 4.93735822e-01, 4.22259198e+00, 1793.85
22, 4.60063338e-01, 4.23017365e+00, 1793.85
23, 4.36327929e-01, 4.23556708e+00, 1793.85
24, 4.22122183e-01, 4.23882770e+00, 1793.85
25, 4.07458113e-01, 4.24221920e+00, 1793.85
26, 3.86592624e-01, 4.24709560e+00, 1793.85
27, 3.67773193e-01, 4.25156603e+00, 1793.85
28, 3.51352487e-01, 4.25554085e+00, 1793.85
29, 3.37303201e-01, 4.25900523e+00, 1793.85
30, 3.32705820e-01, 4.26015230e+00, 1793.85
31, 3.16792358e-01, 4.26419592e+00, 1793.85
32, 3.02864662e-01, 4.26783713e+00, 1793.85
33, 2.92696259e-01, 4.27056620e+00, 1793.85
34, 2.79480043e-01, 4.27422411e+00, 1793.85
35, 2.69498835e-01, 4.27707327e+00, 1793.85
36, 2.60982189e-01, 4.27956963e+00, 1793.85
37, 2.55407974e-01, 4.28123787e+00, 1793.85
38, 2.44748328e-01, 4.28450471e+00, 1793.85
39, 2.34985558e-01, 4.28758357e+00, 1793.85
40, 2.24014319e-01, 4.29114831e+00, 1793.85
41, 2.20511592e-01, 4.29230893e+00, 1793.85
42, 2.15047233e-01, 4.29414141e+00, 1793.85
43, 2.10788939e-01, 4.29558664e+00, 1793.85
44, 2.00735989e-01, 4.29905867e+00, 1793.85
45, 1.88971778e-01, 4.30321700e+00, 1793.85
46, 1.78014403e-01, 4.30716195e+00, 1793.85
47, 1.71872318e-01, 4.30939586e+00, 1793.85
48, 1.68601238e-01, 4.31059084e+00, 1793.85
49, 1.59768365e-01, 4.31382943e+00, 1793.85
50, 1.53117654e-01, 4.31627224e+00, 1793.85
```

## arquivo convergence_history_60x60_G1_sparse_standard.csv
```csv
Iteration,ResidualNorm,SolutionNorm,ExecutionTime_ms
1, 1.54640017e+01, 0.00000000e+00, 1807.63
2, 6.17186055e+00, 2.95333226e+00, 1807.63
3, 3.55670287e+00, 3.53454207e+00, 1807.63
4, 2.99761919e+00, 3.65843662e+00, 1807.63
5, 2.39219064e+00, 3.79383539e+00, 1807.63
6, 2.20794552e+00, 3.83375295e+00, 1807.63
7, 2.06309467e+00, 3.86563639e+00, 1807.63
8, 1.65101719e+00, 3.95979300e+00, 1807.63
9, 1.53108700e+00, 3.98705940e+00, 1807.63
10, 1.48873863e+00, 3.99666487e+00, 1807.63
11, 1.27397610e+00, 4.04632060e+00, 1807.63
12, 1.09950505e+00, 4.08665265e+00, 1807.63
13, 1.01686809e+00, 4.10543978e+00, 1807.63
14, 9.62496045e-01, 4.11776744e+00, 1807.63
15, 8.30742658e-01, 4.14771050e+00, 1807.63
16, 7.54658503e-01, 4.16472755e+00, 1807.63
17, 6.97633203e-01, 4.17736234e+00, 1807.63
18, 6.09044074e-01, 4.19699293e+00, 1807.63
19, 5.74370142e-01, 4.20463616e+00, 1807.63
20, 5.47074792e-01, 4.21067073e+00, 1807.63
21, 4.93735822e-01, 4.22259198e+00, 1807.63
22, 4.60063338e-01, 4.23017365e+00, 1807.63
23, 4.36327929e-01, 4.23556708e+00, 1807.63
24, 4.22122183e-01, 4.23882770e+00, 1807.63
25, 4.07458113e-01, 4.24221920e+00, 1807.63
26, 3.86592624e-01, 4.24709560e+00, 1807.63
27, 3.67773193e-01, 4.25156603e+00, 1807.63
28, 3.51352487e-01, 4.25554085e+00, 1807.63
29, 3.37303201e-01, 4.25900523e+00, 1807.63
30, 3.32705820e-01, 4.26015230e+00, 1807.63
31, 3.16792358e-01, 4.26419592e+00, 1807.63
32, 3.02864662e-01, 4.26783713e+00, 1807.63
33, 2.92696259e-01, 4.27056620e+00, 1807.63
34, 2.79480043e-01, 4.27422411e+00, 1807.63
35, 2.69498835e-01, 4.27707327e+00, 1807.63
36, 2.60982189e-01, 4.27956963e+00, 1807.63
37, 2.55407974e-01, 4.28123787e+00, 1807.63
38, 2.44748328e-01, 4.28450471e+00, 1807.63
39, 2.34985558e-01, 4.28758357e+00, 1807.63
40, 2.24014319e-01, 4.29114831e+00, 1807.63
41, 2.20511592e-01, 4.29230893e+00, 1807.63
42, 2.15047233e-01, 4.29414141e+00, 1807.63
43, 2.10788939e-01, 4.29558664e+00, 1807.63
44, 2.00735989e-01, 4.29905867e+00, 1807.63
45, 1.88971778e-01, 4.30321700e+00, 1807.63
46, 1.78014403e-01, 4.30716195e+00, 1807.63
47, 1.71872318e-01, 4.30939586e+00, 1807.63
48, 1.68601238e-01, 4.31059084e+00, 1807.63
49, 1.59768365e-01, 4.31382943e+00, 1807.63
50, 1.53117654e-01, 4.31627224e+00, 1807.63
```

## arquivo convergence_history_60x60_G2_sparse_precond.csv
```csv
Iteration,ResidualNorm,SolutionNorm,ExecutionTime_ms
1, 2.72014132e+01, 0.00000000e+00, 1811.41
2, 8.78975958e+00, 5.18085941e+00, 1811.41
3, 5.12351791e+00, 5.79821908e+00, 1811.41
4, 4.14430725e+00, 5.97246712e+00, 1811.41
5, 3.38780189e+00, 6.11609297e+00, 1811.41
6, 3.23059750e+00, 6.14586604e+00, 1811.41
7, 3.02412857e+00, 6.18577967e+00, 1811.41
8, 2.66597172e+00, 6.25856680e+00, 1811.41
9, 2.31106204e+00, 6.33345313e+00, 1811.41
10, 2.18561181e+00, 6.36020514e+00, 1811.41
11, 2.11826524e+00, 6.37467736e+00, 1811.41
12, 1.80702862e+00, 6.44401203e+00, 1811.41
13, 1.64602144e+00, 6.48088560e+00, 1811.41
14, 1.58552775e+00, 6.49496220e+00, 1811.41
15, 1.47557885e+00, 6.52118275e+00, 1811.41
16, 1.36978702e+00, 6.54722155e+00, 1811.41
17, 1.29300295e+00, 6.56667185e+00, 1811.41
18, 1.23487904e+00, 6.58185788e+00, 1811.41
19, 1.13326610e+00, 6.60969358e+00, 1811.41
20, 1.08815655e+00, 6.62253628e+00, 1811.41
21, 1.05133480e+00, 6.63333116e+00, 1811.41
22, 9.66160851e-01, 6.65954139e+00, 1811.41
23, 9.26190593e-01, 6.67241909e+00, 1811.41
24, 8.63703021e-01, 6.69353034e+00, 1811.41
25, 8.37768116e-01, 6.70263124e+00, 1811.41
26, 8.26667351e-01, 6.70659592e+00, 1811.41
27, 7.90428543e-01, 6.71986170e+00, 1811.41
28, 7.61820110e-01, 6.73067650e+00, 1811.41
29, 7.35038148e-01, 6.74110382e+00, 1811.41
30, 7.13673675e-01, 6.74964894e+00, 1811.41
31, 7.07278408e-01, 6.75224706e+00, 1811.41
32, 6.76311067e-01, 6.76512932e+00, 1811.41
33, 6.52025527e-01, 6.77556899e+00, 1811.41
34, 6.24402267e-01, 6.78783872e+00, 1811.41
35, 6.00520763e-01, 6.79878969e+00, 1811.41
36, 5.75033134e-01, 6.81083635e+00, 1811.41
37, 5.56581723e-01, 6.81978796e+00, 1811.41
38, 5.43583213e-01, 6.82620307e+00, 1811.41
39, 5.14613674e-01, 6.84081709e+00, 1811.41
40, 4.88693549e-01, 6.85421596e+00, 1811.41
41, 4.61734302e-01, 6.86842760e+00, 1811.41
42, 4.53434153e-01, 6.87284817e+00, 1811.41
43, 4.31372554e-01, 6.88468598e+00, 1811.41
44, 4.24927622e-01, 6.88816216e+00, 1811.41
45, 4.03899413e-01, 6.89955280e+00, 1811.41
46, 3.79463832e-01, 6.91282348e+00, 1811.41
47, 3.52241882e-01, 6.92758657e+00, 1811.41
48, 3.42441288e-01, 6.93287875e+00, 1811.41
49, 3.32917285e-01, 6.93800372e+00, 1811.41
50, 3.17716165e-01, 6.94614282e+00, 1811.41
```

## arquivo convergence_history_60x60_G2_sparse_standard.csv
```csv
Iteration,ResidualNorm,SolutionNorm,ExecutionTime_ms
1, 2.72014132e+01, 0.00000000e+00, 1796.52
2, 8.78975958e+00, 5.18085941e+00, 1796.52
3, 5.12351791e+00, 5.79821908e+00, 1796.52
4, 4.14430725e+00, 5.97246712e+00, 1796.52
5, 3.38780189e+00, 6.11609297e+00, 1796.52
6, 3.23059750e+00, 6.14586604e+00, 1796.52
7, 3.02412857e+00, 6.18577967e+00, 1796.52
8, 2.66597172e+00, 6.25856680e+00, 1796.52
9, 2.31106204e+00, 6.33345313e+00, 1796.52
10, 2.18561181e+00, 6.36020514e+00, 1796.52
11, 2.11826524e+00, 6.37467736e+00, 1796.52
12, 1.80702862e+00, 6.44401203e+00, 1796.52
13, 1.64602144e+00, 6.48088560e+00, 1796.52
14, 1.58552775e+00, 6.49496220e+00, 1796.52
15, 1.47557885e+00, 6.52118275e+00, 1796.52
16, 1.36978702e+00, 6.54722155e+00, 1796.52
17, 1.29300295e+00, 6.56667185e+00, 1796.52
18, 1.23487904e+00, 6.58185788e+00, 1796.52
19, 1.13326610e+00, 6.60969358e+00, 1796.52
20, 1.08815655e+00, 6.62253628e+00, 1796.52
21, 1.05133480e+00, 6.63333116e+00, 1796.52
22, 9.66160851e-01, 6.65954139e+00, 1796.52
23, 9.26190593e-01, 6.67241909e+00, 1796.52
24, 8.63703021e-01, 6.69353034e+00, 1796.52
25, 8.37768116e-01, 6.70263124e+00, 1796.52
26, 8.26667351e-01, 6.70659592e+00, 1796.52
27, 7.90428543e-01, 6.71986170e+00, 1796.52
28, 7.61820110e-01, 6.73067650e+00, 1796.52
29, 7.35038148e-01, 6.74110382e+00, 1796.52
30, 7.13673675e-01, 6.74964894e+00, 1796.52
31, 7.07278408e-01, 6.75224706e+00, 1796.52
32, 6.76311067e-01, 6.76512932e+00, 1796.52
33, 6.52025527e-01, 6.77556899e+00, 1796.52
34, 6.24402267e-01, 6.78783872e+00, 1796.52
35, 6.00520763e-01, 6.79878969e+00, 1796.52
36, 5.75033134e-01, 6.81083635e+00, 1796.52
37, 5.56581723e-01, 6.81978796e+00, 1796.52
38, 5.43583213e-01, 6.82620307e+00, 1796.52
39, 5.14613674e-01, 6.84081709e+00, 1796.52
40, 4.88693549e-01, 6.85421596e+00, 1796.52
41, 4.61734302e-01, 6.86842760e+00, 1796.52
42, 4.53434153e-01, 6.87284817e+00, 1796.52
43, 4.31372554e-01, 6.88468598e+00, 1796.52
44, 4.24927622e-01, 6.88816216e+00, 1796.52
45, 4.03899413e-01, 6.89955280e+00, 1796.52
46, 3.79463832e-01, 6.91282348e+00, 1796.52
47, 3.52241882e-01, 6.92758657e+00, 1796.52
48, 3.42441288e-01, 6.93287875e+00, 1796.52
49, 3.32917285e-01, 6.93800372e+00, 1796.52
50, 3.17716165e-01, 6.94614282e+00, 1796.52
```

## arquivo lcurve_30x30_g1_sparse_precond.csv
```csv
Iteration,SolutionNorm,ResidualNorm
1,0.00000000e+00,9.67196382e+00
2,1.55898777e+00,3.07252139e+00
3,1.77603493e+00,1.53729417e+00
4,1.79399258e+00,1.39883468e+00
5,1.84883524e+00,1.01019361e+00
6,1.86481978e+00,8.97468112e-01
7,1.86894946e+00,8.68404273e-01
8,1.90461444e+00,6.28412797e-01
9,1.91467888e+00,5.59264782e-01
10,1.91887859e+00,5.30052585e-01
11,1.92355181e+00,4.97479833e-01
12,1.93544815e+00,4.14268921e-01
13,1.94220317e+00,3.65674578e-01
14,1.94721209e+00,3.29254234e-01
15,1.95075872e+00,3.03495583e-01
16,1.95419823e+00,2.78732101e-01
17,1.95561550e+00,2.68664181e-01
18,1.95882596e+00,2.46373566e-01
19,1.96191567e+00,2.25538000e-01
20,1.96495649e+00,2.05668964e-01
21,1.96645522e+00,1.96093519e-01
22,1.96812171e+00,1.85659999e-01
23,1.97005770e+00,1.73864957e-01
24,1.97185532e+00,1.63240358e-01
25,1.97383060e+00,1.51970632e-01
26,1.97438909e+00,1.48852344e-01
27,1.97638024e+00,1.37982239e-01
28,1.97737932e+00,1.32656763e-01
29,1.97870045e+00,1.25749048e-01
30,1.97911473e+00,1.23607305e-01
31,1.98090328e+00,1.14523371e-01
32,1.98280764e+00,1.05095830e-01
33,1.98370216e+00,1.00734155e-01
34,1.98536222e+00,9.27383430e-02
35,1.98676886e+00,8.60193691e-02
36,1.98719857e+00,8.39698276e-02
37,1.98844424e+00,7.80321740e-02
38,1.98943704e+00,7.32812572e-02
39,1.99064716e+00,6.74433522e-02
40,1.99125831e+00,6.44618592e-02
41,1.99184752e+00,6.15617841e-02
42,1.99261786e+00,5.77193876e-02
43,1.99277308e+00,5.69357620e-02
44,1.99378588e+00,5.17399209e-02
45,1.99453063e+00,4.77952867e-02
46,1.99568957e+00,4.13555914e-02
47,1.99582484e+00,4.05709750e-02
48,1.99642400e+00,3.69892680e-02
49,1.99702200e+00,3.31973231e-02
50,1.99731703e+00,3.12226361e-02
```

## arquivo lcurve_30x30_g1_sparse_standard.csv
```csv
Iteration,SolutionNorm,ResidualNorm
1,0.00000000e+00,9.67196382e+00
2,1.55898777e+00,3.07252139e+00
3,1.77603493e+00,1.53729417e+00
4,1.79399258e+00,1.39883468e+00
5,1.84883524e+00,1.01019361e+00
6,1.86481978e+00,8.97468112e-01
7,1.86894946e+00,8.68404273e-01
8,1.90461444e+00,6.28412797e-01
9,1.91467888e+00,5.59264782e-01
10,1.91887859e+00,5.30052585e-01
11,1.92355181e+00,4.97479833e-01
12,1.93544815e+00,4.14268921e-01
13,1.94220317e+00,3.65674578e-01
14,1.94721209e+00,3.29254234e-01
15,1.95075872e+00,3.03495583e-01
16,1.95419823e+00,2.78732101e-01
17,1.95561550e+00,2.68664181e-01
18,1.95882596e+00,2.46373566e-01
19,1.96191567e+00,2.25538000e-01
20,1.96495649e+00,2.05668964e-01
21,1.96645522e+00,1.96093519e-01
22,1.96812171e+00,1.85659999e-01
23,1.97005770e+00,1.73864957e-01
24,1.97185532e+00,1.63240358e-01
25,1.97383060e+00,1.51970632e-01
26,1.97438909e+00,1.48852344e-01
27,1.97638024e+00,1.37982239e-01
28,1.97737932e+00,1.32656763e-01
29,1.97870045e+00,1.25749048e-01
30,1.97911473e+00,1.23607305e-01
31,1.98090328e+00,1.14523371e-01
32,1.98280764e+00,1.05095830e-01
33,1.98370216e+00,1.00734155e-01
34,1.98536222e+00,9.27383430e-02
35,1.98676886e+00,8.60193691e-02
36,1.98719857e+00,8.39698276e-02
37,1.98844424e+00,7.80321740e-02
38,1.98943704e+00,7.32812572e-02
39,1.99064716e+00,6.74433522e-02
40,1.99125831e+00,6.44618592e-02
41,1.99184752e+00,6.15617841e-02
42,1.99261786e+00,5.77193876e-02
43,1.99277308e+00,5.69357620e-02
44,1.99378588e+00,5.17399209e-02
45,1.99453063e+00,4.77952867e-02
46,1.99568957e+00,4.13555914e-02
47,1.99582484e+00,4.05709750e-02
48,1.99642400e+00,3.69892680e-02
49,1.99702200e+00,3.31973231e-02
50,1.99731703e+00,3.12226361e-02
```

## arquivo lcurve_30x30_g2_sparse_precond.csv
```csv
Iteration,SolutionNorm,ResidualNorm
1,0.00000000e+00,1.20736878e+01
2,1.87462201e+00,4.02351777e+00
3,1.92042055e+00,3.65398977e+00
4,2.02751235e+00,2.89073698e+00
5,2.10462469e+00,2.36115773e+00
6,2.17845004e+00,1.84100587e+00
7,2.20365158e+00,1.65829698e+00
8,2.22203672e+00,1.52680971e+00
9,2.25500822e+00,1.29867800e+00
10,2.29328838e+00,1.04314309e+00
11,2.30689009e+00,9.52876436e-01
12,2.32457823e+00,8.36827460e-01
13,2.34472561e+00,7.05063906e-01
14,2.35726912e+00,6.21843740e-01
15,2.36910719e+00,5.42210316e-01
16,2.37946642e+00,4.71904883e-01
17,2.38676801e+00,4.22139493e-01
18,2.39307923e+00,3.79399672e-01
19,2.39790904e+00,3.47102850e-01
20,2.40146776e+00,3.23602566e-01
21,2.40635206e+00,2.91820472e-01
22,2.41026993e+00,2.66636569e-01
23,2.41281187e+00,2.50468187e-01
24,2.41406651e+00,2.42540978e-01
25,2.41658517e+00,2.26735977e-01
26,2.41840525e+00,2.15403395e-01
27,2.41936889e+00,2.09439014e-01
28,2.42141240e+00,1.96883253e-01
29,2.42434817e+00,1.79024616e-01
30,2.42713125e+00,1.62278098e-01
31,2.42929646e+00,1.49359351e-01
32,2.43076747e+00,1.40612539e-01
33,2.43279226e+00,1.28604897e-01
34,2.43363739e+00,1.23590971e-01
35,2.43467614e+00,1.17413038e-01
36,2.43652404e+00,1.06360514e-01
37,2.43786257e+00,9.82513480e-02
38,2.43848301e+00,9.44520797e-02
39,2.43933224e+00,8.92032748e-02
40,2.44054084e+00,8.16144141e-02
41,2.44109713e+00,7.80644355e-02
42,2.44181197e+00,7.34411349e-02
43,2.44277183e+00,6.70947154e-02
44,2.44317600e+00,6.43651366e-02
45,2.44350750e+00,6.20965302e-02
46,2.44425717e+00,5.68552688e-02
47,2.44497562e+00,5.16576625e-02
48,2.44563559e+00,4.66946130e-02
49,2.44618314e+00,4.23960938e-02
50,2.44669296e+00,3.81925719e-02
```

## arquivo lcurve_30x30_g2_sparse_standard.csv
```csv
Iteration,SolutionNorm,ResidualNorm
1,0.00000000e+00,1.20736878e+01
2,1.87462201e+00,4.02351777e+00
3,1.92042055e+00,3.65398977e+00
4,2.02751235e+00,2.89073698e+00
5,2.10462469e+00,2.36115773e+00
6,2.17845004e+00,1.84100587e+00
7,2.20365158e+00,1.65829698e+00
8,2.22203672e+00,1.52680971e+00
9,2.25500822e+00,1.29867800e+00
10,2.29328838e+00,1.04314309e+00
11,2.30689009e+00,9.52876436e-01
12,2.32457823e+00,8.36827460e-01
13,2.34472561e+00,7.05063906e-01
14,2.35726912e+00,6.21843740e-01
15,2.36910719e+00,5.42210316e-01
16,2.37946642e+00,4.71904883e-01
17,2.38676801e+00,4.22139493e-01
18,2.39307923e+00,3.79399672e-01
19,2.39790904e+00,3.47102850e-01
20,2.40146776e+00,3.23602566e-01
21,2.40635206e+00,2.91820472e-01
22,2.41026993e+00,2.66636569e-01
23,2.41281187e+00,2.50468187e-01
24,2.41406651e+00,2.42540978e-01
25,2.41658517e+00,2.26735977e-01
26,2.41840525e+00,2.15403395e-01
27,2.41936889e+00,2.09439014e-01
28,2.42141240e+00,1.96883253e-01
29,2.42434817e+00,1.79024616e-01
30,2.42713125e+00,1.62278098e-01
31,2.42929646e+00,1.49359351e-01
32,2.43076747e+00,1.40612539e-01
33,2.43279226e+00,1.28604897e-01
34,2.43363739e+00,1.23590971e-01
35,2.43467614e+00,1.17413038e-01
36,2.43652404e+00,1.06360514e-01
37,2.43786257e+00,9.82513480e-02
38,2.43848301e+00,9.44520797e-02
39,2.43933224e+00,8.92032748e-02
40,2.44054084e+00,8.16144141e-02
41,2.44109713e+00,7.80644355e-02
42,2.44181197e+00,7.34411349e-02
43,2.44277183e+00,6.70947154e-02
44,2.44317600e+00,6.43651366e-02
45,2.44350750e+00,6.20965302e-02
46,2.44425717e+00,5.68552688e-02
47,2.44497562e+00,5.16576625e-02
48,2.44563559e+00,4.66946130e-02
49,2.44618314e+00,4.23960938e-02
50,2.44669296e+00,3.81925719e-02
```

## arquivo lcurve_60x60_G1_sparse_precond.csv
```csv
Iteration,SolutionNorm,ResidualNorm
1,0.00000000e+00,1.54640017e+01
2,2.95333226e+00,6.17186055e+00
3,3.53454207e+00,3.55670287e+00
4,3.65843662e+00,2.99761919e+00
5,3.79383539e+00,2.39219064e+00
6,3.83375295e+00,2.20794552e+00
7,3.86563639e+00,2.06309467e+00
8,3.95979300e+00,1.65101719e+00
9,3.98705940e+00,1.53108700e+00
10,3.99666487e+00,1.48873863e+00
11,4.04632060e+00,1.27397610e+00
12,4.08665265e+00,1.09950505e+00
13,4.10543978e+00,1.01686809e+00
14,4.11776744e+00,9.62496045e-01
15,4.14771050e+00,8.30742658e-01
16,4.16472755e+00,7.54658503e-01
17,4.17736234e+00,6.97633203e-01
18,4.19699293e+00,6.09044074e-01
19,4.20463616e+00,5.74370142e-01
20,4.21067073e+00,5.47074792e-01
21,4.22259198e+00,4.93735822e-01
22,4.23017365e+00,4.60063338e-01
23,4.23556708e+00,4.36327929e-01
24,4.23882770e+00,4.22122183e-01
25,4.24221920e+00,4.07458113e-01
26,4.24709560e+00,3.86592624e-01
27,4.25156603e+00,3.67773193e-01
28,4.25554085e+00,3.51352487e-01
29,4.25900523e+00,3.37303201e-01
30,4.26015230e+00,3.32705820e-01
31,4.26419592e+00,3.16792358e-01
32,4.26783713e+00,3.02864662e-01
33,4.27056620e+00,2.92696259e-01
34,4.27422411e+00,2.79480043e-01
35,4.27707327e+00,2.69498835e-01
36,4.27956963e+00,2.60982189e-01
37,4.28123787e+00,2.55407974e-01
38,4.28450471e+00,2.44748328e-01
39,4.28758357e+00,2.34985558e-01
40,4.29114831e+00,2.24014319e-01
41,4.29230893e+00,2.20511592e-01
42,4.29414141e+00,2.15047233e-01
43,4.29558664e+00,2.10788939e-01
44,4.29905867e+00,2.00735989e-01
45,4.30321700e+00,1.88971778e-01
46,4.30716195e+00,1.78014403e-01
47,4.30939586e+00,1.71872318e-01
48,4.31059084e+00,1.68601238e-01
49,4.31382943e+00,1.59768365e-01
50,4.31627224e+00,1.53117654e-01
```

## arquivo lcurve_60x60_G1_sparse_standard.csv
```csv
Iteration,SolutionNorm,ResidualNorm
1,0.00000000e+00,1.54640017e+01
2,2.95333226e+00,6.17186055e+00
3,3.53454207e+00,3.55670287e+00
4,3.65843662e+00,2.99761919e+00
5,3.79383539e+00,2.39219064e+00
6,3.83375295e+00,2.20794552e+00
7,3.86563639e+00,2.06309467e+00
8,3.95979300e+00,1.65101719e+00
9,3.98705940e+00,1.53108700e+00
10,3.99666487e+00,1.48873863e+00
11,4.04632060e+00,1.27397610e+00
12,4.08665265e+00,1.09950505e+00
13,4.10543978e+00,1.01686809e+00
14,4.11776744e+00,9.62496045e-01
15,4.14771050e+00,8.30742658e-01
16,4.16472755e+00,7.54658503e-01
17,4.17736234e+00,6.97633203e-01
18,4.19699293e+00,6.09044074e-01
19,4.20463616e+00,5.74370142e-01
20,4.21067073e+00,5.47074792e-01
21,4.22259198e+00,4.93735822e-01
22,4.23017365e+00,4.60063338e-01
23,4.23556708e+00,4.36327929e-01
24,4.23882770e+00,4.22122183e-01
25,4.24221920e+00,4.07458113e-01
26,4.24709560e+00,3.86592624e-01
27,4.25156603e+00,3.67773193e-01
28,4.25554085e+00,3.51352487e-01
29,4.25900523e+00,3.37303201e-01
30,4.26015230e+00,3.32705820e-01
31,4.26419592e+00,3.16792358e-01
32,4.26783713e+00,3.02864662e-01
33,4.27056620e+00,2.92696259e-01
34,4.27422411e+00,2.79480043e-01
35,4.27707327e+00,2.69498835e-01
36,4.27956963e+00,2.60982189e-01
37,4.28123787e+00,2.55407974e-01
38,4.28450471e+00,2.44748328e-01
39,4.28758357e+00,2.34985558e-01
40,4.29114831e+00,2.24014319e-01
41,4.29230893e+00,2.20511592e-01
42,4.29414141e+00,2.15047233e-01
43,4.29558664e+00,2.10788939e-01
44,4.29905867e+00,2.00735989e-01
45,4.30321700e+00,1.88971778e-01
46,4.30716195e+00,1.78014403e-01
47,4.30939586e+00,1.71872318e-01
48,4.31059084e+00,1.68601238e-01
49,4.31382943e+00,1.59768365e-01
50,4.31627224e+00,1.53117654e-01
```

## arquivo lcurve_60x60_G2_sparse_precond.csv
```csv
Iteration,SolutionNorm,ResidualNorm
1,0.00000000e+00,2.72014132e+01
2,5.18085941e+00,8.78975958e+00
3,5.79821908e+00,5.12351791e+00
4,5.97246712e+00,4.14430725e+00
5,6.11609297e+00,3.38780189e+00
6,6.14586604e+00,3.23059750e+00
7,6.18577967e+00,3.02412857e+00
8,6.25856680e+00,2.66597172e+00
9,6.33345313e+00,2.31106204e+00
10,6.36020514e+00,2.18561181e+00
11,6.37467736e+00,2.11826524e+00
12,6.44401203e+00,1.80702862e+00
13,6.48088560e+00,1.64602144e+00
14,6.49496220e+00,1.58552775e+00
15,6.52118275e+00,1.47557885e+00
16,6.54722155e+00,1.36978702e+00
17,6.56667185e+00,1.29300295e+00
18,6.58185788e+00,1.23487904e+00
19,6.60969358e+00,1.13326610e+00
20,6.62253628e+00,1.08815655e+00
21,6.63333116e+00,1.05133480e+00
22,6.65954139e+00,9.66160851e-01
23,6.67241909e+00,9.26190593e-01
24,6.69353034e+00,8.63703021e-01
25,6.70263124e+00,8.37768116e-01
26,6.70659592e+00,8.26667351e-01
27,6.71986170e+00,7.90428543e-01
28,6.73067650e+00,7.61820110e-01
29,6.74110382e+00,7.35038148e-01
30,6.74964894e+00,7.13673675e-01
31,6.75224706e+00,7.07278408e-01
32,6.76512932e+00,6.76311067e-01
33,6.77556899e+00,6.52025527e-01
34,6.78783872e+00,6.24402267e-01
35,6.79878969e+00,6.00520763e-01
36,6.81083635e+00,5.75033134e-01
37,6.81978796e+00,5.56581723e-01
38,6.82620307e+00,5.43583213e-01
39,6.84081709e+00,5.14613674e-01
40,6.85421596e+00,4.88693549e-01
41,6.86842760e+00,4.61734302e-01
42,6.87284817e+00,4.53434153e-01
43,6.88468598e+00,4.31372554e-01
44,6.88816216e+00,4.24927622e-01
45,6.89955280e+00,4.03899413e-01
46,6.91282348e+00,3.79463832e-01
47,6.92758657e+00,3.52241882e-01
48,6.93287875e+00,3.42441288e-01
49,6.93800372e+00,3.32917285e-01
50,6.94614282e+00,3.17716165e-01
```

## arquivo lcurve_60x60_G2_sparse_standard.csv
```csv
Iteration,SolutionNorm,ResidualNorm
1,0.00000000e+00,2.72014132e+01
2,5.18085941e+00,8.78975958e+00
3,5.79821908e+00,5.12351791e+00
4,5.97246712e+00,4.14430725e+00
5,6.11609297e+00,3.38780189e+00
6,6.14586604e+00,3.23059750e+00
7,6.18577967e+00,3.02412857e+00
8,6.25856680e+00,2.66597172e+00
9,6.33345313e+00,2.31106204e+00
10,6.36020514e+00,2.18561181e+00
11,6.37467736e+00,2.11826524e+00
12,6.44401203e+00,1.80702862e+00
13,6.48088560e+00,1.64602144e+00
14,6.49496220e+00,1.58552775e+00
15,6.52118275e+00,1.47557885e+00
16,6.54722155e+00,1.36978702e+00
17,6.56667185e+00,1.29300295e+00
18,6.58185788e+00,1.23487904e+00
19,6.60969358e+00,1.13326610e+00
20,6.62253628e+00,1.08815655e+00
21,6.63333116e+00,1.05133480e+00
22,6.65954139e+00,9.66160851e-01
23,6.67241909e+00,9.26190593e-01
24,6.69353034e+00,8.63703021e-01
25,6.70263124e+00,8.37768116e-01
26,6.70659592e+00,8.26667351e-01
27,6.71986170e+00,7.90428543e-01
28,6.73067650e+00,7.61820110e-01
29,6.74110382e+00,7.35038148e-01
30,6.74964894e+00,7.13673675e-01
31,6.75224706e+00,7.07278408e-01
32,6.76512932e+00,6.76311067e-01
33,6.77556899e+00,6.52025527e-01
34,6.78783872e+00,6.24402267e-01
35,6.79878969e+00,6.00520763e-01
36,6.81083635e+00,5.75033134e-01
37,6.81978796e+00,5.56581723e-01
38,6.82620307e+00,5.43583213e-01
39,6.84081709e+00,5.14613674e-01
40,6.85421596e+00,4.88693549e-01
41,6.86842760e+00,4.61734302e-01
42,6.87284817e+00,4.53434153e-01
43,6.88468598e+00,4.31372554e-01
44,6.88816216e+00,4.24927622e-01
45,6.89955280e+00,4.03899413e-01
46,6.91282348e+00,3.79463832e-01
47,6.92758657e+00,3.52241882e-01
48,6.93287875e+00,3.42441288e-01
49,6.93800372e+00,3.32917285e-01
50,6.94614282e+00,3.17716165e-01
```

## arquivo convergence_history_30x30_g1_sparse_precond.csv
```csv
Iteration,ResidualNorm,SolutionNorm,ExecutionTime_ms
1, 9.67196382e+00, 0.00000000e+00, 455.05
2, 3.07252139e+00, 1.55898777e+00, 455.05
3, 1.53729417e+00, 1.77603493e+00, 455.05
4, 1.39883468e+00, 1.79399258e+00, 455.05
5, 1.01019361e+00, 1.84883524e+00, 455.05
6, 8.97468112e-01, 1.86481978e+00, 455.05
7, 8.68404273e-01, 1.86894946e+00, 455.05
8, 6.28412797e-01, 1.90461444e+00, 455.05
9, 5.59264782e-01, 1.91467888e+00, 455.05
10, 5.30052585e-01, 1.91887859e+00, 455.05
11, 4.97479833e-01, 1.92355181e+00, 455.05
12, 4.14268921e-01, 1.93544815e+00, 455.05
13, 3.65674578e-01, 1.94220317e+00, 455.05
14, 3.29254234e-01, 1.94721209e+00, 455.05
15, 3.03495583e-01, 1.95075872e+00, 455.05
16, 2.78732101e-01, 1.95419823e+00, 455.05
17, 2.68664181e-01, 1.95561550e+00, 455.05
18, 2.46373566e-01, 1.95882596e+00, 455.05
19, 2.25538000e-01, 1.96191567e+00, 455.05
20, 2.05668964e-01, 1.96495649e+00, 455.05
21, 1.96093519e-01, 1.96645522e+00, 455.05
22, 1.85659999e-01, 1.96812171e+00, 455.05
23, 1.73864957e-01, 1.97005770e+00, 455.05
24, 1.63240358e-01, 1.97185532e+00, 455.05
25, 1.51970632e-01, 1.97383060e+00, 455.05
26, 1.48852344e-01, 1.97438909e+00, 455.05
27, 1.37982239e-01, 1.97638024e+00, 455.05
28, 1.32656763e-01, 1.97737932e+00, 455.05
29, 1.25749048e-01, 1.97870045e+00, 455.05
30, 1.23607305e-01, 1.97911473e+00, 455.05
31, 1.14523371e-01, 1.98090328e+00, 455.05
32, 1.05095830e-01, 1.98280764e+00, 455.05
33, 1.00734155e-01, 1.98370216e+00, 455.05
34, 9.27383430e-02, 1.98536222e+00, 455.05
35, 8.60193691e-02, 1.98676886e+00, 455.05
36, 8.39698276e-02, 1.98719857e+00, 455.05
37, 7.80321740e-02, 1.98844424e+00, 455.05
38, 7.32812572e-02, 1.98943704e+00, 455.05
39, 6.74433522e-02, 1.99064716e+00, 455.05
40, 6.44618592e-02, 1.99125831e+00, 455.05
41, 6.15617841e-02, 1.99184752e+00, 455.05
42, 5.77193876e-02, 1.99261786e+00, 455.05
43, 5.69357620e-02, 1.99277308e+00, 455.05
44, 5.17399209e-02, 1.99378588e+00, 455.05
45, 4.77952867e-02, 1.99453063e+00, 455.05
46, 4.13555914e-02, 1.99568957e+00, 455.05
47, 4.05709750e-02, 1.99582484e+00, 455.05
48, 3.69892680e-02, 1.99642400e+00, 455.05
49, 3.31973231e-02, 1.99702200e+00, 455.05
50, 3.12226361e-02, 1.99731703e+00, 455.05
```

## arquivo convergence_history_30x30_g1_sparse_standard.csv
```csv
Iteration,ResidualNorm,SolutionNorm,ExecutionTime_ms
1, 9.67196382e+00, 0.00000000e+00, 423.21
2, 3.07252139e+00, 1.55898777e+00, 423.21
3, 1.53729417e+00, 1.77603493e+00, 423.21
4, 1.39883468e+00, 1.79399258e+00, 423.21
5, 1.01019361e+00, 1.84883524e+00, 423.21
6, 8.97468112e-01, 1.86481978e+00, 423.21
7, 8.68404273e-01, 1.86894946e+00, 423.21
8, 6.28412797e-01, 1.90461444e+00, 423.21
9, 5.59264782e-01, 1.91467888e+00, 423.21
10, 5.30052585e-01, 1.91887859e+00, 423.21
11, 4.97479833e-01, 1.92355181e+00, 423.21
12, 4.14268921e-01, 1.93544815e+00, 423.21
13, 3.65674578e-01, 1.94220317e+00, 423.21
14, 3.29254234e-01, 1.94721209e+00, 423.21
15, 3.03495583e-01, 1.95075872e+00, 423.21
16, 2.78732101e-01, 1.95419823e+00, 423.21
17, 2.68664181e-01, 1.95561550e+00, 423.21
18, 2.46373566e-01, 1.95882596e+00, 423.21
19, 2.25538000e-01, 1.96191567e+00, 423.21
20, 2.05668964e-01, 1.96495649e+00, 423.21
21, 1.96093519e-01, 1.96645522e+00, 423.21
22, 1.85659999e-01, 1.96812171e+00, 423.21
23, 1.73864957e-01, 1.97005770e+00, 423.21
24, 1.63240358e-01, 1.97185532e+00, 423.21
25, 1.51970632e-01, 1.97383060e+00, 423.21
26, 1.48852344e-01, 1.97438909e+00, 423.21
27, 1.37982239e-01, 1.97638024e+00, 423.21
28, 1.32656763e-01, 1.97737932e+00, 423.21
29, 1.25749048e-01, 1.97870045e+00, 423.21
30, 1.23607305e-01, 1.97911473e+00, 423.21
31, 1.14523371e-01, 1.98090328e+00, 423.21
32, 1.05095830e-01, 1.98280764e+00, 423.21
33, 1.00734155e-01, 1.98370216e+00, 423.21
34, 9.27383430e-02, 1.98536222e+00, 423.21
35, 8.60193691e-02, 1.98676886e+00, 423.21
36, 8.39698276e-02, 1.98719857e+00, 423.21
37, 7.80321740e-02, 1.98844424e+00, 423.21
38, 7.32812572e-02, 1.98943704e+00, 423.21
39, 6.74433522e-02, 1.99064716e+00, 423.21
40, 6.44618592e-02, 1.99125831e+00, 423.21
41, 6.15617841e-02, 1.99184752e+00, 423.21
42, 5.77193876e-02, 1.99261786e+00, 423.21
43, 5.69357620e-02, 1.99277308e+00, 423.21
44, 5.17399209e-02, 1.99378588e+00, 423.21
45, 4.77952867e-02, 1.99453063e+00, 423.21
46, 4.13555914e-02, 1.99568957e+00, 423.21
47, 4.05709750e-02, 1.99582484e+00, 423.21
48, 3.69892680e-02, 1.99642400e+00, 423.21
49, 3.31973231e-02, 1.99702200e+00, 423.21
50, 3.12226361e-02, 1.99731703e+00, 423.21
```

## arquivo convergence_history_30x30_g2_sparse_precond.csv
```csv
Iteration,ResidualNorm,SolutionNorm,ExecutionTime_ms
1, 1.20736878e+01, 0.00000000e+00, 416.88
2, 4.02351777e+00, 1.87462201e+00, 416.88
3, 3.65398977e+00, 1.92042055e+00, 416.88
4, 2.89073698e+00, 2.02751235e+00, 416.88
5, 2.36115773e+00, 2.10462469e+00, 416.88
6, 1.84100587e+00, 2.17845004e+00, 416.88
7, 1.65829698e+00, 2.20365158e+00, 416.88
8, 1.52680971e+00, 2.22203672e+00, 416.88
9, 1.29867800e+00, 2.25500822e+00, 416.88
10, 1.04314309e+00, 2.29328838e+00, 416.88
11, 9.52876436e-01, 2.30689009e+00, 416.88
12, 8.36827460e-01, 2.32457823e+00, 416.88
13, 7.05063906e-01, 2.34472561e+00, 416.88
14, 6.21843740e-01, 2.35726912e+00, 416.88
15, 5.42210316e-01, 2.36910719e+00, 416.88
16, 4.71904883e-01, 2.37946642e+00, 416.88
17, 4.22139493e-01, 2.38676801e+00, 416.88
18, 3.79399672e-01, 2.39307923e+00, 416.88
19, 3.47102850e-01, 2.39790904e+00, 416.88
20, 3.23602566e-01, 2.40146776e+00, 416.88
21, 2.91820472e-01, 2.40635206e+00, 416.88
22, 2.66636569e-01, 2.41026993e+00, 416.88
23, 2.50468187e-01, 2.41281187e+00, 416.88
24, 2.42540978e-01, 2.41406651e+00, 416.88
25, 2.26735977e-01, 2.41658517e+00, 416.88
26, 2.15403395e-01, 2.41840525e+00, 416.88
27, 2.09439014e-01, 2.41936889e+00, 416.88
28, 1.96883253e-01, 2.42141240e+00, 416.88
29, 1.79024616e-01, 2.42434817e+00, 416.88
30, 1.62278098e-01, 2.42713125e+00, 416.88
31, 1.49359351e-01, 2.42929646e+00, 416.88
32, 1.40612539e-01, 2.43076747e+00, 416.88
33, 1.28604897e-01, 2.43279226e+00, 416.88
34, 1.23590971e-01, 2.43363739e+00, 416.88
35, 1.17413038e-01, 2.43467614e+00, 416.88
36, 1.06360514e-01, 2.43652404e+00, 416.88
37, 9.82513480e-02, 2.43786257e+00, 416.88
38, 9.44520797e-02, 2.43848301e+00, 416.88
39, 8.92032748e-02, 2.43933224e+00, 416.88
40, 8.16144141e-02, 2.44054084e+00, 416.88
41, 7.80644355e-02, 2.44109713e+00, 416.88
42, 7.34411349e-02, 2.44181197e+00, 416.88
43, 6.70947154e-02, 2.44277183e+00, 416.88
44, 6.43651366e-02, 2.44317600e+00, 416.88
45, 6.20965302e-02, 2.44350750e+00, 416.88
46, 5.68552688e-02, 2.44425717e+00, 416.88
47, 5.16576625e-02, 2.44497562e+00, 416.88
48, 4.66946130e-02, 2.44563559e+00, 416.88
49, 4.23960938e-02, 2.44618314e+00, 416.88
50, 3.81925719e-02, 2.44669296e+00, 416.88
```

## arquivo convergence_history_30x30_g2_sparse_standard.csv
```csv
Iteration,ResidualNorm,SolutionNorm,ExecutionTime_ms
1, 1.20736878e+01, 0.00000000e+00, 439.40
2, 4.02351777e+00, 1.87462201e+00, 439.40
3, 3.65398977e+00, 1.92042055e+00, 439.40
4, 2.89073698e+00, 2.02751235e+00, 439.40
5, 2.36115773e+00, 2.10462469e+00, 439.40
6, 1.84100587e+00, 2.17845004e+00, 439.40
7, 1.65829698e+00, 2.20365158e+00, 439.40
8, 1.52680971e+00, 2.22203672e+00, 439.40
9, 1.29867800e+00, 2.25500822e+00, 439.40
10, 1.04314309e+00, 2.29328838e+00, 439.40
11, 9.52876436e-01, 2.30689009e+00, 439.40
12, 8.36827460e-01, 2.32457823e+00, 439.40
13, 7.05063906e-01, 2.34472561e+00, 439.40
14, 6.21843740e-01, 2.35726912e+00, 439.40
15, 5.42210316e-01, 2.36910719e+00, 439.40
16, 4.71904883e-01, 2.37946642e+00, 439.40
17, 4.22139493e-01, 2.38676801e+00, 439.40
18, 3.79399672e-01, 2.39307923e+00, 439.40
19, 3.47102850e-01, 2.39790904e+00, 439.40
20, 3.23602566e-01, 2.40146776e+00, 439.40
21, 2.91820472e-01, 2.40635206e+00, 439.40
22, 2.66636569e-01, 2.41026993e+00, 439.40
23, 2.50468187e-01, 2.41281187e+00, 439.40
24, 2.42540978e-01, 2.41406651e+00, 439.40
25, 2.26735977e-01, 2.41658517e+00, 439.40
26, 2.15403395e-01, 2.41840525e+00, 439.40
27, 2.09439014e-01, 2.41936889e+00, 439.40
28, 1.96883253e-01, 2.42141240e+00, 439.40
29, 1.79024616e-01, 2.42434817e+00, 439.40
30, 1.62278098e-01, 2.42713125e+00, 439.40
31, 1.49359351e-01, 2.42929646e+00, 439.40
32, 1.40612539e-01, 2.43076747e+00, 439.40
33, 1.28604897e-01, 2.43279226e+00, 439.40
34, 1.23590971e-01, 2.43363739e+00, 439.40
35, 1.17413038e-01, 2.43467614e+00, 439.40
36, 1.06360514e-01, 2.43652404e+00, 439.40
37, 9.82513480e-02, 2.43786257e+00, 439.40
38, 9.44520797e-02, 2.43848301e+00, 439.40
39, 8.92032748e-02, 2.43933224e+00, 439.40
40, 8.16144141e-02, 2.44054084e+00, 439.40
41, 7.80644355e-02, 2.44109713e+00, 439.40
42, 7.34411349e-02, 2.44181197e+00, 439.40
43, 6.70947154e-02, 2.44277183e+00, 439.40
44, 6.43651366e-02, 2.44317600e+00, 439.40
45, 6.20965302e-02, 2.44350750e+00, 439.40
46, 5.68552688e-02, 2.44425717e+00, 439.40
47, 5.16576625e-02, 2.44497562e+00, 439.40
48, 4.66946130e-02, 2.44563559e+00, 439.40
49, 4.23960938e-02, 2.44618314e+00, 439.40
50, 3.81925719e-02, 2.44669296e+00, 439.40
```

## arquivo convergence_history_60x60_G1_sparse_precond.csv
```csv
Iteration,ResidualNorm,SolutionNorm,ExecutionTime_ms
1, 1.54640017e+01, 0.00000000e+00, 1855.06
2, 6.17186055e+00, 2.95333226e+00, 1855.06
3, 3.55670287e+00, 3.53454207e+00, 1855.06
4, 2.99761919e+00, 3.65843662e+00, 1855.06
5, 2.39219064e+00, 3.79383539e+00, 1855.06
6, 2.20794552e+00, 3.83375295e+00, 1855.06
7, 2.06309467e+00, 3.86563639e+00, 1855.06
8, 1.65101719e+00, 3.95979300e+00, 1855.06
9, 1.53108700e+00, 3.98705940e+00, 1855.06
10, 1.48873863e+00, 3.99666487e+00, 1855.06
11, 1.27397610e+00, 4.04632060e+00, 1855.06
12, 1.09950505e+00, 4.08665265e+00, 1855.06
13, 1.01686809e+00, 4.10543978e+00, 1855.06
14, 9.62496045e-01, 4.11776744e+00, 1855.06
15, 8.30742658e-01, 4.14771050e+00, 1855.06
16, 7.54658503e-01, 4.16472755e+00, 1855.06
17, 6.97633203e-01, 4.17736234e+00, 1855.06
18, 6.09044074e-01, 4.19699293e+00, 1855.06
19, 5.74370142e-01, 4.20463616e+00, 1855.06
20, 5.47074792e-01, 4.21067073e+00, 1855.06
21, 4.93735822e-01, 4.22259198e+00, 1855.06
22, 4.60063338e-01, 4.23017365e+00, 1855.06
23, 4.36327929e-01, 4.23556708e+00, 1855.06
24, 4.22122183e-01, 4.23882770e+00, 1855.06
25, 4.07458113e-01, 4.24221920e+00, 1855.06
26, 3.86592624e-01, 4.24709560e+00, 1855.06
27, 3.67773193e-01, 4.25156603e+00, 1855.06
28, 3.51352487e-01, 4.25554085e+00, 1855.06
29, 3.37303201e-01, 4.25900523e+00, 1855.06
30, 3.32705820e-01, 4.26015230e+00, 1855.06
31, 3.16792358e-01, 4.26419592e+00, 1855.06
32, 3.02864662e-01, 4.26783713e+00, 1855.06
33, 2.92696259e-01, 4.27056620e+00, 1855.06
34, 2.79480043e-01, 4.27422411e+00, 1855.06
35, 2.69498835e-01, 4.27707327e+00, 1855.06
36, 2.60982189e-01, 4.27956963e+00, 1855.06
37, 2.55407974e-01, 4.28123787e+00, 1855.06
38, 2.44748328e-01, 4.28450471e+00, 1855.06
39, 2.34985558e-01, 4.28758357e+00, 1855.06
40, 2.24014319e-01, 4.29114831e+00, 1855.06
41, 2.20511592e-01, 4.29230893e+00, 1855.06
42, 2.15047233e-01, 4.29414141e+00, 1855.06
43, 2.10788939e-01, 4.29558664e+00, 1855.06
44, 2.00735989e-01, 4.29905867e+00, 1855.06
45, 1.88971778e-01, 4.30321700e+00, 1855.06
46, 1.78014403e-01, 4.30716195e+00, 1855.06
47, 1.71872318e-01, 4.30939586e+00, 1855.06
48, 1.68601238e-01, 4.31059084e+00, 1855.06
49, 1.59768365e-01, 4.31382943e+00, 1855.06
50, 1.53117654e-01, 4.31627224e+00, 1855.06
```

## arquivo convergence_history_60x60_G1_sparse_standard.csv
```csv
Iteration,ResidualNorm,SolutionNorm,ExecutionTime_ms
1, 1.54640017e+01, 0.00000000e+00, 1887.10
2, 6.17186055e+00, 2.95333226e+00, 1887.10
3, 3.55670287e+00, 3.53454207e+00, 1887.10
4, 2.99761919e+00, 3.65843662e+00, 1887.10
5, 2.39219064e+00, 3.79383539e+00, 1887.10
6, 2.20794552e+00, 3.83375295e+00, 1887.10
7, 2.06309467e+00, 3.86563639e+00, 1887.10
8, 1.65101719e+00, 3.95979300e+00, 1887.10
9, 1.53108700e+00, 3.98705940e+00, 1887.10
10, 1.48873863e+00, 3.99666487e+00, 1887.10
11, 1.27397610e+00, 4.04632060e+00, 1887.10
12, 1.09950505e+00, 4.08665265e+00, 1887.10
13, 1.01686809e+00, 4.10543978e+00, 1887.10
14, 9.62496045e-01, 4.11776744e+00, 1887.10
15, 8.30742658e-01, 4.14771050e+00, 1887.10
16, 7.54658503e-01, 4.16472755e+00, 1887.10
17, 6.97633203e-01, 4.17736234e+00, 1887.10
18, 6.09044074e-01, 4.19699293e+00, 1887.10
19, 5.74370142e-01, 4.20463616e+00, 1887.10
20, 5.47074792e-01, 4.21067073e+00, 1887.10
21, 4.93735822e-01, 4.22259198e+00, 1887.10
22, 4.60063338e-01, 4.23017365e+00, 1887.10
23, 4.36327929e-01, 4.23556708e+00, 1887.10
24, 4.22122183e-01, 4.23882770e+00, 1887.10
25, 4.07458113e-01, 4.24221920e+00, 1887.10
26, 3.86592624e-01, 4.24709560e+00, 1887.10
27, 3.67773193e-01, 4.25156603e+00, 1887.10
28, 3.51352487e-01, 4.25554085e+00, 1887.10
29, 3.37303201e-01, 4.25900523e+00, 1887.10
30, 3.32705820e-01, 4.26015230e+00, 1887.10
31, 3.16792358e-01, 4.26419592e+00, 1887.10
32, 3.02864662e-01, 4.26783713e+00, 1887.10
33, 2.92696259e-01, 4.27056620e+00, 1887.10
34, 2.79480043e-01, 4.27422411e+00, 1887.10
35, 2.69498835e-01, 4.27707327e+00, 1887.10
36, 2.60982189e-01, 4.27956963e+00, 1887.10
37, 2.55407974e-01, 4.28123787e+00, 1887.10
38, 2.44748328e-01, 4.28450471e+00, 1887.10
39, 2.34985558e-01, 4.28758357e+00, 1887.10
40, 2.24014319e-01, 4.29114831e+00, 1887.10
41, 2.20511592e-01, 4.29230893e+00, 1887.10
42, 2.15047233e-01, 4.29414141e+00, 1887.10
43, 2.10788939e-01, 4.29558664e+00, 1887.10
44, 2.00735989e-01, 4.29905867e+00, 1887.10
45, 1.88971778e-01, 4.30321700e+00, 1887.10
46, 1.78014403e-01, 4.30716195e+00, 1887.10
47, 1.71872318e-01, 4.30939586e+00, 1887.10
48, 1.68601238e-01, 4.31059084e+00, 1887.10
49, 1.59768365e-01, 4.31382943e+00, 1887.10
50, 1.53117654e-01, 4.31627224e+00, 1887.10
```

## arquivo convergence_history_60x60_G2_sparse_precond.csv
```csv
Iteration,ResidualNorm,SolutionNorm,ExecutionTime_ms
1, 2.72014132e+01, 0.00000000e+00, 1837.99
2, 8.78975958e+00, 5.18085941e+00, 1837.99
3, 5.12351791e+00, 5.79821908e+00, 1837.99
4, 4.14430725e+00, 5.97246712e+00, 1837.99
5, 3.38780189e+00, 6.11609297e+00, 1837.99
6, 3.23059750e+00, 6.14586604e+00, 1837.99
7, 3.02412857e+00, 6.18577967e+00, 1837.99
8, 2.66597172e+00, 6.25856680e+00, 1837.99
9, 2.31106204e+00, 6.33345313e+00, 1837.99
10, 2.18561181e+00, 6.36020514e+00, 1837.99
11, 2.11826524e+00, 6.37467736e+00, 1837.99
12, 1.80702862e+00, 6.44401203e+00, 1837.99
13, 1.64602144e+00, 6.48088560e+00, 1837.99
14, 1.58552775e+00, 6.49496220e+00, 1837.99
15, 1.47557885e+00, 6.52118275e+00, 1837.99
16, 1.36978702e+00, 6.54722155e+00, 1837.99
17, 1.29300295e+00, 6.56667185e+00, 1837.99
18, 1.23487904e+00, 6.58185788e+00, 1837.99
19, 1.13326610e+00, 6.60969358e+00, 1837.99
20, 1.08815655e+00, 6.62253628e+00, 1837.99
21, 1.05133480e+00, 6.63333116e+00, 1837.99
22, 9.66160851e-01, 6.65954139e+00, 1837.99
23, 9.26190593e-01, 6.67241909e+00, 1837.99
24, 8.63703021e-01, 6.69353034e+00, 1837.99
25, 8.37768116e-01, 6.70263124e+00, 1837.99
26, 8.26667351e-01, 6.70659592e+00, 1837.99
27, 7.90428543e-01, 6.71986170e+00, 1837.99
28, 7.61820110e-01, 6.73067650e+00, 1837.99
29, 7.35038148e-01, 6.74110382e+00, 1837.99
30, 7.13673675e-01, 6.74964894e+00, 1837.99
31, 7.07278408e-01, 6.75224706e+00, 1837.99
32, 6.76311067e-01, 6.76512932e+00, 1837.99
33, 6.52025527e-01, 6.77556899e+00, 1837.99
34, 6.24402267e-01, 6.78783872e+00, 1837.99
35, 6.00520763e-01, 6.79878969e+00, 1837.99
36, 5.75033134e-01, 6.81083635e+00, 1837.99
37, 5.56581723e-01, 6.81978796e+00, 1837.99
38, 5.43583213e-01, 6.82620307e+00, 1837.99
39, 5.14613674e-01, 6.84081709e+00, 1837.99
40, 4.88693549e-01, 6.85421596e+00, 1837.99
41, 4.61734302e-01, 6.86842760e+00, 1837.99
42, 4.53434153e-01, 6.87284817e+00, 1837.99
43, 4.31372554e-01, 6.88468598e+00, 1837.99
44, 4.24927622e-01, 6.88816216e+00, 1837.99
45, 4.03899413e-01, 6.89955280e+00, 1837.99
46, 3.79463832e-01, 6.91282348e+00, 1837.99
47, 3.52241882e-01, 6.92758657e+00, 1837.99
48, 3.42441288e-01, 6.93287875e+00, 1837.99
49, 3.32917285e-01, 6.93800372e+00, 1837.99
50, 3.17716165e-01, 6.94614282e+00, 1837.99
```

## arquivo convergence_history_60x60_G2_sparse_standard.csv
```csv
Iteration,ResidualNorm,SolutionNorm,ExecutionTime_ms
1, 2.72014132e+01, 0.00000000e+00, 1840.11
2, 8.78975958e+00, 5.18085941e+00, 1840.11
3, 5.12351791e+00, 5.79821908e+00, 1840.11
4, 4.14430725e+00, 5.97246712e+00, 1840.11
5, 3.38780189e+00, 6.11609297e+00, 1840.11
6, 3.23059750e+00, 6.14586604e+00, 1840.11
7, 3.02412857e+00, 6.18577967e+00, 1840.11
8, 2.66597172e+00, 6.25856680e+00, 1840.11
9, 2.31106204e+00, 6.33345313e+00, 1840.11
10, 2.18561181e+00, 6.36020514e+00, 1840.11
11, 2.11826524e+00, 6.37467736e+00, 1840.11
12, 1.80702862e+00, 6.44401203e+00, 1840.11
13, 1.64602144e+00, 6.48088560e+00, 1840.11
14, 1.58552775e+00, 6.49496220e+00, 1840.11
15, 1.47557885e+00, 6.52118275e+00, 1840.11
16, 1.36978702e+00, 6.54722155e+00, 1840.11
17, 1.29300295e+00, 6.56667185e+00, 1840.11
18, 1.23487904e+00, 6.58185788e+00, 1840.11
19, 1.13326610e+00, 6.60969358e+00, 1840.11
20, 1.08815655e+00, 6.62253628e+00, 1840.11
21, 1.05133480e+00, 6.63333116e+00, 1840.11
22, 9.66160851e-01, 6.65954139e+00, 1840.11
23, 9.26190593e-01, 6.67241909e+00, 1840.11
24, 8.63703021e-01, 6.69353034e+00, 1840.11
25, 8.37768116e-01, 6.70263124e+00, 1840.11
26, 8.26667351e-01, 6.70659592e+00, 1840.11
27, 7.90428543e-01, 6.71986170e+00, 1840.11
28, 7.61820110e-01, 6.73067650e+00, 1840.11
29, 7.35038148e-01, 6.74110382e+00, 1840.11
30, 7.13673675e-01, 6.74964894e+00, 1840.11
31, 7.07278408e-01, 6.75224706e+00, 1840.11
32, 6.76311067e-01, 6.76512932e+00, 1840.11
33, 6.52025527e-01, 6.77556899e+00, 1840.11
34, 6.24402267e-01, 6.78783872e+00, 1840.11
35, 6.00520763e-01, 6.79878969e+00, 1840.11
36, 5.75033134e-01, 6.81083635e+00, 1840.11
37, 5.56581723e-01, 6.81978796e+00, 1840.11
38, 5.43583213e-01, 6.82620307e+00, 1840.11
39, 5.14613674e-01, 6.84081709e+00, 1840.11
40, 4.88693549e-01, 6.85421596e+00, 1840.11
41, 4.61734302e-01, 6.86842760e+00, 1840.11
42, 4.53434153e-01, 6.87284817e+00, 1840.11
43, 4.31372554e-01, 6.88468598e+00, 1840.11
44, 4.24927622e-01, 6.88816216e+00, 1840.11
45, 4.03899413e-01, 6.89955280e+00, 1840.11
46, 3.79463832e-01, 6.91282348e+00, 1840.11
47, 3.52241882e-01, 6.92758657e+00, 1840.11
48, 3.42441288e-01, 6.93287875e+00, 1840.11
49, 3.32917285e-01, 6.93800372e+00, 1840.11
50, 3.17716165e-01, 6.94614282e+00, 1840.11
```

## arquivo lcurve_30x30_g1_sparse_precond.csv
```csv
Iteration,SolutionNorm,ResidualNorm
1,0.00000000e+00,9.67196382e+00
2,1.55898777e+00,3.07252139e+00
3,1.77603493e+00,1.53729417e+00
4,1.79399258e+00,1.39883468e+00
5,1.84883524e+00,1.01019361e+00
6,1.86481978e+00,8.97468112e-01
7,1.86894946e+00,8.68404273e-01
8,1.90461444e+00,6.28412797e-01
9,1.91467888e+00,5.59264782e-01
10,1.91887859e+00,5.30052585e-01
11,1.92355181e+00,4.97479833e-01
12,1.93544815e+00,4.14268921e-01
13,1.94220317e+00,3.65674578e-01
14,1.94721209e+00,3.29254234e-01
15,1.95075872e+00,3.03495583e-01
16,1.95419823e+00,2.78732101e-01
17,1.95561550e+00,2.68664181e-01
18,1.95882596e+00,2.46373566e-01
19,1.96191567e+00,2.25538000e-01
20,1.96495649e+00,2.05668964e-01
21,1.96645522e+00,1.96093519e-01
22,1.96812171e+00,1.85659999e-01
23,1.97005770e+00,1.73864957e-01
24,1.97185532e+00,1.63240358e-01
25,1.97383060e+00,1.51970632e-01
26,1.97438909e+00,1.48852344e-01
27,1.97638024e+00,1.37982239e-01
28,1.97737932e+00,1.32656763e-01
29,1.97870045e+00,1.25749048e-01
30,1.97911473e+00,1.23607305e-01
31,1.98090328e+00,1.14523371e-01
32,1.98280764e+00,1.05095830e-01
33,1.98370216e+00,1.00734155e-01
34,1.98536222e+00,9.27383430e-02
35,1.98676886e+00,8.60193691e-02
36,1.98719857e+00,8.39698276e-02
37,1.98844424e+00,7.80321740e-02
38,1.98943704e+00,7.32812572e-02
39,1.99064716e+00,6.74433522e-02
40,1.99125831e+00,6.44618592e-02
41,1.99184752e+00,6.15617841e-02
42,1.99261786e+00,5.77193876e-02
43,1.99277308e+00,5.69357620e-02
44,1.99378588e+00,5.17399209e-02
45,1.99453063e+00,4.77952867e-02
46,1.99568957e+00,4.13555914e-02
47,1.99582484e+00,4.05709750e-02
48,1.99642400e+00,3.69892680e-02
49,1.99702200e+00,3.31973231e-02
50,1.99731703e+00,3.12226361e-02
```

## arquivo lcurve_30x30_g1_sparse_standard.csv
```csv
Iteration,SolutionNorm,ResidualNorm
1,0.00000000e+00,9.67196382e+00
2,1.55898777e+00,3.07252139e+00
3,1.77603493e+00,1.53729417e+00
4,1.79399258e+00,1.39883468e+00
5,1.84883524e+00,1.01019361e+00
6,1.86481978e+00,8.97468112e-01
7,1.86894946e+00,8.68404273e-01
8,1.90461444e+00,6.28412797e-01
9,1.91467888e+00,5.59264782e-01
10,1.91887859e+00,5.30052585e-01
11,1.92355181e+00,4.97479833e-01
12,1.93544815e+00,4.14268921e-01
13,1.94220317e+00,3.65674578e-01
14,1.94721209e+00,3.29254234e-01
15,1.95075872e+00,3.03495583e-01
16,1.95419823e+00,2.78732101e-01
17,1.95561550e+00,2.68664181e-01
18,1.95882596e+00,2.46373566e-01
19,1.96191567e+00,2.25538000e-01
20,1.96495649e+00,2.05668964e-01
21,1.96645522e+00,1.96093519e-01
22,1.96812171e+00,1.85659999e-01
23,1.97005770e+00,1.73864957e-01
24,1.97185532e+00,1.63240358e-01
25,1.97383060e+00,1.51970632e-01
26,1.97438909e+00,1.48852344e-01
27,1.97638024e+00,1.37982239e-01
28,1.97737932e+00,1.32656763e-01
29,1.97870045e+00,1.25749048e-01
30,1.97911473e+00,1.23607305e-01
31,1.98090328e+00,1.14523371e-01
32,1.98280764e+00,1.05095830e-01
33,1.98370216e+00,1.00734155e-01
34,1.98536222e+00,9.27383430e-02
35,1.98676886e+00,8.60193691e-02
36,1.98719857e+00,8.39698276e-02
37,1.98844424e+00,7.80321740e-02
38,1.98943704e+00,7.32812572e-02
39,1.99064716e+00,6.74433522e-02
40,1.99125831e+00,6.44618592e-02
41,1.99184752e+00,6.15617841e-02
42,1.99261786e+00,5.77193876e-02
43,1.99277308e+00,5.69357620e-02
44,1.99378588e+00,5.17399209e-02
45,1.99453063e+00,4.77952867e-02
46,1.99568957e+00,4.13555914e-02
47,1.99582484e+00,4.05709750e-02
48,1.99642400e+00,3.69892680e-02
49,1.99702200e+00,3.31973231e-02
50,1.99731703e+00,3.12226361e-02
```

## arquivo lcurve_30x30_g2_sparse_precond.csv
```csv
Iteration,SolutionNorm,ResidualNorm
1,0.00000000e+00,1.20736878e+01
2,1.87462201e+00,4.02351777e+00
3,1.92042055e+00,3.65398977e+00
4,2.02751235e+00,2.89073698e+00
5,2.10462469e+00,2.36115773e+00
6,2.17845004e+00,1.84100587e+00
7,2.20365158e+00,1.65829698e+00
8,2.22203672e+00,1.52680971e+00
9,2.25500822e+00,1.29867800e+00
10,2.29328838e+00,1.04314309e+00
11,2.30689009e+00,9.52876436e-01
12,2.32457823e+00,8.36827460e-01
13,2.34472561e+00,7.05063906e-01
14,2.35726912e+00,6.21843740e-01
15,2.36910719e+00,5.42210316e-01
16,2.37946642e+00,4.71904883e-01
17,2.38676801e+00,4.22139493e-01
18,2.39307923e+00,3.79399672e-01
19,2.39790904e+00,3.47102850e-01
20,2.40146776e+00,3.23602566e-01
21,2.40635206e+00,2.91820472e-01
22,2.41026993e+00,2.66636569e-01
23,2.41281187e+00,2.50468187e-01
24,2.41406651e+00,2.42540978e-01
25,2.41658517e+00,2.26735977e-01
26,2.41840525e+00,2.15403395e-01
27,2.41936889e+00,2.09439014e-01
28,2.42141240e+00,1.96883253e-01
29,2.42434817e+00,1.79024616e-01
30,2.42713125e+00,1.62278098e-01
31,2.42929646e+00,1.49359351e-01
32,2.43076747e+00,1.40612539e-01
33,2.43279226e+00,1.28604897e-01
34,2.43363739e+00,1.23590971e-01
35,2.43467614e+00,1.17413038e-01
36,2.43652404e+00,1.06360514e-01
37,2.43786257e+00,9.82513480e-02
38,2.43848301e+00,9.44520797e-02
39,2.43933224e+00,8.92032748e-02
40,2.44054084e+00,8.16144141e-02
41,2.44109713e+00,7.80644355e-02
42,2.44181197e+00,7.34411349e-02
43,2.44277183e+00,6.70947154e-02
44,2.44317600e+00,6.43651366e-02
45,2.44350750e+00,6.20965302e-02
46,2.44425717e+00,5.68552688e-02
47,2.44497562e+00,5.16576625e-02
48,2.44563559e+00,4.66946130e-02
49,2.44618314e+00,4.23960938e-02
50,2.44669296e+00,3.81925719e-02
```

## arquivo lcurve_30x30_g2_sparse_standard.csv
```csv
Iteration,SolutionNorm,ResidualNorm
1,0.00000000e+00,1.20736878e+01
2,1.87462201e+00,4.02351777e+00
3,1.92042055e+00,3.65398977e+00
4,2.02751235e+00,2.89073698e+00
5,2.10462469e+00,2.36115773e+00
6,2.17845004e+00,1.84100587e+00
7,2.20365158e+00,1.65829698e+00
8,2.22203672e+00,1.52680971e+00
9,2.25500822e+00,1.29867800e+00
10,2.29328838e+00,1.04314309e+00
11,2.30689009e+00,9.52876436e-01
12,2.32457823e+00,8.36827460e-01
13,2.34472561e+00,7.05063906e-01
14,2.35726912e+00,6.21843740e-01
15,2.36910719e+00,5.42210316e-01
16,2.37946642e+00,4.71904883e-01
17,2.38676801e+00,4.22139493e-01
18,2.39307923e+00,3.79399672e-01
19,2.39790904e+00,3.47102850e-01
20,2.40146776e+00,3.23602566e-01
21,2.40635206e+00,2.91820472e-01
22,2.41026993e+00,2.66636569e-01
23,2.41281187e+00,2.50468187e-01
24,2.41406651e+00,2.42540978e-01
25,2.41658517e+00,2.26735977e-01
26,2.41840525e+00,2.15403395e-01
27,2.41936889e+00,2.09439014e-01
28,2.42141240e+00,1.96883253e-01
29,2.42434817e+00,1.79024616e-01
30,2.42713125e+00,1.62278098e-01
31,2.42929646e+00,1.49359351e-01
32,2.43076747e+00,1.40612539e-01
33,2.43279226e+00,1.28604897e-01
34,2.43363739e+00,1.23590971e-01
35,2.43467614e+00,1.17413038e-01
36,2.43652404e+00,1.06360514e-01
37,2.43786257e+00,9.82513480e-02
38,2.43848301e+00,9.44520797e-02
39,2.43933224e+00,8.92032748e-02
40,2.44054084e+00,8.16144141e-02
41,2.44109713e+00,7.80644355e-02
42,2.44181197e+00,7.34411349e-02
43,2.44277183e+00,6.70947154e-02
44,2.44317600e+00,6.43651366e-02
45,2.44350750e+00,6.20965302e-02
46,2.44425717e+00,5.68552688e-02
47,2.44497562e+00,5.16576625e-02
48,2.44563559e+00,4.66946130e-02
49,2.44618314e+00,4.23960938e-02
50,2.44669296e+00,3.81925719e-02
```

## arquivo lcurve_60x60_G1_sparse_precond.csv
```csv
Iteration,SolutionNorm,ResidualNorm
1,0.00000000e+00,1.54640017e+01
2,2.95333226e+00,6.17186055e+00
3,3.53454207e+00,3.55670287e+00
4,3.65843662e+00,2.99761919e+00
5,3.79383539e+00,2.39219064e+00
6,3.83375295e+00,2.20794552e+00
7,3.86563639e+00,2.06309467e+00
8,3.95979300e+00,1.65101719e+00
9,3.98705940e+00,1.53108700e+00
10,3.99666487e+00,1.48873863e+00
11,4.04632060e+00,1.27397610e+00
12,4.08665265e+00,1.09950505e+00
13,4.10543978e+00,1.01686809e+00
14,4.11776744e+00,9.62496045e-01
15,4.14771050e+00,8.30742658e-01
16,4.16472755e+00,7.54658503e-01
17,4.17736234e+00,6.97633203e-01
18,4.19699293e+00,6.09044074e-01
19,4.20463616e+00,5.74370142e-01
20,4.21067073e+00,5.47074792e-01
21,4.22259198e+00,4.93735822e-01
22,4.23017365e+00,4.60063338e-01
23,4.23556708e+00,4.36327929e-01
24,4.23882770e+00,4.22122183e-01
25,4.24221920e+00,4.07458113e-01
26,4.24709560e+00,3.86592624e-01
27,4.25156603e+00,3.67773193e-01
28,4.25554085e+00,3.51352487e-01
29,4.25900523e+00,3.37303201e-01
30,4.26015230e+00,3.32705820e-01
31,4.26419592e+00,3.16792358e-01
32,4.26783713e+00,3.02864662e-01
33,4.27056620e+00,2.92696259e-01
34,4.27422411e+00,2.79480043e-01
35,4.27707327e+00,2.69498835e-01
36,4.27956963e+00,2.60982189e-01
37,4.28123787e+00,2.55407974e-01
38,4.28450471e+00,2.44748328e-01
39,4.28758357e+00,2.34985558e-01
40,4.29114831e+00,2.24014319e-01
41,4.29230893e+00,2.20511592e-01
42,4.29414141e+00,2.15047233e-01
43,4.29558664e+00,2.10788939e-01
44,4.29905867e+00,2.00735989e-01
45,4.30321700e+00,1.88971778e-01
46,4.30716195e+00,1.78014403e-01
47,4.30939586e+00,1.71872318e-01
48,4.31059084e+00,1.68601238e-01
49,4.31382943e+00,1.59768365e-01
50,4.31627224e+00,1.53117654e-01
```

## arquivo lcurve_60x60_G1_sparse_standard.csv
```csv
Iteration,SolutionNorm,ResidualNorm
1,0.00000000e+00,1.54640017e+01
2,2.95333226e+00,6.17186055e+00
3,3.53454207e+00,3.55670287e+00
4,3.65843662e+00,2.99761919e+00
5,3.79383539e+00,2.39219064e+00
6,3.83375295e+00,2.20794552e+00
7,3.86563639e+00,2.06309467e+00
8,3.95979300e+00,1.65101719e+00
9,3.98705940e+00,1.53108700e+00
10,3.99666487e+00,1.48873863e+00
11,4.04632060e+00,1.27397610e+00
12,4.08665265e+00,1.09950505e+00
13,4.10543978e+00,1.01686809e+00
14,4.11776744e+00,9.62496045e-01
15,4.14771050e+00,8.30742658e-01
16,4.16472755e+00,7.54658503e-01
17,4.17736234e+00,6.97633203e-01
18,4.19699293e+00,6.09044074e-01
19,4.20463616e+00,5.74370142e-01
20,4.21067073e+00,5.47074792e-01
21,4.22259198e+00,4.93735822e-01
22,4.23017365e+00,4.60063338e-01
23,4.23556708e+00,4.36327929e-01
24,4.23882770e+00,4.22122183e-01
25,4.24221920e+00,4.07458113e-01
26,4.24709560e+00,3.86592624e-01
27,4.25156603e+00,3.67773193e-01
28,4.25554085e+00,3.51352487e-01
29,4.25900523e+00,3.37303201e-01
30,4.26015230e+00,3.32705820e-01
31,4.26419592e+00,3.16792358e-01
32,4.26783713e+00,3.02864662e-01
33,4.27056620e+00,2.92696259e-01
34,4.27422411e+00,2.79480043e-01
35,4.27707327e+00,2.69498835e-01
36,4.27956963e+00,2.60982189e-01
37,4.28123787e+00,2.55407974e-01
38,4.28450471e+00,2.44748328e-01
39,4.28758357e+00,2.34985558e-01
40,4.29114831e+00,2.24014319e-01
41,4.29230893e+00,2.20511592e-01
42,4.29414141e+00,2.15047233e-01
43,4.29558664e+00,2.10788939e-01
44,4.29905867e+00,2.00735989e-01
45,4.30321700e+00,1.88971778e-01
46,4.30716195e+00,1.78014403e-01
47,4.30939586e+00,1.71872318e-01
48,4.31059084e+00,1.68601238e-01
49,4.31382943e+00,1.59768365e-01
50,4.31627224e+00,1.53117654e-01
```

## arquivo lcurve_60x60_G2_sparse_precond.csv
```csv
Iteration,SolutionNorm,ResidualNorm
1,0.00000000e+00,2.72014132e+01
2,5.18085941e+00,8.78975958e+00
3,5.79821908e+00,5.12351791e+00
4,5.97246712e+00,4.14430725e+00
5,6.11609297e+00,3.38780189e+00
6,6.14586604e+00,3.23059750e+00
7,6.18577967e+00,3.02412857e+00
8,6.25856680e+00,2.66597172e+00
9,6.33345313e+00,2.31106204e+00
10,6.36020514e+00,2.18561181e+00
11,6.37467736e+00,2.11826524e+00
12,6.44401203e+00,1.80702862e+00
13,6.48088560e+00,1.64602144e+00
14,6.49496220e+00,1.58552775e+00
15,6.52118275e+00,1.47557885e+00
16,6.54722155e+00,1.36978702e+00
17,6.56667185e+00,1.29300295e+00
18,6.58185788e+00,1.23487904e+00
19,6.60969358e+00,1.13326610e+00
20,6.62253628e+00,1.08815655e+00
21,6.63333116e+00,1.05133480e+00
22,6.65954139e+00,9.66160851e-01
23,6.67241909e+00,9.26190593e-01
24,6.69353034e+00,8.63703021e-01
25,6.70263124e+00,8.37768116e-01
26,6.70659592e+00,8.26667351e-01
27,6.71986170e+00,7.90428543e-01
28,6.73067650e+00,7.61820110e-01
29,6.74110382e+00,7.35038148e-01
30,6.74964894e+00,7.13673675e-01
31,6.75224706e+00,7.07278408e-01
32,6.76512932e+00,6.76311067e-01
33,6.77556899e+00,6.52025527e-01
34,6.78783872e+00,6.24402267e-01
35,6.79878969e+00,6.00520763e-01
36,6.81083635e+00,5.75033134e-01
37,6.81978796e+00,5.56581723e-01
38,6.82620307e+00,5.43583213e-01
39,6.84081709e+00,5.14613674e-01
40,6.85421596e+00,4.88693549e-01
41,6.86842760e+00,4.61734302e-01
42,6.87284817e+00,4.53434153e-01
43,6.88468598e+00,4.31372554e-01
44,6.88816216e+00,4.24927622e-01
45,6.89955280e+00,4.03899413e-01
46,6.91282348e+00,3.79463832e-01
47,6.92758657e+00,3.52241882e-01
48,6.93287875e+00,3.42441288e-01
49,6.93800372e+00,3.32917285e-01
50,6.94614282e+00,3.17716165e-01
```

## arquivo lcurve_60x60_G2_sparse_standard.csv
```csv
Iteration,SolutionNorm,ResidualNorm
1,0.00000000e+00,2.72014132e+01
2,5.18085941e+00,8.78975958e+00
3,5.79821908e+00,5.12351791e+00
4,5.97246712e+00,4.14430725e+00
5,6.11609297e+00,3.38780189e+00
6,6.14586604e+00,3.23059750e+00
7,6.18577967e+00,3.02412857e+00
8,6.25856680e+00,2.66597172e+00
9,6.33345313e+00,2.31106204e+00
10,6.36020514e+00,2.18561181e+00
11,6.37467736e+00,2.11826524e+00
12,6.44401203e+00,1.80702862e+00
13,6.48088560e+00,1.64602144e+00
14,6.49496220e+00,1.58552775e+00
15,6.52118275e+00,1.47557885e+00
16,6.54722155e+00,1.36978702e+00
17,6.56667185e+00,1.29300295e+00
18,6.58185788e+00,1.23487904e+00
19,6.60969358e+00,1.13326610e+00
20,6.62253628e+00,1.08815655e+00
21,6.63333116e+00,1.05133480e+00
22,6.65954139e+00,9.66160851e-01
23,6.67241909e+00,9.26190593e-01
24,6.69353034e+00,8.63703021e-01
25,6.70263124e+00,8.37768116e-01
26,6.70659592e+00,8.26667351e-01
27,6.71986170e+00,7.90428543e-01
28,6.73067650e+00,7.61820110e-01
29,6.74110382e+00,7.35038148e-01
30,6.74964894e+00,7.13673675e-01
31,6.75224706e+00,7.07278408e-01
32,6.76512932e+00,6.76311067e-01
33,6.77556899e+00,6.52025527e-01
34,6.78783872e+00,6.24402267e-01
35,6.79878969e+00,6.00520763e-01
36,6.81083635e+00,5.75033134e-01
37,6.81978796e+00,5.56581723e-01
38,6.82620307e+00,5.43583213e-01
39,6.84081709e+00,5.14613674e-01
40,6.85421596e+00,4.88693549e-01
41,6.86842760e+00,4.61734302e-01
42,6.87284817e+00,4.53434153e-01
43,6.88468598e+00,4.31372554e-01
44,6.88816216e+00,4.24927622e-01
45,6.89955280e+00,4.03899413e-01
46,6.91282348e+00,3.79463832e-01
47,6.92758657e+00,3.52241882e-01
48,6.93287875e+00,3.42441288e-01
49,6.93800372e+00,3.32917285e-01
50,6.94614282e+00,3.17716165e-01
```

## arquivo run_and_log.sh
```bash
#!/bin/bash

# Verifica se o caminho do executável foi passado
if [ -z "$1" ]; then
  echo "Erro: Caminho do executável não fornecido."
  exit 1
fi

EXECUTABLE_PATH="$1"
# Pega todos os argumentos a partir do segundo (se houver)
shift # Remove o primeiro argumento (o caminho do executável)
PROGRAM_ARGS="$@" # Junta o resto

# Cria o nome do arquivo de log com data e hora
TIMESTAMP=$(date +"%d-%m-%Y--%H-%M-%S")
LOG_DIR="doc"
LOG_FILENAME="$LOG_DIR/CPL_RUN_$TIMESTAMP.md"

# Garante que o diretório 'doc' exista
mkdir -p "$LOG_DIR"

echo "--- Executando '$EXECUTABLE_PATH $PROGRAM_ARGS' ---"
echo "--- Log de execução será salvo em: '$LOG_FILENAME' ---"

# Executa o comando, redireciona stdout e stderr (2>&1),
# mostra no console (tee) e salva no arquivo.
# Usamos 'script' para capturar melhor a saída, incluindo cores se houver
script -q -c "$EXECUTABLE_PATH $PROGRAM_ARGS" /dev/null | tee "$LOG_FILENAME"

# Pega o código de saída do comando executado
# OBS: O código de saída capturado aqui pode ser do 'tee', não do executável diretamente
# Uma forma mais robusta seria executar sem o 'tee' primeiro, pegar o código, e depois rodar de novo com 'tee',
# mas isso executaria o programa duas vezes. Para logs, isso geralmente é suficiente.
EXIT_CODE=$?

echo "--- Execução concluída (Código de Saída: $EXIT_CODE) ---"

# Sai do script bash com o código de saída capturado
exit $EXIT_CODE
```

